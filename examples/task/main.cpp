/**
 * @file main.cpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <cmath>
#include <future>
#include <vector>
#include <functional>
#include <iostream>

#include <util/logger.hpp>
#include <messaging/async.hpp>
#include <messaging/process_manager.hpp>

//=============================================================================

int fib(int n) {
  if (n < 3) return 1;
  else
    return fib(n - 1) + fib(n - 2);
}

double mypow(double x, double y) {
  return std::pow(x, y);
}

struct ObjType {
  int a;
  int add(int b) { return a + b; }
};

//=============================================================================

static void init_debug_streams() __attribute__((constructor));
static void init_debug_streams() {
  using namespace util::logger;
  for (auto && stream : std::vector<costream *> {&info, &debug, &trace, &warning, &error, &stats}) {
    stream->enable(true);
    stream->show_thread(true);
    stream->show_linenumber(true);
    stream->show_time(true);
  }
}

int main() {
  TRACER_FUNC();

  // Instantiate process manager
  using process_type_worker = messaging::multithread::std_thread_types;
  messaging::process_manager<process_type_worker> manager;

  // Instantiate the worker process and attach to process manager
  messaging::process myworker = manager.add<process_type_worker>("myworker", messaging::create_worker_process<process_type_worker>());

  // Add event callbacks
  myworker.on_start([] { info << "Worker ready for processing." << std::endl; })
    .on_finish([] { info << "Worker closed." << std::endl; })
    .on_exception([](auto & process, std::exception_ptr e) {
      error << "Exception caught in system (" << process.template name<std::string>() << ")!" << std::endl;
      std::rethrow_exception(e);
    });

  info << "Sending work packages to worker '" << messaging::await<messaging::get_process_name>(myworker).get() << '\'' << std::endl;
  std::future<int> fib_fut = messaging::async<int>(myworker, fib, 42);
  std::future<double> pow_fut = messaging::async<double>(myworker, mypow, 2.0, 11.5);
  ObjType obj {11};
  std::future<int> add_fut = messaging::async<int>(myworker, &ObjType::add, &obj, 9);

  // Wait for results from worker (optional step, .get() on future also does a wait)
  fib_fut.wait();
  pow_fut.wait();
  add_fut.wait();

  info << "Result of fibonaci: " << fib_fut.get() << std::endl;
  info << "Result of power: " << pow_fut.get() << std::endl;
  info << "Result of obj.add: " << add_fut.get() << std::endl;

  // Close worker
  myworker.done();

  //* Wait until all processes are finished
  using namespace std::chrono_literals;
  manager.run_every(100ms);

  TRACER_RETURN(EXIT_SUCCESS);
}
