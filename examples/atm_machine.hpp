/**
 * @file atm_machine.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <functional>
#include <atm_messages.hpp>

template <typename Process, typename BankSender, typename InterfaceSender>
class atm final : public Process {

  using self = atm;
  using sender_type = typename Process::sender_type;
  using dispatcher_type = typename Process::dispatcher_type;

  BankSender bank;
  InterfaceSender interface_hardware;

  std::string account;
  unsigned withdrawal_amount;
  std::string pin;

  template <typename F>
  inline auto bind(F && f) {
    return std::bind(f, this, std::placeholders::_1);
  }

  class {
    std::function<void(dispatcher_type &)> f;
    bool c = false;

  public:
    void on_change(std::function<void()> p) {
      if (c) {
        p();
        c = false;
      }
    }

    void operator=(decltype(f) f_) {
      f = f_;
      c = true;
    }

    void operator()(dispatcher_type & d) { f(d); }
  } state;

  void process_withdrawal(dispatcher_type & dispatcher) {
    dispatcher
      .template handle<withdraw_ok>([&](withdraw_ok const &) {
        interface_hardware.send(issue_money(withdrawal_amount));
        bank.send(withdrawal_processed(account, withdrawal_amount));
        state = bind(&self::done_processing);
      })
      .template handle<withdraw_denied>([&](withdraw_denied const &) {
        interface_hardware.send(display_insufficient_funds());
        state = bind(&self::done_processing);
      })
      .template handle<cancel_pressed>([&](cancel_pressed const &) {
        bank.send(cancel_withdrawal(account, withdrawal_amount));
        interface_hardware.send(display_withdrawal_cancelled());
        state = bind(&self::done_processing);
      });
  }

  void process_balance(dispatcher_type & dispatcher) {
    dispatcher
      .template handle<balance>([&](balance const & msg) {
        interface_hardware.send(display_balance(msg.amount));
        state = bind(&self::wait_for_action);
      })
      .template handle<cancel_pressed>([&](cancel_pressed const &) { state = bind(&self::done_processing); });
  }

  void wait_for_action(dispatcher_type & dispatcher) {
    state.on_change([&] { interface_hardware.send(display_withdrawal_options()); });
    dispatcher
      .template handle<withdraw_pressed>([&](withdraw_pressed const & msg) {
        withdrawal_amount = msg.amount;
        bank.send(withdraw<sender_type>(account, msg.amount, this->get_sender()));
        state = bind(&self::process_withdrawal);
      })
      .template handle<balance_pressed>([&](balance_pressed const &) {
        bank.send(get_balance<sender_type>(account, this->get_sender()));
        state = bind(&self::process_balance);
      })
      .template handle<cancel_pressed>([&](cancel_pressed const &) { state = bind(&self::done_processing); });
  }

  void verifying_pin(dispatcher_type & dispatcher) {
    dispatcher.template handle<pin_verified>([&](pin_verified const &) { state = bind(&self::wait_for_action); })
      .template handle<pin_incorrect>([&](pin_incorrect const &) {
        interface_hardware.send(display_pin_incorrect_message());
        state = bind(&self::done_processing);
      })
      .template handle<cancel_pressed>([&](cancel_pressed const &) { state = bind(&self::done_processing); });
  }

  void getting_pin(dispatcher_type & dispatcher) {
    dispatcher
      .template handle<digit_pressed>([&](digit_pressed const & msg) {
        unsigned const pin_length = 4;
        pin += msg.digit;
        if (pin.length() == pin_length) {
          bank.send(verify_pin<sender_type>(account, pin, this->get_sender()));
          state = bind(&self::verifying_pin);
        }
      })
      .template handle<clear_last_pressed>([&](clear_last_pressed const &) {
        if (!pin.empty()) {
          pin.pop_back();
        }
      })
      .template handle<cancel_pressed>([&](cancel_pressed const &) { state = bind(&self::done_processing); });
  }

  void waiting_for_card(dispatcher_type & dispatcher) {
    state.on_change([&] { interface_hardware.send(display_enter_card()); });
    dispatcher.template handle<card_inserted>([&](card_inserted const & msg) {
      account = msg.account;
      pin = "";
      interface_hardware.send(display_enter_pin());
      state = bind(&self::getting_pin);
    });
  }

  void done_processing(dispatcher_type &) {
    state.on_change([&] { interface_hardware.send(eject_card()); });
    state = bind(&self::waiting_for_card);
  }

  void dispatch(dispatcher_type & dispatcher) override { state(dispatcher); }

public:

  // Constructor when using 'add' to process manager
  atm(BankSender bank_, InterfaceSender interface_hardware_, bool auto_start = true)
  : Process(auto_start), bank(bank_), interface_hardware(interface_hardware_) {
    state = bind(&self::waiting_for_card);
  }

  // Constructor when using 'emplace_process' to process manager
  atm(typename Process::dictionary_type & dict, typename Process::name_ref_type ref, BankSender bank_, InterfaceSender interface_hardware_,
    bool auto_start = true)
  : Process(dict, ref, auto_start), bank(bank_), interface_hardware(interface_hardware_) {
    state = bind(&self::waiting_for_card);
  }
};
