/**
 * @file test_type_info.cpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <set>

#include <util/type_info.hpp>
#include <util/algorithm.hpp>

#include <gtest/gtest.h>

enum Enum1 {};
enum Enum2 {};
enum class EnumClass1 {};
enum class EnumClass2 {};

union Union {
  float f;
  double d;
};

struct Base {
  int i;
};

struct Derived : Base {
  double d;
  void foobar() {}
};

void func(int, int) {}

struct POD {
  int a;
  int b;
};

struct Abstract {
  virtual ~Abstract() = 0;
  int a;
};

struct Final final {};

struct DBase1 {
  int a;
  virtual ~DBase1() noexcept {}
};
struct DBase2 {
  int a;
  virtual ~DBase2() noexcept {}
};
struct DDerived : DBase1, DBase2 {};

using namespace util;

constexpr type_info<void> void_info;
constexpr type_info<void *> voidp_info;

constexpr type_info<std::nullptr_t> null_info;

constexpr type_info<bool> bool_info;

constexpr type_info<char> char_info;

constexpr type_info<signed char> signed_char_info;
constexpr type_info<unsigned char> unsigned_char_info;

constexpr type_info<signed short> signed_short_info;
constexpr type_info<unsigned short> unsigned_short_info;

constexpr type_info<signed int> signed_int_info;
constexpr type_info<unsigned int> unsigned_int_info;

constexpr type_info<signed long> signed_long_info;
constexpr type_info<unsigned long> unsigned_long_info;

constexpr type_info<signed long long> signed_long_long_info;
constexpr type_info<unsigned long long> unsigned_long_long_info;

constexpr type_info<float> float_info;
constexpr type_info<double> double_info;
constexpr type_info<long double> long_double_info;

constexpr type_info<char[]> char_array_unbounded_info;
constexpr type_info<char[3]> char_array_bounded_size3_info;

constexpr type_info<Enum1> enum1_info;
constexpr type_info<Enum2> enum2_info;

constexpr type_info<Union> union_info;

constexpr type_info<Base> base_info;
constexpr type_info<Derived> derived_info;

constexpr type_info<decltype(func)> func_info;

constexpr type_info<int *> intp_info;
constexpr type_info<int **> intpp_info;
constexpr type_info<int &> intr_info;
constexpr type_info<int &&> intrr_info;

constexpr type_info<decltype(&Base::i)> mem_obj_ptr_info;
constexpr type_info<decltype(&Derived::foobar)> mem_fun_ptr_info;

constexpr type_info<POD> pod_info;
constexpr type_info<Abstract> abstract_info;
constexpr type_info<Final> final_info;
constexpr type_info<DBase1> dbase1_info;
constexpr type_info<DDerived> dderived_info;

constexpr bool is_32bit = (sizeof(void *) == 4);
constexpr bool is_64bit = (sizeof(void *) == 8);

TEST(TypeInfo, Size) {
  EXPECT_EQ(void_info.traits.size, 0);
  if (is_32bit) {
    EXPECT_EQ(voidp_info.traits.size, 4);
  }
  if (is_64bit) {
    EXPECT_EQ(voidp_info.traits.size, 8);
  }

  if (is_32bit) {
    EXPECT_EQ(null_info.traits.size, 4);
  }
  if (is_64bit) {
    EXPECT_EQ(null_info.traits.size, 8);
  }

  EXPECT_GE(bool_info.traits.size, 1);

  EXPECT_EQ(char_info.traits.size, 1);

  EXPECT_EQ(signed_char_info.traits.size, 1);
  EXPECT_EQ(unsigned_char_info.traits.size, 1);

  EXPECT_GE(signed_short_info.traits.size, 2);
  EXPECT_GE(unsigned_short_info.traits.size, 2);

  EXPECT_GE(signed_int_info.traits.size, 2);
  EXPECT_GE(unsigned_int_info.traits.size, 2);

  EXPECT_GE(signed_long_info.traits.size, 4);
  EXPECT_GE(unsigned_long_info.traits.size, 4);

  EXPECT_GE(signed_long_long_info.traits.size, 8);
  EXPECT_GE(unsigned_long_long_info.traits.size, 8);

  EXPECT_GE(float_info.traits.size, 4);
  EXPECT_GE(double_info.traits.size, 8);
  EXPECT_GE(long_double_info.traits.size, 8);

  EXPECT_EQ(char_array_unbounded_info.traits.size, 0);
#if __cplusplus >= CPP20_STANDARD
  EXPECT_EQ(char_array_bounded_size3_info.traits.size, 3);
#else
  EXPECT_EQ(char_array_bounded_size3_info.traits.size, 0);
#endif

  EXPECT_GE(enum1_info.traits.size, 1);
  EXPECT_GE(enum2_info.traits.size, 1);

  EXPECT_GE(union_info.traits.size, sizeof(double));

  EXPECT_GE(base_info.traits.size, signed_int_info.traits.size);
  EXPECT_GE(derived_info.traits.size, signed_int_info.traits.size + double_info.traits.size);

  EXPECT_EQ(func_info.traits.size, 0);

  EXPECT_EQ(intp_info.traits.size, voidp_info.traits.size);
  EXPECT_EQ(intpp_info.traits.size, voidp_info.traits.size);
  EXPECT_EQ(intr_info.traits.size, signed_int_info.traits.size);
  EXPECT_EQ(intrr_info.traits.size, signed_int_info.traits.size);

  EXPECT_EQ(mem_obj_ptr_info.traits.size, voidp_info.traits.size);
  EXPECT_GE(mem_fun_ptr_info.traits.size, voidp_info.traits.size);
}

TEST(TypeInfo, HashCode) {
  EXPECT_TRUE((std::is_same<std::size_t, decltype(get_hash_code(void_info))>::value));
  constexpr std::size_t void_hash = get_hash_code(void_info);
  constexpr std::size_t voidp_hash = get_hash_code(voidp_info);
  constexpr std::size_t null_hash = get_hash_code(null_info);
  constexpr std::size_t bool_hash = get_hash_code(bool_info);
  constexpr std::size_t char_hash = get_hash_code(char_info);
  constexpr std::size_t signed_char_hash = get_hash_code(signed_char_info);
  constexpr std::size_t unsigned_char_hash = get_hash_code(unsigned_char_info);
  constexpr std::size_t signed_int_hash = get_hash_code(signed_int_info);
  constexpr std::size_t unsigned_int_hash = get_hash_code(unsigned_int_info);
  constexpr std::size_t signed_long_hash = get_hash_code(signed_long_info);
  constexpr std::size_t unsigned_long_hash = get_hash_code(unsigned_long_info);
  constexpr std::size_t signed_long_long_hash = get_hash_code(signed_long_long_info);
  constexpr std::size_t unsigned_long_long_hash = get_hash_code(unsigned_long_long_info);
  constexpr std::size_t float_hash = get_hash_code(float_info);
  constexpr std::size_t double_hash = get_hash_code(double_info);
  constexpr std::size_t long_double_hash = get_hash_code(long_double_info);
  constexpr std::size_t char_array_unbounded_hash = get_hash_code(char_array_unbounded_info);
  constexpr std::size_t char_array_bounded_size3_hash = get_hash_code(char_array_bounded_size3_info);
  constexpr std::size_t enum1_hash = get_hash_code(enum1_info);
  constexpr std::size_t enum2_hash = get_hash_code(enum2_info);
  constexpr std::size_t union_hash = get_hash_code(union_info);
  constexpr std::size_t base_hash = get_hash_code(base_info);
  constexpr std::size_t derived_hash = get_hash_code(derived_info);
  constexpr std::size_t func_hash = get_hash_code(func_info);
  constexpr std::size_t intp_hash = get_hash_code(intp_info);
  constexpr std::size_t intpp_hash = get_hash_code(intpp_info);
  constexpr std::size_t intr_hash = get_hash_code(intr_info);
  constexpr std::size_t intrr_hash = get_hash_code(intrr_info);
  constexpr std::size_t mem_obj_ptr_hash = get_hash_code(mem_obj_ptr_info);
  constexpr std::size_t mem_fun_ptr_hash = get_hash_code(mem_fun_ptr_info);

  // clang-format off
  std::set<std::size_t> unique_hashes { 
    void_hash,
    voidp_hash,
    null_hash,
    bool_hash,
    char_hash,
    signed_char_hash,
    unsigned_char_hash,
    signed_int_hash,
    unsigned_int_hash,
    signed_long_hash,
    unsigned_long_hash,
    signed_long_long_hash,
    unsigned_long_long_hash,
    float_hash,
    double_hash,
    long_double_hash,
    char_array_unbounded_hash,
    char_array_bounded_size3_hash,
    enum1_hash,
    enum2_hash,
    union_hash,
    base_hash,
    derived_hash,
    func_hash,
    intp_hash,
    intpp_hash,
    intr_hash,
    intrr_hash,
    mem_obj_ptr_hash,
    mem_fun_ptr_hash
  };
  // clang-format on

  EXPECT_EQ(unique_hashes.size(), 30);
}

TEST(TypeInfo, ConstHashCode) {
  EXPECT_TRUE((std::is_same<std::size_t, decltype(get_const_hash_code(void_info))>::value));
  constexpr std::size_t const_void_hash = get_const_hash_code(void_info);
  constexpr std::size_t const_voidp_hash = get_const_hash_code(voidp_info);
  constexpr std::size_t const_null_hash = get_const_hash_code(null_info);
  constexpr std::size_t const_bool_hash = get_const_hash_code(bool_info);
  constexpr std::size_t const_char_hash = get_const_hash_code(char_info);
  constexpr std::size_t const_signed_char_hash = get_const_hash_code(signed_char_info);
  constexpr std::size_t const_unsigned_char_hash = get_const_hash_code(unsigned_char_info);
  constexpr std::size_t const_signed_int_hash = get_const_hash_code(signed_int_info);
  constexpr std::size_t const_unsigned_int_hash = get_const_hash_code(unsigned_int_info);
  constexpr std::size_t const_signed_long_hash = get_const_hash_code(signed_long_info);
  constexpr std::size_t const_unsigned_long_hash = get_const_hash_code(unsigned_long_info);
  constexpr std::size_t const_signed_long_long_hash = get_const_hash_code(signed_long_long_info);
  constexpr std::size_t const_unsigned_long_long_hash = get_const_hash_code(unsigned_long_long_info);
  constexpr std::size_t const_float_hash = get_const_hash_code(float_info);
  constexpr std::size_t const_double_hash = get_const_hash_code(double_info);
  constexpr std::size_t const_long_double_hash = get_const_hash_code(long_double_info);
  constexpr std::size_t const_char_array_unbounded_hash = get_const_hash_code(char_array_unbounded_info);
  constexpr std::size_t const_char_array_bounded_size3_hash = get_const_hash_code(char_array_bounded_size3_info);
  constexpr std::size_t const_enum1_hash = get_const_hash_code(enum1_info);
  constexpr std::size_t const_enum2_hash = get_const_hash_code(enum2_info);
  constexpr std::size_t const_union_hash = get_const_hash_code(union_info);
  constexpr std::size_t const_base_hash = get_const_hash_code(base_info);
  constexpr std::size_t const_derived_hash = get_const_hash_code(derived_info);
  constexpr std::size_t const_func_hash = get_const_hash_code(func_info);
  constexpr std::size_t const_intp_hash = get_const_hash_code(intp_info);
  constexpr std::size_t const_intpp_hash = get_const_hash_code(intpp_info);
  constexpr std::size_t const_intr_hash = get_const_hash_code(intr_info);
  constexpr std::size_t const_intrr_hash = get_const_hash_code(intrr_info);
  constexpr std::size_t const_mem_obj_ptr_hash = get_const_hash_code(mem_obj_ptr_info);
  constexpr std::size_t const_mem_fun_ptr_hash = get_const_hash_code(mem_fun_ptr_info);

  // clang-format off
  std::set<std::size_t> unique_hashes { 
    const_void_hash,
    const_voidp_hash,
    const_null_hash,
    const_bool_hash,
    const_char_hash,
    const_signed_char_hash,
    const_unsigned_char_hash,
    const_signed_int_hash,
    const_unsigned_int_hash,
    const_signed_long_hash,
    const_unsigned_long_hash,
    const_signed_long_long_hash,
    const_unsigned_long_long_hash,
    const_float_hash,
    const_double_hash,
    const_long_double_hash,
    const_char_array_unbounded_hash,
    const_char_array_bounded_size3_hash,
    const_enum1_hash,
    const_enum2_hash,
    const_union_hash,
    const_base_hash,
    const_derived_hash,
    const_func_hash,
    const_intp_hash,
    const_intpp_hash,
    const_intr_hash,
    const_intrr_hash,
    const_mem_obj_ptr_hash,
    const_mem_fun_ptr_hash
  };
  // clang-format on

  EXPECT_EQ(unique_hashes.size(), 30);
}

TEST(TypeInfo, DiffHashVsConstHash) {
  constexpr std::size_t void_hash = get_hash_code(void_info);
  constexpr std::size_t voidp_hash = get_hash_code(voidp_info);
  constexpr std::size_t null_hash = get_hash_code(null_info);
  constexpr std::size_t bool_hash = get_hash_code(bool_info);
  constexpr std::size_t char_hash = get_hash_code(char_info);
  constexpr std::size_t signed_char_hash = get_hash_code(signed_char_info);
  constexpr std::size_t unsigned_char_hash = get_hash_code(unsigned_char_info);
  constexpr std::size_t signed_int_hash = get_hash_code(signed_int_info);
  constexpr std::size_t unsigned_int_hash = get_hash_code(unsigned_int_info);
  constexpr std::size_t signed_long_hash = get_hash_code(signed_long_info);
  constexpr std::size_t unsigned_long_hash = get_hash_code(unsigned_long_info);
  constexpr std::size_t signed_long_long_hash = get_hash_code(signed_long_long_info);
  constexpr std::size_t unsigned_long_long_hash = get_hash_code(unsigned_long_long_info);
  constexpr std::size_t float_hash = get_hash_code(float_info);
  constexpr std::size_t double_hash = get_hash_code(double_info);
  constexpr std::size_t long_double_hash = get_hash_code(long_double_info);
  constexpr std::size_t char_array_unbounded_hash = get_hash_code(char_array_unbounded_info);
  constexpr std::size_t char_array_bounded_size3_hash = get_hash_code(char_array_bounded_size3_info);
  constexpr std::size_t enum1_hash = get_hash_code(enum1_info);
  constexpr std::size_t enum2_hash = get_hash_code(enum2_info);
  constexpr std::size_t union_hash = get_hash_code(union_info);
  constexpr std::size_t base_hash = get_hash_code(base_info);
  constexpr std::size_t derived_hash = get_hash_code(derived_info);
  constexpr std::size_t func_hash = get_hash_code(func_info);
  constexpr std::size_t intp_hash = get_hash_code(intp_info);
  constexpr std::size_t intpp_hash = get_hash_code(intpp_info);
  constexpr std::size_t intr_hash = get_hash_code(intr_info);
  constexpr std::size_t intrr_hash = get_hash_code(intrr_info);
  constexpr std::size_t mem_obj_ptr_hash = get_hash_code(mem_obj_ptr_info);
  constexpr std::size_t mem_fun_ptr_hash = get_hash_code(mem_fun_ptr_info);

  constexpr std::size_t const_void_hash = get_const_hash_code(void_info);
  constexpr std::size_t const_voidp_hash = get_const_hash_code(voidp_info);
  constexpr std::size_t const_null_hash = get_const_hash_code(null_info);
  constexpr std::size_t const_bool_hash = get_const_hash_code(bool_info);
  constexpr std::size_t const_char_hash = get_const_hash_code(char_info);
  constexpr std::size_t const_signed_char_hash = get_const_hash_code(signed_char_info);
  constexpr std::size_t const_unsigned_char_hash = get_const_hash_code(unsigned_char_info);
  constexpr std::size_t const_signed_int_hash = get_const_hash_code(signed_int_info);
  constexpr std::size_t const_unsigned_int_hash = get_const_hash_code(unsigned_int_info);
  constexpr std::size_t const_signed_long_hash = get_const_hash_code(signed_long_info);
  constexpr std::size_t const_unsigned_long_hash = get_const_hash_code(unsigned_long_info);
  constexpr std::size_t const_signed_long_long_hash = get_const_hash_code(signed_long_long_info);
  constexpr std::size_t const_unsigned_long_long_hash = get_const_hash_code(unsigned_long_long_info);
  constexpr std::size_t const_float_hash = get_const_hash_code(float_info);
  constexpr std::size_t const_double_hash = get_const_hash_code(double_info);
  constexpr std::size_t const_long_double_hash = get_const_hash_code(long_double_info);
  constexpr std::size_t const_char_array_unbounded_hash = get_const_hash_code(char_array_unbounded_info);
  constexpr std::size_t const_char_array_bounded_size3_hash = get_const_hash_code(char_array_bounded_size3_info);
  constexpr std::size_t const_enum1_hash = get_const_hash_code(enum1_info);
  constexpr std::size_t const_enum2_hash = get_const_hash_code(enum2_info);
  constexpr std::size_t const_union_hash = get_const_hash_code(union_info);
  constexpr std::size_t const_base_hash = get_const_hash_code(base_info);
  constexpr std::size_t const_derived_hash = get_const_hash_code(derived_info);
  constexpr std::size_t const_func_hash = get_const_hash_code(func_info);
  constexpr std::size_t const_intp_hash = get_const_hash_code(intp_info);
  constexpr std::size_t const_intpp_hash = get_const_hash_code(intpp_info);
  constexpr std::size_t const_intr_hash = get_const_hash_code(intr_info);
  constexpr std::size_t const_intrr_hash = get_const_hash_code(intrr_info);
  constexpr std::size_t const_mem_obj_ptr_hash = get_const_hash_code(mem_obj_ptr_info);
  constexpr std::size_t const_mem_fun_ptr_hash = get_const_hash_code(mem_fun_ptr_info);


  EXPECT_NE(void_hash, const_void_hash);
  EXPECT_NE(voidp_hash, const_voidp_hash);
#ifdef __clang__
  EXPECT_NE(null_hash, const_null_hash);
#else
  EXPECT_EQ(null_hash, const_null_hash); // No const exists under GCC!
#endif
  EXPECT_NE(bool_hash, const_bool_hash);
  EXPECT_NE(char_hash, const_char_hash);
  EXPECT_NE(signed_char_hash, const_signed_char_hash);
  EXPECT_NE(unsigned_char_hash, const_unsigned_char_hash);
  EXPECT_NE(signed_int_hash, const_signed_int_hash);
  EXPECT_NE(unsigned_int_hash, const_unsigned_int_hash);
  EXPECT_NE(signed_long_hash, const_signed_long_hash);
  EXPECT_NE(unsigned_long_hash, const_unsigned_long_hash);
  EXPECT_NE(signed_long_long_hash, const_signed_long_long_hash);
  EXPECT_NE(unsigned_long_long_hash, const_unsigned_long_long_hash);
  EXPECT_NE(float_hash, const_float_hash);
  EXPECT_NE(double_hash, const_double_hash);
  EXPECT_NE(long_double_hash, const_long_double_hash);
  EXPECT_NE(char_array_unbounded_hash, const_char_array_unbounded_hash);
  EXPECT_NE(char_array_bounded_size3_hash, const_char_array_bounded_size3_hash);
  EXPECT_NE(enum1_hash, const_enum1_hash);
  EXPECT_NE(enum2_hash, const_enum2_hash);
  EXPECT_NE(union_hash, const_union_hash);
  EXPECT_NE(base_hash, const_base_hash);
  EXPECT_NE(derived_hash, const_derived_hash);
  EXPECT_EQ(func_hash, const_func_hash); // No const exists!
  EXPECT_NE(intp_hash, const_intp_hash);
  EXPECT_NE(intpp_hash, const_intpp_hash);
  EXPECT_NE(intr_hash, const_intr_hash);
  EXPECT_NE(intrr_hash, const_intrr_hash);
  EXPECT_NE(mem_obj_ptr_hash, const_mem_obj_ptr_hash);
  EXPECT_NE(mem_fun_ptr_hash, const_mem_fun_ptr_hash);
}

TEST(TypeInfo, TypeName) {
  // Only testing simple types, as names are compiler vendor specific
  EXPECT_EQ(std::string(get_name(void_info)), "void");
  EXPECT_EQ(std::string(get_name(signed_int_info)), "int");
  EXPECT_EQ(std::string(get_name(enum1_info)), "Enum1");
  EXPECT_EQ(std::string(get_const_traits(signed_int_info).name), "const int");
  EXPECT_EQ(std::string(get_const_traits(enum1_info).name), "const Enum1");
}

TEST(TypeInfo, Compare) {
  EXPECT_TRUE(void_info.has_same_type(void_info));
  EXPECT_TRUE(signed_int_info.has_same_type(signed_int_info));
  EXPECT_TRUE(float_info.has_same_type(float_info));

  EXPECT_FALSE(void_info.has_same_type(signed_int_info));
  EXPECT_FALSE(signed_int_info.has_same_type(float_info));
  EXPECT_FALSE(signed_int_info.has_same_type(unsigned_int_info));

  EXPECT_TRUE(void_info == void_info);
  EXPECT_TRUE(signed_int_info == signed_int_info);
  EXPECT_TRUE(float_info == float_info);

  EXPECT_FALSE(void_info == signed_int_info);
  EXPECT_FALSE(signed_int_info == float_info);
  EXPECT_FALSE(signed_int_info == unsigned_int_info);

  EXPECT_FALSE(void_info != void_info);
  EXPECT_FALSE(signed_int_info != signed_int_info);
  EXPECT_FALSE(float_info != float_info);

  EXPECT_TRUE(void_info != signed_int_info);
  EXPECT_TRUE(signed_int_info != float_info);
  EXPECT_TRUE(signed_int_info != unsigned_int_info);

#ifdef PLATFORM_IS64BIT
  EXPECT_TRUE(signed_int_info < void_info);
  EXPECT_TRUE(signed_int_info < float_info);
  EXPECT_TRUE(void_info < float_info);
  EXPECT_FALSE(float_info < void_info);

  EXPECT_TRUE(get_hash_code(signed_int_info) < get_hash_code(void_info));
  EXPECT_TRUE(get_hash_code(signed_int_info) < get_hash_code(float_info));
  EXPECT_TRUE(get_hash_code(void_info) < get_hash_code(float_info));
  EXPECT_FALSE(get_hash_code(float_info) < get_hash_code(void_info));
#else
  EXPECT_TRUE(void_info < signed_int_info);
  EXPECT_TRUE(signed_int_info < float_info);
  EXPECT_TRUE(void_info < float_info);
  EXPECT_FALSE(float_info < void_info);

  EXPECT_TRUE(get_hash_code(void_info) < get_hash_code(signed_int_info));
  EXPECT_TRUE(get_hash_code(signed_int_info) < get_hash_code(float_info));
  EXPECT_TRUE(get_hash_code(void_info) < get_hash_code(float_info));
  EXPECT_FALSE(get_hash_code(float_info) < get_hash_code(void_info));
#endif
}

TEST(TypeInfo, Containerize) {
  std::vector<type_base> v;
  v.push_back(signed_int_info);
  v.push_back(void_info);
  v.push_back(float_info);
  v.push_back(type_info<double> {});
  v.reserve(10);

  EXPECT_EQ(v.size(), 4);
  EXPECT_EQ(v[0], type_info<signed int> {});
  EXPECT_EQ(v[1], type_info<void> {});
  EXPECT_EQ(v[2], type_info<float> {});
  EXPECT_EQ(v[3], type_info<double> {});

  std::set<type_base> s;
  s.insert(signed_int_info);
  s.insert(void_info);
  s.insert(float_info);
  s.insert(type_info<double> {});

  EXPECT_NE(s.find(type_info<void> {}), s.end());
  EXPECT_NE(s.find(type_info<int> {}), s.end());
  EXPECT_EQ(s.find(type_info<long double> {}), s.end());
}

TEST(TypeInfo, Traits) {

  // void
  {
    EXPECT_TRUE(is_void(void_info));
    EXPECT_FALSE(is_null_pointer(void_info));
    EXPECT_FALSE(is_integral(void_info));
    EXPECT_FALSE(is_floating_point(void_info));
    EXPECT_FALSE(is_array(void_info));
    EXPECT_FALSE(is_enum(void_info));
    EXPECT_FALSE(is_union(void_info));
    EXPECT_FALSE(is_class(void_info));
    EXPECT_FALSE(is_function(void_info));
    EXPECT_FALSE(is_pointer(void_info));
    EXPECT_FALSE(is_lvalue_reference(void_info));
    EXPECT_FALSE(is_rvalue_reference(void_info));
    EXPECT_FALSE(is_member_function_pointer(void_info));
    EXPECT_TRUE(is_fundamental(void_info));
    EXPECT_FALSE(is_arithmetic(void_info));
    EXPECT_FALSE(is_scalar(void_info));
    EXPECT_FALSE(is_object(void_info));
    EXPECT_FALSE(is_compound(void_info));
    EXPECT_FALSE(is_reference(void_info));
    EXPECT_FALSE(is_member_pointer(void_info));
    EXPECT_FALSE(is_const(void_info));
    EXPECT_FALSE(is_volatile(void_info));
    EXPECT_FALSE(is_trivial(void_info));
    EXPECT_FALSE(is_trivially_copyable(void_info));
    EXPECT_FALSE(is_standard_layout(void_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(void_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(void_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(void_info));
#endif
    EXPECT_FALSE(is_empty(void_info));
    EXPECT_FALSE(is_polymorphic(void_info));
    EXPECT_FALSE(is_abstract(void_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(void_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(void_info));
#endif
    EXPECT_FALSE(is_signed(void_info));
    EXPECT_FALSE(is_unsigned(void_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(void_info));
    EXPECT_FALSE(is_unbounded_array(void_info));
#endif
    EXPECT_FALSE(is_default_constructible(void_info));
    EXPECT_FALSE(is_trivially_default_constructible(void_info));
    EXPECT_FALSE(is_nothrow_default_constructible(void_info));
    EXPECT_FALSE(is_copy_constructible(void_info));
    EXPECT_FALSE(is_trivially_copy_constructible(void_info));
    EXPECT_FALSE(is_nothrow_copy_constructible(void_info));
    EXPECT_FALSE(is_move_constructible(void_info));
    EXPECT_FALSE(is_trivially_move_constructible(void_info));
    EXPECT_FALSE(is_nothrow_move_constructible(void_info));
    EXPECT_FALSE(is_copy_assignable(void_info));
    EXPECT_FALSE(is_trivially_copy_assignable(void_info));
    EXPECT_FALSE(is_move_assignable(void_info));
    EXPECT_FALSE(is_trivially_move_assignable(void_info));
    EXPECT_FALSE(is_nothrow_move_assignable(void_info));
    EXPECT_FALSE(is_destructible(void_info));
    EXPECT_FALSE(is_trivially_destructible(void_info));
    EXPECT_FALSE(is_nothrow_destructible(void_info));
    EXPECT_FALSE(has_virtual_destructor(void_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_swappable(void_info));
    EXPECT_FALSE(is_nothrow_swappable(void_info));
#endif
  }

  // void*
  {
    EXPECT_FALSE(is_void(voidp_info));
    EXPECT_FALSE(is_null_pointer(voidp_info));
    EXPECT_FALSE(is_integral(voidp_info));
    EXPECT_FALSE(is_floating_point(voidp_info));
    EXPECT_FALSE(is_array(voidp_info));
    EXPECT_FALSE(is_enum(voidp_info));
    EXPECT_FALSE(is_union(voidp_info));
    EXPECT_FALSE(is_class(voidp_info));
    EXPECT_FALSE(is_function(voidp_info));
    EXPECT_TRUE(is_pointer(voidp_info));
    EXPECT_FALSE(is_lvalue_reference(voidp_info));
    EXPECT_FALSE(is_rvalue_reference(voidp_info));
    EXPECT_FALSE(is_member_function_pointer(voidp_info));
    EXPECT_FALSE(is_fundamental(voidp_info));
    EXPECT_FALSE(is_arithmetic(voidp_info));
    EXPECT_TRUE(is_scalar(voidp_info));
    EXPECT_TRUE(is_object(voidp_info));
    EXPECT_TRUE(is_compound(voidp_info));
    EXPECT_FALSE(is_reference(voidp_info));
    EXPECT_FALSE(is_member_pointer(voidp_info));
    EXPECT_FALSE(is_const(voidp_info));
    EXPECT_FALSE(is_volatile(voidp_info));
    EXPECT_TRUE(is_trivial(voidp_info));
    EXPECT_TRUE(is_trivially_copyable(voidp_info));
    EXPECT_TRUE(is_standard_layout(voidp_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(voidp_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(voidp_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(voidp_info));
#endif
    EXPECT_FALSE(is_empty(voidp_info));
    EXPECT_FALSE(is_polymorphic(voidp_info));
    EXPECT_FALSE(is_abstract(voidp_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(voidp_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(voidp_info));
#endif
    EXPECT_FALSE(is_signed(voidp_info));
    EXPECT_FALSE(is_unsigned(voidp_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(voidp_info));
    EXPECT_FALSE(is_unbounded_array(voidp_info));
#endif
    EXPECT_TRUE(is_default_constructible(voidp_info));
    EXPECT_TRUE(is_trivially_default_constructible(voidp_info));
    EXPECT_TRUE(is_nothrow_default_constructible(voidp_info));
    EXPECT_TRUE(is_copy_constructible(voidp_info));
    EXPECT_TRUE(is_trivially_copy_constructible(voidp_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(voidp_info));
    EXPECT_TRUE(is_move_constructible(voidp_info));
    EXPECT_TRUE(is_trivially_move_constructible(voidp_info));
    EXPECT_TRUE(is_nothrow_move_constructible(voidp_info));
    EXPECT_TRUE(is_copy_assignable(voidp_info));
    EXPECT_TRUE(is_trivially_copy_assignable(voidp_info));
    EXPECT_TRUE(is_move_assignable(voidp_info));
    EXPECT_TRUE(is_trivially_move_assignable(voidp_info));
    EXPECT_TRUE(is_nothrow_move_assignable(voidp_info));
    EXPECT_TRUE(is_destructible(voidp_info));
    EXPECT_TRUE(is_trivially_destructible(voidp_info));
    EXPECT_TRUE(is_nothrow_destructible(voidp_info));
    EXPECT_FALSE(has_virtual_destructor(voidp_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(voidp_info));
    EXPECT_TRUE(is_nothrow_swappable(voidp_info));
#endif
  }

  // nullptr_t
  {
    EXPECT_FALSE(is_void(null_info));
    EXPECT_TRUE(is_null_pointer(null_info));
    EXPECT_FALSE(is_integral(null_info));
    EXPECT_FALSE(is_floating_point(null_info));
    EXPECT_FALSE(is_array(null_info));
    EXPECT_FALSE(is_enum(null_info));
    EXPECT_FALSE(is_union(null_info));
    EXPECT_FALSE(is_class(null_info));
    EXPECT_FALSE(is_function(null_info));
    EXPECT_FALSE(is_pointer(null_info));
    EXPECT_FALSE(is_lvalue_reference(null_info));
    EXPECT_FALSE(is_rvalue_reference(null_info));
    EXPECT_FALSE(is_member_function_pointer(null_info));
    EXPECT_TRUE(is_fundamental(null_info));
    EXPECT_FALSE(is_arithmetic(null_info));
    EXPECT_TRUE(is_scalar(null_info));
    EXPECT_TRUE(is_object(null_info));
    EXPECT_FALSE(is_compound(null_info));
    EXPECT_FALSE(is_reference(null_info));
    EXPECT_FALSE(is_member_pointer(null_info));
    EXPECT_FALSE(is_const(null_info));
    EXPECT_FALSE(is_volatile(null_info));
    EXPECT_TRUE(is_trivial(null_info));
    EXPECT_TRUE(is_trivially_copyable(null_info));
    EXPECT_TRUE(is_standard_layout(null_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(null_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(null_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(null_info));
#endif
    EXPECT_FALSE(is_empty(null_info));
    EXPECT_FALSE(is_polymorphic(null_info));
    EXPECT_FALSE(is_abstract(null_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(null_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(null_info));
#endif
    EXPECT_FALSE(is_signed(null_info));
    EXPECT_FALSE(is_unsigned(null_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(null_info));
    EXPECT_FALSE(is_unbounded_array(null_info));
#endif
    EXPECT_TRUE(is_default_constructible(null_info));
    EXPECT_TRUE(is_trivially_default_constructible(null_info));
    EXPECT_TRUE(is_nothrow_default_constructible(null_info));
    EXPECT_TRUE(is_copy_constructible(null_info));
    EXPECT_TRUE(is_trivially_copy_constructible(null_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(null_info));
    EXPECT_TRUE(is_move_constructible(null_info));
    EXPECT_TRUE(is_trivially_move_constructible(null_info));
    EXPECT_TRUE(is_nothrow_move_constructible(null_info));
    EXPECT_TRUE(is_copy_assignable(null_info));
    EXPECT_TRUE(is_trivially_copy_assignable(null_info));
    EXPECT_TRUE(is_move_assignable(null_info));
    EXPECT_TRUE(is_trivially_move_assignable(null_info));
    EXPECT_TRUE(is_nothrow_move_assignable(null_info));
    EXPECT_TRUE(is_destructible(null_info));
    EXPECT_TRUE(is_trivially_destructible(null_info));
    EXPECT_TRUE(is_nothrow_destructible(null_info));
    EXPECT_FALSE(has_virtual_destructor(null_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(null_info));
    EXPECT_TRUE(is_nothrow_swappable(null_info));
#endif
  }

  // bool
  {
    EXPECT_FALSE(is_void(bool_info));
    EXPECT_FALSE(is_null_pointer(bool_info));
    EXPECT_TRUE(is_integral(bool_info));
    EXPECT_FALSE(is_floating_point(bool_info));
    EXPECT_FALSE(is_array(bool_info));
    EXPECT_FALSE(is_enum(bool_info));
    EXPECT_FALSE(is_union(bool_info));
    EXPECT_FALSE(is_class(bool_info));
    EXPECT_FALSE(is_function(bool_info));
    EXPECT_FALSE(is_pointer(bool_info));
    EXPECT_FALSE(is_lvalue_reference(bool_info));
    EXPECT_FALSE(is_rvalue_reference(bool_info));
    EXPECT_FALSE(is_member_function_pointer(bool_info));
    EXPECT_TRUE(is_fundamental(bool_info));
    EXPECT_TRUE(is_arithmetic(bool_info));
    EXPECT_TRUE(is_scalar(bool_info));
    EXPECT_TRUE(is_object(bool_info));
    EXPECT_FALSE(is_compound(bool_info));
    EXPECT_FALSE(is_reference(bool_info));
    EXPECT_FALSE(is_member_pointer(bool_info));
    EXPECT_FALSE(is_const(bool_info));
    EXPECT_FALSE(is_volatile(bool_info));
    EXPECT_TRUE(is_trivial(bool_info));
    EXPECT_TRUE(is_trivially_copyable(bool_info));
    EXPECT_TRUE(is_standard_layout(bool_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(bool_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(bool_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(bool_info));
#endif
    EXPECT_FALSE(is_empty(bool_info));
    EXPECT_FALSE(is_polymorphic(bool_info));
    EXPECT_FALSE(is_abstract(bool_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(bool_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(bool_info));
#endif
    EXPECT_FALSE(is_signed(bool_info));
    EXPECT_TRUE(is_unsigned(bool_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(bool_info));
    EXPECT_FALSE(is_unbounded_array(bool_info));
#endif
    EXPECT_TRUE(is_default_constructible(bool_info));
    EXPECT_TRUE(is_trivially_default_constructible(bool_info));
    EXPECT_TRUE(is_nothrow_default_constructible(bool_info));
    EXPECT_TRUE(is_copy_constructible(bool_info));
    EXPECT_TRUE(is_trivially_copy_constructible(bool_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(bool_info));
    EXPECT_TRUE(is_move_constructible(bool_info));
    EXPECT_TRUE(is_trivially_move_constructible(bool_info));
    EXPECT_TRUE(is_nothrow_move_constructible(bool_info));
    EXPECT_TRUE(is_copy_assignable(bool_info));
    EXPECT_TRUE(is_trivially_copy_assignable(bool_info));
    EXPECT_TRUE(is_move_assignable(bool_info));
    EXPECT_TRUE(is_trivially_move_assignable(bool_info));
    EXPECT_TRUE(is_nothrow_move_assignable(bool_info));
    EXPECT_TRUE(is_destructible(bool_info));
    EXPECT_TRUE(is_trivially_destructible(bool_info));
    EXPECT_TRUE(is_nothrow_destructible(bool_info));
    EXPECT_FALSE(has_virtual_destructor(bool_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(bool_info));
    EXPECT_TRUE(is_nothrow_swappable(bool_info));
#endif
  }

  // char
  {
    EXPECT_FALSE(is_void(char_info));
    EXPECT_FALSE(is_null_pointer(char_info));
    EXPECT_TRUE(is_integral(char_info));
    EXPECT_FALSE(is_floating_point(char_info));
    EXPECT_FALSE(is_array(char_info));
    EXPECT_FALSE(is_enum(char_info));
    EXPECT_FALSE(is_union(char_info));
    EXPECT_FALSE(is_class(char_info));
    EXPECT_FALSE(is_function(char_info));
    EXPECT_FALSE(is_pointer(char_info));
    EXPECT_FALSE(is_lvalue_reference(char_info));
    EXPECT_FALSE(is_rvalue_reference(char_info));
    EXPECT_FALSE(is_member_function_pointer(char_info));
    EXPECT_TRUE(is_fundamental(char_info));
    EXPECT_TRUE(is_arithmetic(char_info));
    EXPECT_TRUE(is_scalar(char_info));
    EXPECT_TRUE(is_object(char_info));
    EXPECT_FALSE(is_compound(char_info));
    EXPECT_FALSE(is_reference(char_info));
    EXPECT_FALSE(is_member_pointer(char_info));
    EXPECT_FALSE(is_const(char_info));
    EXPECT_FALSE(is_volatile(char_info));
    EXPECT_TRUE(is_trivial(char_info));
    EXPECT_TRUE(is_trivially_copyable(char_info));
    EXPECT_TRUE(is_standard_layout(char_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(char_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(char_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(char_info));
#endif
    EXPECT_FALSE(is_empty(char_info));
    EXPECT_FALSE(is_polymorphic(char_info));
    EXPECT_FALSE(is_abstract(char_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(char_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(char_info));
#endif
    EXPECT_TRUE(is_signed(char_info));
    EXPECT_FALSE(is_unsigned(char_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(char_info));
    EXPECT_FALSE(is_unbounded_array(char_info));
#endif
    EXPECT_TRUE(is_default_constructible(char_info));
    EXPECT_TRUE(is_trivially_default_constructible(char_info));
    EXPECT_TRUE(is_nothrow_default_constructible(char_info));
    EXPECT_TRUE(is_copy_constructible(char_info));
    EXPECT_TRUE(is_trivially_copy_constructible(char_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(char_info));
    EXPECT_TRUE(is_move_constructible(char_info));
    EXPECT_TRUE(is_trivially_move_constructible(char_info));
    EXPECT_TRUE(is_nothrow_move_constructible(char_info));
    EXPECT_TRUE(is_copy_assignable(char_info));
    EXPECT_TRUE(is_trivially_copy_assignable(char_info));
    EXPECT_TRUE(is_move_assignable(char_info));
    EXPECT_TRUE(is_trivially_move_assignable(char_info));
    EXPECT_TRUE(is_nothrow_move_assignable(char_info));
    EXPECT_TRUE(is_destructible(char_info));
    EXPECT_TRUE(is_trivially_destructible(char_info));
    EXPECT_TRUE(is_nothrow_destructible(char_info));
    EXPECT_FALSE(has_virtual_destructor(char_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(char_info));
    EXPECT_TRUE(is_nothrow_swappable(char_info));
#endif
  }

  // signed char
  {
    EXPECT_FALSE(is_void(signed_char_info));
    EXPECT_FALSE(is_null_pointer(signed_char_info));
    EXPECT_TRUE(is_integral(signed_char_info));
    EXPECT_FALSE(is_floating_point(signed_char_info));
    EXPECT_FALSE(is_array(signed_char_info));
    EXPECT_FALSE(is_enum(signed_char_info));
    EXPECT_FALSE(is_union(signed_char_info));
    EXPECT_FALSE(is_class(signed_char_info));
    EXPECT_FALSE(is_function(signed_char_info));
    EXPECT_FALSE(is_pointer(signed_char_info));
    EXPECT_FALSE(is_lvalue_reference(signed_char_info));
    EXPECT_FALSE(is_rvalue_reference(signed_char_info));
    EXPECT_FALSE(is_member_function_pointer(signed_char_info));
    EXPECT_TRUE(is_fundamental(signed_char_info));
    EXPECT_TRUE(is_arithmetic(signed_char_info));
    EXPECT_TRUE(is_scalar(signed_char_info));
    EXPECT_TRUE(is_object(signed_char_info));
    EXPECT_FALSE(is_compound(signed_char_info));
    EXPECT_FALSE(is_reference(signed_char_info));
    EXPECT_FALSE(is_member_pointer(signed_char_info));
    EXPECT_FALSE(is_const(signed_char_info));
    EXPECT_FALSE(is_volatile(signed_char_info));
    EXPECT_TRUE(is_trivial(signed_char_info));
    EXPECT_TRUE(is_trivially_copyable(signed_char_info));
    EXPECT_TRUE(is_standard_layout(signed_char_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(signed_char_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(signed_char_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(signed_char_info));
#endif
    EXPECT_FALSE(is_empty(signed_char_info));
    EXPECT_FALSE(is_polymorphic(signed_char_info));
    EXPECT_FALSE(is_abstract(signed_char_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(signed_char_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(signed_char_info));
#endif
    EXPECT_TRUE(is_signed(signed_char_info));
    EXPECT_FALSE(is_unsigned(signed_char_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(signed_char_info));
    EXPECT_FALSE(is_unbounded_array(signed_char_info));
#endif
    EXPECT_TRUE(is_default_constructible(signed_char_info));
    EXPECT_TRUE(is_trivially_default_constructible(signed_char_info));
    EXPECT_TRUE(is_nothrow_default_constructible(signed_char_info));
    EXPECT_TRUE(is_copy_constructible(signed_char_info));
    EXPECT_TRUE(is_trivially_copy_constructible(signed_char_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(signed_char_info));
    EXPECT_TRUE(is_move_constructible(signed_char_info));
    EXPECT_TRUE(is_trivially_move_constructible(signed_char_info));
    EXPECT_TRUE(is_nothrow_move_constructible(signed_char_info));
    EXPECT_TRUE(is_copy_assignable(signed_char_info));
    EXPECT_TRUE(is_trivially_copy_assignable(signed_char_info));
    EXPECT_TRUE(is_move_assignable(signed_char_info));
    EXPECT_TRUE(is_trivially_move_assignable(signed_char_info));
    EXPECT_TRUE(is_nothrow_move_assignable(signed_char_info));
    EXPECT_TRUE(is_destructible(signed_char_info));
    EXPECT_TRUE(is_trivially_destructible(signed_char_info));
    EXPECT_TRUE(is_nothrow_destructible(signed_char_info));
    EXPECT_FALSE(has_virtual_destructor(signed_char_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(signed_char_info));
    EXPECT_TRUE(is_nothrow_swappable(signed_char_info));
#endif
  }

  // unsigned char
  {
    EXPECT_FALSE(is_void(unsigned_char_info));
    EXPECT_FALSE(is_null_pointer(unsigned_char_info));
    EXPECT_TRUE(is_integral(unsigned_char_info));
    EXPECT_FALSE(is_floating_point(unsigned_char_info));
    EXPECT_FALSE(is_array(unsigned_char_info));
    EXPECT_FALSE(is_enum(unsigned_char_info));
    EXPECT_FALSE(is_union(unsigned_char_info));
    EXPECT_FALSE(is_class(unsigned_char_info));
    EXPECT_FALSE(is_function(unsigned_char_info));
    EXPECT_FALSE(is_pointer(unsigned_char_info));
    EXPECT_FALSE(is_lvalue_reference(unsigned_char_info));
    EXPECT_FALSE(is_rvalue_reference(unsigned_char_info));
    EXPECT_FALSE(is_member_function_pointer(unsigned_char_info));
    EXPECT_TRUE(is_fundamental(unsigned_char_info));
    EXPECT_TRUE(is_arithmetic(unsigned_char_info));
    EXPECT_TRUE(is_scalar(unsigned_char_info));
    EXPECT_TRUE(is_object(unsigned_char_info));
    EXPECT_FALSE(is_compound(unsigned_char_info));
    EXPECT_FALSE(is_reference(unsigned_char_info));
    EXPECT_FALSE(is_member_pointer(unsigned_char_info));
    EXPECT_FALSE(is_const(unsigned_char_info));
    EXPECT_FALSE(is_volatile(unsigned_char_info));
    EXPECT_TRUE(is_trivial(unsigned_char_info));
    EXPECT_TRUE(is_trivially_copyable(unsigned_char_info));
    EXPECT_TRUE(is_standard_layout(unsigned_char_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(unsigned_char_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(unsigned_char_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(unsigned_char_info));
#endif
    EXPECT_FALSE(is_empty(unsigned_char_info));
    EXPECT_FALSE(is_polymorphic(unsigned_char_info));
    EXPECT_FALSE(is_abstract(unsigned_char_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(unsigned_char_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(unsigned_char_info));
#endif
    EXPECT_FALSE(is_signed(unsigned_char_info));
    EXPECT_TRUE(is_unsigned(unsigned_char_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(unsigned_char_info));
    EXPECT_FALSE(is_unbounded_array(unsigned_char_info));
#endif
    EXPECT_TRUE(is_default_constructible(unsigned_char_info));
    EXPECT_TRUE(is_trivially_default_constructible(unsigned_char_info));
    EXPECT_TRUE(is_nothrow_default_constructible(unsigned_char_info));
    EXPECT_TRUE(is_copy_constructible(unsigned_char_info));
    EXPECT_TRUE(is_trivially_copy_constructible(unsigned_char_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(unsigned_char_info));
    EXPECT_TRUE(is_move_constructible(unsigned_char_info));
    EXPECT_TRUE(is_trivially_move_constructible(unsigned_char_info));
    EXPECT_TRUE(is_nothrow_move_constructible(unsigned_char_info));
    EXPECT_TRUE(is_copy_assignable(unsigned_char_info));
    EXPECT_TRUE(is_trivially_copy_assignable(unsigned_char_info));
    EXPECT_TRUE(is_move_assignable(unsigned_char_info));
    EXPECT_TRUE(is_trivially_move_assignable(unsigned_char_info));
    EXPECT_TRUE(is_nothrow_move_assignable(unsigned_char_info));
    EXPECT_TRUE(is_destructible(unsigned_char_info));
    EXPECT_TRUE(is_trivially_destructible(unsigned_char_info));
    EXPECT_TRUE(is_nothrow_destructible(unsigned_char_info));
    EXPECT_FALSE(has_virtual_destructor(unsigned_char_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(unsigned_char_info));
    EXPECT_TRUE(is_nothrow_swappable(unsigned_char_info));
#endif
  }

  // float
  {
    EXPECT_FALSE(is_void(float_info));
    EXPECT_FALSE(is_null_pointer(float_info));
    EXPECT_FALSE(is_integral(float_info));
    EXPECT_TRUE(is_floating_point(float_info));
    EXPECT_FALSE(is_array(float_info));
    EXPECT_FALSE(is_enum(float_info));
    EXPECT_FALSE(is_union(float_info));
    EXPECT_FALSE(is_class(float_info));
    EXPECT_FALSE(is_function(float_info));
    EXPECT_FALSE(is_pointer(float_info));
    EXPECT_FALSE(is_lvalue_reference(float_info));
    EXPECT_FALSE(is_rvalue_reference(float_info));
    EXPECT_FALSE(is_member_function_pointer(float_info));
    EXPECT_TRUE(is_fundamental(float_info));
    EXPECT_TRUE(is_arithmetic(float_info));
    EXPECT_TRUE(is_scalar(float_info));
    EXPECT_TRUE(is_object(float_info));
    EXPECT_FALSE(is_compound(float_info));
    EXPECT_FALSE(is_reference(float_info));
    EXPECT_FALSE(is_member_pointer(float_info));
    EXPECT_FALSE(is_const(float_info));
    EXPECT_FALSE(is_volatile(float_info));
    EXPECT_TRUE(is_trivial(float_info));
    EXPECT_TRUE(is_trivially_copyable(float_info));
    EXPECT_TRUE(is_standard_layout(float_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(float_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(float_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(float_info));
#endif
    EXPECT_FALSE(is_empty(float_info));
    EXPECT_FALSE(is_polymorphic(float_info));
    EXPECT_FALSE(is_abstract(float_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(float_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(float_info));
#endif
    EXPECT_TRUE(is_signed(float_info));
    EXPECT_FALSE(is_unsigned(float_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(float_info));
    EXPECT_FALSE(is_unbounded_array(float_info));
#endif
    EXPECT_TRUE(is_default_constructible(float_info));
    EXPECT_TRUE(is_trivially_default_constructible(float_info));
    EXPECT_TRUE(is_nothrow_default_constructible(float_info));
    EXPECT_TRUE(is_copy_constructible(float_info));
    EXPECT_TRUE(is_trivially_copy_constructible(float_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(float_info));
    EXPECT_TRUE(is_move_constructible(float_info));
    EXPECT_TRUE(is_trivially_move_constructible(float_info));
    EXPECT_TRUE(is_nothrow_move_constructible(float_info));
    EXPECT_TRUE(is_copy_assignable(float_info));
    EXPECT_TRUE(is_trivially_copy_assignable(float_info));
    EXPECT_TRUE(is_move_assignable(float_info));
    EXPECT_TRUE(is_trivially_move_assignable(float_info));
    EXPECT_TRUE(is_nothrow_move_assignable(float_info));
    EXPECT_TRUE(is_destructible(float_info));
    EXPECT_TRUE(is_trivially_destructible(float_info));
    EXPECT_TRUE(is_nothrow_destructible(float_info));
    EXPECT_FALSE(has_virtual_destructor(float_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(float_info));
    EXPECT_TRUE(is_nothrow_swappable(float_info));
#endif
  }

  // char array unbound
  {
    EXPECT_FALSE(is_void(char_array_unbounded_info));
    EXPECT_FALSE(is_null_pointer(char_array_unbounded_info));
    EXPECT_FALSE(is_integral(char_array_unbounded_info));
    EXPECT_FALSE(is_floating_point(char_array_unbounded_info));
    EXPECT_TRUE(is_array(char_array_unbounded_info));
    EXPECT_FALSE(is_enum(char_array_unbounded_info));
    EXPECT_FALSE(is_union(char_array_unbounded_info));
    EXPECT_FALSE(is_class(char_array_unbounded_info));
    EXPECT_FALSE(is_function(char_array_unbounded_info));
    EXPECT_FALSE(is_pointer(char_array_unbounded_info));
    EXPECT_FALSE(is_lvalue_reference(char_array_unbounded_info));
    EXPECT_FALSE(is_rvalue_reference(char_array_unbounded_info));
    EXPECT_FALSE(is_member_function_pointer(char_array_unbounded_info));
    EXPECT_FALSE(is_fundamental(char_array_unbounded_info));
    EXPECT_FALSE(is_arithmetic(char_array_unbounded_info));
    EXPECT_FALSE(is_scalar(char_array_unbounded_info));
    EXPECT_TRUE(is_object(char_array_unbounded_info));
    EXPECT_TRUE(is_compound(char_array_unbounded_info));
    EXPECT_FALSE(is_reference(char_array_unbounded_info));
    EXPECT_FALSE(is_member_pointer(char_array_unbounded_info));
    EXPECT_FALSE(is_const(char_array_unbounded_info));
    EXPECT_FALSE(is_volatile(char_array_unbounded_info));
    EXPECT_TRUE(is_trivial(char_array_unbounded_info));
    EXPECT_TRUE(is_trivially_copyable(char_array_unbounded_info));
    EXPECT_TRUE(is_standard_layout(char_array_unbounded_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(char_array_unbounded_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(char_array_unbounded_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(char_array_unbounded_info));
#endif
    EXPECT_FALSE(is_empty(char_array_unbounded_info));
    EXPECT_FALSE(is_polymorphic(char_array_unbounded_info));
    EXPECT_FALSE(is_abstract(char_array_unbounded_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(char_array_unbounded_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(char_array_unbounded_info));
#endif
    EXPECT_FALSE(is_signed(char_array_unbounded_info));
    EXPECT_FALSE(is_unsigned(char_array_unbounded_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(char_array_unbounded_info));
    EXPECT_TRUE(is_unbounded_array(char_array_unbounded_info));
#endif
    EXPECT_FALSE(is_default_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_trivially_default_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_nothrow_default_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_copy_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_trivially_copy_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_nothrow_copy_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_move_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_trivially_move_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_nothrow_move_constructible(char_array_unbounded_info));
    EXPECT_FALSE(is_copy_assignable(char_array_unbounded_info));
    EXPECT_FALSE(is_trivially_copy_assignable(char_array_unbounded_info));
    EXPECT_FALSE(is_move_assignable(char_array_unbounded_info));
    EXPECT_FALSE(is_trivially_move_assignable(char_array_unbounded_info));
    EXPECT_FALSE(is_nothrow_move_assignable(char_array_unbounded_info));
    EXPECT_FALSE(is_destructible(char_array_unbounded_info));
    EXPECT_FALSE(is_trivially_destructible(char_array_unbounded_info));
    EXPECT_FALSE(is_nothrow_destructible(char_array_unbounded_info));
    EXPECT_FALSE(has_virtual_destructor(char_array_unbounded_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_swappable(char_array_unbounded_info));
    EXPECT_FALSE(is_nothrow_swappable(char_array_unbounded_info));
#endif
  }

  // char array bounded
  {
    EXPECT_FALSE(is_void(char_array_bounded_size3_info));
    EXPECT_FALSE(is_null_pointer(char_array_bounded_size3_info));
    EXPECT_FALSE(is_integral(char_array_bounded_size3_info));
    EXPECT_FALSE(is_floating_point(char_array_bounded_size3_info));
    EXPECT_TRUE(is_array(char_array_bounded_size3_info));
    EXPECT_FALSE(is_enum(char_array_bounded_size3_info));
    EXPECT_FALSE(is_union(char_array_bounded_size3_info));
    EXPECT_FALSE(is_class(char_array_bounded_size3_info));
    EXPECT_FALSE(is_function(char_array_bounded_size3_info));
    EXPECT_FALSE(is_pointer(char_array_bounded_size3_info));
    EXPECT_FALSE(is_lvalue_reference(char_array_bounded_size3_info));
    EXPECT_FALSE(is_rvalue_reference(char_array_bounded_size3_info));
    EXPECT_FALSE(is_member_function_pointer(char_array_bounded_size3_info));
    EXPECT_FALSE(is_fundamental(char_array_bounded_size3_info));
    EXPECT_FALSE(is_arithmetic(char_array_bounded_size3_info));
    EXPECT_FALSE(is_scalar(char_array_bounded_size3_info));
    EXPECT_TRUE(is_object(char_array_bounded_size3_info));
    EXPECT_TRUE(is_compound(char_array_bounded_size3_info));
    EXPECT_FALSE(is_reference(char_array_bounded_size3_info));
    EXPECT_FALSE(is_member_pointer(char_array_bounded_size3_info));
    EXPECT_FALSE(is_const(char_array_bounded_size3_info));
    EXPECT_FALSE(is_volatile(char_array_bounded_size3_info));
    EXPECT_TRUE(is_trivial(char_array_bounded_size3_info));
    EXPECT_TRUE(is_trivially_copyable(char_array_bounded_size3_info));
    EXPECT_TRUE(is_standard_layout(char_array_bounded_size3_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(char_array_bounded_size3_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(char_array_bounded_size3_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(char_array_bounded_size3_info));
#endif
    EXPECT_FALSE(is_empty(char_array_bounded_size3_info));
    EXPECT_FALSE(is_polymorphic(char_array_bounded_size3_info));
    EXPECT_FALSE(is_abstract(char_array_bounded_size3_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(char_array_bounded_size3_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(char_array_bounded_size3_info));
#endif
    EXPECT_FALSE(is_signed(char_array_bounded_size3_info));
    EXPECT_FALSE(is_unsigned(char_array_bounded_size3_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_TRUE(is_bounded_array(char_array_bounded_size3_info));
    EXPECT_FALSE(is_unbounded_array(char_array_bounded_size3_info));
#endif
    EXPECT_TRUE(is_default_constructible(char_array_bounded_size3_info));
    EXPECT_TRUE(is_trivially_default_constructible(char_array_bounded_size3_info));
    EXPECT_TRUE(is_nothrow_default_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_copy_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_trivially_copy_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_nothrow_copy_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_move_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_trivially_move_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_nothrow_move_constructible(char_array_bounded_size3_info));
    EXPECT_FALSE(is_copy_assignable(char_array_bounded_size3_info));
    EXPECT_FALSE(is_trivially_copy_assignable(char_array_bounded_size3_info));
    EXPECT_FALSE(is_move_assignable(char_array_bounded_size3_info));
    EXPECT_FALSE(is_trivially_move_assignable(char_array_bounded_size3_info));
    EXPECT_FALSE(is_nothrow_move_assignable(char_array_bounded_size3_info));
    EXPECT_TRUE(is_destructible(char_array_bounded_size3_info));
    EXPECT_TRUE(is_trivially_destructible(char_array_bounded_size3_info));
    EXPECT_TRUE(is_nothrow_destructible(char_array_bounded_size3_info));
    EXPECT_FALSE(has_virtual_destructor(char_array_bounded_size3_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(char_array_bounded_size3_info));
    EXPECT_TRUE(is_nothrow_swappable(char_array_bounded_size3_info));
#endif
  }

  // enum
  {
    EXPECT_FALSE(is_void(enum1_info));
    EXPECT_FALSE(is_null_pointer(enum1_info));
    EXPECT_FALSE(is_integral(enum1_info));
    EXPECT_FALSE(is_floating_point(enum1_info));
    EXPECT_FALSE(is_array(enum1_info));
    EXPECT_TRUE(is_enum(enum1_info));
    EXPECT_FALSE(is_union(enum1_info));
    EXPECT_FALSE(is_class(enum1_info));
    EXPECT_FALSE(is_function(enum1_info));
    EXPECT_FALSE(is_pointer(enum1_info));
    EXPECT_FALSE(is_lvalue_reference(enum1_info));
    EXPECT_FALSE(is_rvalue_reference(enum1_info));
    EXPECT_FALSE(is_member_function_pointer(enum1_info));
    EXPECT_FALSE(is_fundamental(enum1_info));
    EXPECT_FALSE(is_arithmetic(enum1_info));
    EXPECT_TRUE(is_scalar(enum1_info));
    EXPECT_TRUE(is_object(enum1_info));
    EXPECT_TRUE(is_compound(enum1_info));
    EXPECT_FALSE(is_reference(enum1_info));
    EXPECT_FALSE(is_member_pointer(enum1_info));
    EXPECT_FALSE(is_const(enum1_info));
    EXPECT_FALSE(is_volatile(enum1_info));
    EXPECT_TRUE(is_trivial(enum1_info));
    EXPECT_TRUE(is_trivially_copyable(enum1_info));
    EXPECT_TRUE(is_standard_layout(enum1_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(enum1_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(enum1_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(enum1_info));
#endif
    EXPECT_FALSE(is_empty(enum1_info));
    EXPECT_FALSE(is_polymorphic(enum1_info));
    EXPECT_FALSE(is_abstract(enum1_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(enum1_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(enum1_info));
#endif
    EXPECT_FALSE(is_signed(enum1_info));
    EXPECT_FALSE(is_unsigned(enum1_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(enum1_info));
    EXPECT_FALSE(is_unbounded_array(enum1_info));
#endif
    EXPECT_TRUE(is_default_constructible(enum1_info));
    EXPECT_TRUE(is_trivially_default_constructible(enum1_info));
    EXPECT_TRUE(is_nothrow_default_constructible(enum1_info));
    EXPECT_TRUE(is_copy_constructible(enum1_info));
    EXPECT_TRUE(is_trivially_copy_constructible(enum1_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(enum1_info));
    EXPECT_TRUE(is_move_constructible(enum1_info));
    EXPECT_TRUE(is_trivially_move_constructible(enum1_info));
    EXPECT_TRUE(is_nothrow_move_constructible(enum1_info));
    EXPECT_TRUE(is_copy_assignable(enum1_info));
    EXPECT_TRUE(is_trivially_copy_assignable(enum1_info));
    EXPECT_TRUE(is_move_assignable(enum1_info));
    EXPECT_TRUE(is_trivially_move_assignable(enum1_info));
    EXPECT_TRUE(is_nothrow_move_assignable(enum1_info));
    EXPECT_TRUE(is_destructible(enum1_info));
    EXPECT_TRUE(is_trivially_destructible(enum1_info));
    EXPECT_TRUE(is_nothrow_destructible(enum1_info));
    EXPECT_FALSE(has_virtual_destructor(enum1_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(enum1_info));
    EXPECT_TRUE(is_nothrow_swappable(enum1_info));
#endif
  }

  // union
  {
    EXPECT_FALSE(is_void(union_info));
    EXPECT_FALSE(is_null_pointer(union_info));
    EXPECT_FALSE(is_integral(union_info));
    EXPECT_FALSE(is_floating_point(union_info));
    EXPECT_FALSE(is_array(union_info));
    EXPECT_FALSE(is_enum(union_info));
    EXPECT_TRUE(is_union(union_info));
    EXPECT_FALSE(is_class(union_info));
    EXPECT_FALSE(is_function(union_info));
    EXPECT_FALSE(is_pointer(union_info));
    EXPECT_FALSE(is_lvalue_reference(union_info));
    EXPECT_FALSE(is_rvalue_reference(union_info));
    EXPECT_FALSE(is_member_function_pointer(union_info));
    EXPECT_FALSE(is_fundamental(union_info));
    EXPECT_FALSE(is_arithmetic(union_info));
    EXPECT_FALSE(is_scalar(union_info));
    EXPECT_TRUE(is_object(union_info));
    EXPECT_TRUE(is_compound(union_info));
    EXPECT_FALSE(is_reference(union_info));
    EXPECT_FALSE(is_member_pointer(union_info));
    EXPECT_FALSE(is_const(union_info));
    EXPECT_FALSE(is_volatile(union_info));
    EXPECT_TRUE(is_trivial(union_info));
    EXPECT_TRUE(is_trivially_copyable(union_info));
    EXPECT_TRUE(is_standard_layout(union_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(union_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(union_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(union_info));
#endif
    EXPECT_FALSE(is_empty(union_info));
    EXPECT_FALSE(is_polymorphic(union_info));
    EXPECT_FALSE(is_abstract(union_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(union_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(union_info));
#endif
    EXPECT_FALSE(is_signed(union_info));
    EXPECT_FALSE(is_unsigned(union_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(union_info));
    EXPECT_FALSE(is_unbounded_array(union_info));
#endif
    EXPECT_TRUE(is_default_constructible(union_info));
    EXPECT_TRUE(is_trivially_default_constructible(union_info));
    EXPECT_TRUE(is_nothrow_default_constructible(union_info));
    EXPECT_TRUE(is_copy_constructible(union_info));
    EXPECT_TRUE(is_trivially_copy_constructible(union_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(union_info));
    EXPECT_TRUE(is_move_constructible(union_info));
    EXPECT_TRUE(is_trivially_move_constructible(union_info));
    EXPECT_TRUE(is_nothrow_move_constructible(union_info));
    EXPECT_TRUE(is_copy_assignable(union_info));
    EXPECT_TRUE(is_trivially_copy_assignable(union_info));
    EXPECT_TRUE(is_move_assignable(union_info));
    EXPECT_TRUE(is_trivially_move_assignable(union_info));
    EXPECT_TRUE(is_nothrow_move_assignable(union_info));
    EXPECT_TRUE(is_destructible(union_info));
    EXPECT_TRUE(is_trivially_destructible(union_info));
    EXPECT_TRUE(is_nothrow_destructible(union_info));
    EXPECT_FALSE(has_virtual_destructor(union_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(union_info));
    EXPECT_TRUE(is_nothrow_swappable(union_info));
#endif
  }

  // base
  {
    EXPECT_FALSE(is_void(base_info));
    EXPECT_FALSE(is_null_pointer(base_info));
    EXPECT_FALSE(is_integral(base_info));
    EXPECT_FALSE(is_floating_point(base_info));
    EXPECT_FALSE(is_array(base_info));
    EXPECT_FALSE(is_enum(base_info));
    EXPECT_FALSE(is_union(base_info));
    EXPECT_TRUE(is_class(base_info));
    EXPECT_FALSE(is_function(base_info));
    EXPECT_FALSE(is_pointer(base_info));
    EXPECT_FALSE(is_lvalue_reference(base_info));
    EXPECT_FALSE(is_rvalue_reference(base_info));
    EXPECT_FALSE(is_member_function_pointer(base_info));
    EXPECT_FALSE(is_fundamental(base_info));
    EXPECT_FALSE(is_arithmetic(base_info));
    EXPECT_FALSE(is_scalar(base_info));
    EXPECT_TRUE(is_object(base_info));
    EXPECT_TRUE(is_compound(base_info));
    EXPECT_FALSE(is_reference(base_info));
    EXPECT_FALSE(is_member_pointer(base_info));
    EXPECT_FALSE(is_const(base_info));
    EXPECT_FALSE(is_volatile(base_info));
    EXPECT_TRUE(is_trivial(base_info));
    EXPECT_TRUE(is_trivially_copyable(base_info));
    EXPECT_TRUE(is_standard_layout(base_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(base_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(base_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(base_info));
#endif
    EXPECT_FALSE(is_empty(base_info));
    EXPECT_FALSE(is_polymorphic(base_info));
    EXPECT_FALSE(is_abstract(base_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(base_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(base_info));
#endif
    EXPECT_FALSE(is_signed(base_info));
    EXPECT_FALSE(is_unsigned(base_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(base_info));
    EXPECT_FALSE(is_unbounded_array(base_info));
#endif
    EXPECT_TRUE(is_default_constructible(base_info));
    EXPECT_TRUE(is_trivially_default_constructible(base_info));
    EXPECT_TRUE(is_nothrow_default_constructible(base_info));
    EXPECT_TRUE(is_copy_constructible(base_info));
    EXPECT_TRUE(is_trivially_copy_constructible(base_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(base_info));
    EXPECT_TRUE(is_move_constructible(base_info));
    EXPECT_TRUE(is_trivially_move_constructible(base_info));
    EXPECT_TRUE(is_nothrow_move_constructible(base_info));
    EXPECT_TRUE(is_copy_assignable(base_info));
    EXPECT_TRUE(is_trivially_copy_assignable(base_info));
    EXPECT_TRUE(is_move_assignable(base_info));
    EXPECT_TRUE(is_trivially_move_assignable(base_info));
    EXPECT_TRUE(is_nothrow_move_assignable(base_info));
    EXPECT_TRUE(is_destructible(base_info));
    EXPECT_TRUE(is_trivially_destructible(base_info));
    EXPECT_TRUE(is_nothrow_destructible(base_info));
    EXPECT_FALSE(has_virtual_destructor(base_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(base_info));
    EXPECT_TRUE(is_nothrow_swappable(base_info));
#endif
  }

  // derived
  {
    EXPECT_FALSE(is_void(derived_info));
    EXPECT_FALSE(is_null_pointer(derived_info));
    EXPECT_FALSE(is_integral(derived_info));
    EXPECT_FALSE(is_floating_point(derived_info));
    EXPECT_FALSE(is_array(derived_info));
    EXPECT_FALSE(is_enum(derived_info));
    EXPECT_FALSE(is_union(derived_info));
    EXPECT_TRUE(is_class(derived_info));
    EXPECT_FALSE(is_function(derived_info));
    EXPECT_FALSE(is_pointer(derived_info));
    EXPECT_FALSE(is_lvalue_reference(derived_info));
    EXPECT_FALSE(is_rvalue_reference(derived_info));
    EXPECT_FALSE(is_member_function_pointer(derived_info));
    EXPECT_FALSE(is_fundamental(derived_info));
    EXPECT_FALSE(is_arithmetic(derived_info));
    EXPECT_FALSE(is_scalar(derived_info));
    EXPECT_TRUE(is_object(derived_info));
    EXPECT_TRUE(is_compound(derived_info));
    EXPECT_FALSE(is_reference(derived_info));
    EXPECT_FALSE(is_member_pointer(derived_info));
    EXPECT_FALSE(is_const(derived_info));
    EXPECT_FALSE(is_volatile(derived_info));
    EXPECT_TRUE(is_trivial(derived_info));
    EXPECT_TRUE(is_trivially_copyable(derived_info));
    EXPECT_FALSE(is_standard_layout(derived_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(derived_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(derived_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(derived_info));
#endif
    EXPECT_FALSE(is_empty(derived_info));
    EXPECT_FALSE(is_polymorphic(derived_info));
    EXPECT_FALSE(is_abstract(derived_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(derived_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(derived_info));
#endif
    EXPECT_FALSE(is_signed(derived_info));
    EXPECT_FALSE(is_unsigned(derived_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(derived_info));
    EXPECT_FALSE(is_unbounded_array(derived_info));
#endif
    EXPECT_TRUE(is_default_constructible(derived_info));
    EXPECT_TRUE(is_trivially_default_constructible(derived_info));
    EXPECT_TRUE(is_nothrow_default_constructible(derived_info));
    EXPECT_TRUE(is_copy_constructible(derived_info));
    EXPECT_TRUE(is_trivially_copy_constructible(derived_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(derived_info));
    EXPECT_TRUE(is_move_constructible(derived_info));
    EXPECT_TRUE(is_trivially_move_constructible(derived_info));
    EXPECT_TRUE(is_nothrow_move_constructible(derived_info));
    EXPECT_TRUE(is_copy_assignable(derived_info));
    EXPECT_TRUE(is_trivially_copy_assignable(derived_info));
    EXPECT_TRUE(is_move_assignable(derived_info));
    EXPECT_TRUE(is_trivially_move_assignable(derived_info));
    EXPECT_TRUE(is_nothrow_move_assignable(derived_info));
    EXPECT_TRUE(is_destructible(derived_info));
    EXPECT_TRUE(is_trivially_destructible(derived_info));
    EXPECT_TRUE(is_nothrow_destructible(derived_info));
    EXPECT_FALSE(has_virtual_destructor(derived_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(derived_info));
    EXPECT_TRUE(is_nothrow_swappable(derived_info));
#endif
  }

  // func
  {
    EXPECT_FALSE(is_void(func_info));
    EXPECT_FALSE(is_null_pointer(func_info));
    EXPECT_FALSE(is_integral(func_info));
    EXPECT_FALSE(is_floating_point(func_info));
    EXPECT_FALSE(is_array(func_info));
    EXPECT_FALSE(is_enum(func_info));
    EXPECT_FALSE(is_union(func_info));
    EXPECT_FALSE(is_class(func_info));
    EXPECT_TRUE(is_function(func_info));
    EXPECT_FALSE(is_pointer(func_info));
    EXPECT_FALSE(is_lvalue_reference(func_info));
    EXPECT_FALSE(is_rvalue_reference(func_info));
    EXPECT_FALSE(is_member_function_pointer(func_info));
    EXPECT_FALSE(is_fundamental(func_info));
    EXPECT_FALSE(is_arithmetic(func_info));
    EXPECT_FALSE(is_scalar(func_info));
    EXPECT_FALSE(is_object(func_info));
    EXPECT_TRUE(is_compound(func_info));
    EXPECT_FALSE(is_reference(func_info));
    EXPECT_FALSE(is_member_pointer(func_info));
    EXPECT_FALSE(is_const(func_info));
    EXPECT_FALSE(is_volatile(func_info));
    EXPECT_FALSE(is_trivial(func_info));
    EXPECT_FALSE(is_trivially_copyable(func_info));
    EXPECT_FALSE(is_standard_layout(func_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(func_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_FALSE(is_literal_type(func_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(func_info));
#endif
    EXPECT_FALSE(is_empty(func_info));
    EXPECT_FALSE(is_polymorphic(func_info));
    EXPECT_FALSE(is_abstract(func_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(func_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(func_info));
#endif
    EXPECT_FALSE(is_signed(func_info));
    EXPECT_FALSE(is_unsigned(func_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(func_info));
    EXPECT_FALSE(is_unbounded_array(func_info));
#endif
    EXPECT_FALSE(is_default_constructible(func_info));
    EXPECT_FALSE(is_trivially_default_constructible(func_info));
    EXPECT_FALSE(is_nothrow_default_constructible(func_info));
    EXPECT_FALSE(is_copy_constructible(func_info));
    EXPECT_FALSE(is_trivially_copy_constructible(func_info));
    EXPECT_FALSE(is_nothrow_copy_constructible(func_info));
    EXPECT_FALSE(is_move_constructible(func_info));
    EXPECT_FALSE(is_trivially_move_constructible(func_info));
    EXPECT_FALSE(is_nothrow_move_constructible(func_info));
    EXPECT_FALSE(is_copy_assignable(func_info));
    EXPECT_FALSE(is_trivially_copy_assignable(func_info));
    EXPECT_FALSE(is_move_assignable(func_info));
    EXPECT_FALSE(is_trivially_move_assignable(func_info));
    EXPECT_FALSE(is_nothrow_move_assignable(func_info));
    EXPECT_FALSE(is_destructible(func_info));
    EXPECT_FALSE(is_trivially_destructible(func_info));
    EXPECT_FALSE(is_nothrow_destructible(func_info));
    EXPECT_FALSE(has_virtual_destructor(func_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_swappable(func_info));
    EXPECT_FALSE(is_nothrow_swappable(func_info));
#endif
  }

  // int*
  {
    EXPECT_FALSE(is_void(intp_info));
    EXPECT_FALSE(is_null_pointer(intp_info));
    EXPECT_FALSE(is_integral(intp_info));
    EXPECT_FALSE(is_floating_point(intp_info));
    EXPECT_FALSE(is_array(intp_info));
    EXPECT_FALSE(is_enum(intp_info));
    EXPECT_FALSE(is_union(intp_info));
    EXPECT_FALSE(is_class(intp_info));
    EXPECT_FALSE(is_function(intp_info));
    EXPECT_TRUE(is_pointer(intp_info));
    EXPECT_FALSE(is_lvalue_reference(intp_info));
    EXPECT_FALSE(is_rvalue_reference(intp_info));
    EXPECT_FALSE(is_member_function_pointer(intp_info));
    EXPECT_FALSE(is_fundamental(intp_info));
    EXPECT_FALSE(is_arithmetic(intp_info));
    EXPECT_TRUE(is_scalar(intp_info));
    EXPECT_TRUE(is_object(intp_info));
    EXPECT_TRUE(is_compound(intp_info));
    EXPECT_FALSE(is_reference(intp_info));
    EXPECT_FALSE(is_member_pointer(intp_info));
    EXPECT_FALSE(is_const(intp_info));
    EXPECT_FALSE(is_volatile(intp_info));
    EXPECT_TRUE(is_trivial(intp_info));
    EXPECT_TRUE(is_trivially_copyable(intp_info));
    EXPECT_TRUE(is_standard_layout(intp_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(intp_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(intp_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(intp_info));
#endif
    EXPECT_FALSE(is_empty(intp_info));
    EXPECT_FALSE(is_polymorphic(intp_info));
    EXPECT_FALSE(is_abstract(intp_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(intp_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(intp_info));
#endif
    EXPECT_FALSE(is_signed(intp_info));
    EXPECT_FALSE(is_unsigned(intp_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(intp_info));
    EXPECT_FALSE(is_unbounded_array(intp_info));
#endif
    EXPECT_TRUE(is_default_constructible(intp_info));
    EXPECT_TRUE(is_trivially_default_constructible(intp_info));
    EXPECT_TRUE(is_nothrow_default_constructible(intp_info));
    EXPECT_TRUE(is_copy_constructible(intp_info));
    EXPECT_TRUE(is_trivially_copy_constructible(intp_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(intp_info));
    EXPECT_TRUE(is_move_constructible(intp_info));
    EXPECT_TRUE(is_trivially_move_constructible(intp_info));
    EXPECT_TRUE(is_nothrow_move_constructible(intp_info));
    EXPECT_TRUE(is_copy_assignable(intp_info));
    EXPECT_TRUE(is_trivially_copy_assignable(intp_info));
    EXPECT_TRUE(is_move_assignable(intp_info));
    EXPECT_TRUE(is_trivially_move_assignable(intp_info));
    EXPECT_TRUE(is_nothrow_move_assignable(intp_info));
    EXPECT_TRUE(is_destructible(intp_info));
    EXPECT_TRUE(is_trivially_destructible(intp_info));
    EXPECT_TRUE(is_nothrow_destructible(intp_info));
    EXPECT_FALSE(has_virtual_destructor(intp_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(intp_info));
    EXPECT_TRUE(is_nothrow_swappable(intp_info));
#endif
  }

  // int**
  {
    EXPECT_FALSE(is_void(intpp_info));
    EXPECT_FALSE(is_null_pointer(intpp_info));
    EXPECT_FALSE(is_integral(intpp_info));
    EXPECT_FALSE(is_floating_point(intpp_info));
    EXPECT_FALSE(is_array(intpp_info));
    EXPECT_FALSE(is_enum(intpp_info));
    EXPECT_FALSE(is_union(intpp_info));
    EXPECT_FALSE(is_class(intpp_info));
    EXPECT_FALSE(is_function(intpp_info));
    EXPECT_TRUE(is_pointer(intpp_info));
    EXPECT_FALSE(is_lvalue_reference(intpp_info));
    EXPECT_FALSE(is_rvalue_reference(intpp_info));
    EXPECT_FALSE(is_member_function_pointer(intpp_info));
    EXPECT_FALSE(is_fundamental(intpp_info));
    EXPECT_FALSE(is_arithmetic(intpp_info));
    EXPECT_TRUE(is_scalar(intpp_info));
    EXPECT_TRUE(is_object(intpp_info));
    EXPECT_TRUE(is_compound(intpp_info));
    EXPECT_FALSE(is_reference(intpp_info));
    EXPECT_FALSE(is_member_pointer(intpp_info));
    EXPECT_FALSE(is_const(intpp_info));
    EXPECT_FALSE(is_volatile(intpp_info));
    EXPECT_TRUE(is_trivial(intpp_info));
    EXPECT_TRUE(is_trivially_copyable(intpp_info));
    EXPECT_TRUE(is_standard_layout(intpp_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(intpp_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(intpp_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(intpp_info));
#endif
    EXPECT_FALSE(is_empty(intpp_info));
    EXPECT_FALSE(is_polymorphic(intpp_info));
    EXPECT_FALSE(is_abstract(intpp_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(intpp_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(intpp_info));
#endif
    EXPECT_FALSE(is_signed(intpp_info));
    EXPECT_FALSE(is_unsigned(intpp_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(intpp_info));
    EXPECT_FALSE(is_unbounded_array(intpp_info));
#endif
    EXPECT_TRUE(is_default_constructible(intpp_info));
    EXPECT_TRUE(is_trivially_default_constructible(intpp_info));
    EXPECT_TRUE(is_nothrow_default_constructible(intpp_info));
    EXPECT_TRUE(is_copy_constructible(intpp_info));
    EXPECT_TRUE(is_trivially_copy_constructible(intpp_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(intpp_info));
    EXPECT_TRUE(is_move_constructible(intpp_info));
    EXPECT_TRUE(is_trivially_move_constructible(intpp_info));
    EXPECT_TRUE(is_nothrow_move_constructible(intpp_info));
    EXPECT_TRUE(is_copy_assignable(intpp_info));
    EXPECT_TRUE(is_trivially_copy_assignable(intpp_info));
    EXPECT_TRUE(is_move_assignable(intpp_info));
    EXPECT_TRUE(is_trivially_move_assignable(intpp_info));
    EXPECT_TRUE(is_nothrow_move_assignable(intpp_info));
    EXPECT_TRUE(is_destructible(intpp_info));
    EXPECT_TRUE(is_trivially_destructible(intpp_info));
    EXPECT_TRUE(is_nothrow_destructible(intpp_info));
    EXPECT_FALSE(has_virtual_destructor(intpp_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(intpp_info));
    EXPECT_TRUE(is_nothrow_swappable(intpp_info));
#endif
  }

  // int&
  {
    EXPECT_FALSE(is_void(intr_info));
    EXPECT_FALSE(is_null_pointer(intr_info));
    EXPECT_FALSE(is_integral(intr_info));
    EXPECT_FALSE(is_floating_point(intr_info));
    EXPECT_FALSE(is_array(intr_info));
    EXPECT_FALSE(is_enum(intr_info));
    EXPECT_FALSE(is_union(intr_info));
    EXPECT_FALSE(is_class(intr_info));
    EXPECT_FALSE(is_function(intr_info));
    EXPECT_FALSE(is_pointer(intr_info));
    EXPECT_TRUE(is_lvalue_reference(intr_info));
    EXPECT_FALSE(is_rvalue_reference(intr_info));
    EXPECT_FALSE(is_member_function_pointer(intr_info));
    EXPECT_FALSE(is_fundamental(intr_info));
    EXPECT_FALSE(is_arithmetic(intr_info));
    EXPECT_FALSE(is_scalar(intr_info));
    EXPECT_FALSE(is_object(intr_info));
    EXPECT_TRUE(is_compound(intr_info));
    EXPECT_TRUE(is_reference(intr_info));
    EXPECT_FALSE(is_member_pointer(intr_info));
    EXPECT_FALSE(is_const(intr_info));
    EXPECT_FALSE(is_volatile(intr_info));
    EXPECT_FALSE(is_trivial(intr_info));
    EXPECT_FALSE(is_trivially_copyable(intr_info));
    EXPECT_FALSE(is_standard_layout(intr_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(intr_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(intr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(intr_info));
#endif
    EXPECT_FALSE(is_empty(intr_info));
    EXPECT_FALSE(is_polymorphic(intr_info));
    EXPECT_FALSE(is_abstract(intr_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(intr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(intr_info));
#endif
    EXPECT_FALSE(is_signed(intr_info));
    EXPECT_FALSE(is_unsigned(intr_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(intr_info));
    EXPECT_FALSE(is_unbounded_array(intr_info));
#endif
    EXPECT_FALSE(is_default_constructible(intr_info));
    EXPECT_FALSE(is_trivially_default_constructible(intr_info));
    EXPECT_FALSE(is_nothrow_default_constructible(intr_info));
    EXPECT_TRUE(is_copy_constructible(intr_info));
    EXPECT_TRUE(is_trivially_copy_constructible(intr_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(intr_info));
    EXPECT_TRUE(is_move_constructible(intr_info));
    EXPECT_TRUE(is_trivially_move_constructible(intr_info));
    EXPECT_TRUE(is_nothrow_move_constructible(intr_info));
    EXPECT_TRUE(is_copy_assignable(intr_info));
    EXPECT_TRUE(is_trivially_copy_assignable(intr_info));
    EXPECT_TRUE(is_move_assignable(intr_info));
    EXPECT_TRUE(is_trivially_move_assignable(intr_info));
    EXPECT_TRUE(is_nothrow_move_assignable(intr_info));
    EXPECT_TRUE(is_destructible(intr_info));
    EXPECT_TRUE(is_trivially_destructible(intr_info));
    EXPECT_TRUE(is_nothrow_destructible(intr_info));
    EXPECT_FALSE(has_virtual_destructor(intr_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(intr_info));
    EXPECT_TRUE(is_nothrow_swappable(intr_info));
#endif
  }

  // int&&
  {
    EXPECT_FALSE(is_void(intrr_info));
    EXPECT_FALSE(is_null_pointer(intrr_info));
    EXPECT_FALSE(is_integral(intrr_info));
    EXPECT_FALSE(is_floating_point(intrr_info));
    EXPECT_FALSE(is_array(intrr_info));
    EXPECT_FALSE(is_enum(intrr_info));
    EXPECT_FALSE(is_union(intrr_info));
    EXPECT_FALSE(is_class(intrr_info));
    EXPECT_FALSE(is_function(intrr_info));
    EXPECT_FALSE(is_pointer(intrr_info));
    EXPECT_FALSE(is_lvalue_reference(intrr_info));
    EXPECT_TRUE(is_rvalue_reference(intrr_info));
    EXPECT_FALSE(is_member_function_pointer(intrr_info));
    EXPECT_FALSE(is_fundamental(intrr_info));
    EXPECT_FALSE(is_arithmetic(intrr_info));
    EXPECT_FALSE(is_scalar(intrr_info));
    EXPECT_FALSE(is_object(intrr_info));
    EXPECT_TRUE(is_compound(intrr_info));
    EXPECT_TRUE(is_reference(intrr_info));
    EXPECT_FALSE(is_member_pointer(intrr_info));
    EXPECT_FALSE(is_const(intrr_info));
    EXPECT_FALSE(is_volatile(intrr_info));
    EXPECT_FALSE(is_trivial(intrr_info));
    EXPECT_FALSE(is_trivially_copyable(intrr_info));
    EXPECT_FALSE(is_standard_layout(intrr_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(intrr_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(intrr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(intrr_info));
#endif
    EXPECT_FALSE(is_empty(intrr_info));
    EXPECT_FALSE(is_polymorphic(intrr_info));
    EXPECT_FALSE(is_abstract(intrr_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(intrr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(intrr_info));
#endif
    EXPECT_FALSE(is_signed(intrr_info));
    EXPECT_FALSE(is_unsigned(intrr_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(intrr_info));
    EXPECT_FALSE(is_unbounded_array(intrr_info));
#endif
    EXPECT_FALSE(is_default_constructible(intrr_info));
    EXPECT_FALSE(is_trivially_default_constructible(intrr_info));
    EXPECT_FALSE(is_nothrow_default_constructible(intrr_info));
    EXPECT_FALSE(is_copy_constructible(intrr_info));
    EXPECT_FALSE(is_trivially_copy_constructible(intrr_info));
    EXPECT_FALSE(is_nothrow_copy_constructible(intrr_info));
    EXPECT_TRUE(is_move_constructible(intrr_info));
    EXPECT_TRUE(is_trivially_move_constructible(intrr_info));
    EXPECT_TRUE(is_nothrow_move_constructible(intrr_info));
    EXPECT_TRUE(is_copy_assignable(intrr_info));
    EXPECT_TRUE(is_trivially_copy_assignable(intrr_info));
    EXPECT_TRUE(is_move_assignable(intrr_info));
    EXPECT_TRUE(is_trivially_move_assignable(intrr_info));
    EXPECT_TRUE(is_nothrow_move_assignable(intrr_info));
    EXPECT_TRUE(is_destructible(intrr_info));
    EXPECT_TRUE(is_trivially_destructible(intrr_info));
    EXPECT_TRUE(is_nothrow_destructible(intrr_info));
    EXPECT_FALSE(has_virtual_destructor(intrr_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(intrr_info));
    EXPECT_TRUE(is_nothrow_swappable(intrr_info));
#endif
  }

  // data member
  {
    EXPECT_FALSE(is_void(mem_obj_ptr_info));
    EXPECT_FALSE(is_null_pointer(mem_obj_ptr_info));
    EXPECT_FALSE(is_integral(mem_obj_ptr_info));
    EXPECT_FALSE(is_floating_point(mem_obj_ptr_info));
    EXPECT_FALSE(is_array(mem_obj_ptr_info));
    EXPECT_FALSE(is_enum(mem_obj_ptr_info));
    EXPECT_FALSE(is_union(mem_obj_ptr_info));
    EXPECT_FALSE(is_class(mem_obj_ptr_info));
    EXPECT_FALSE(is_function(mem_obj_ptr_info));
    EXPECT_FALSE(is_pointer(mem_obj_ptr_info));
    EXPECT_FALSE(is_lvalue_reference(mem_obj_ptr_info));
    EXPECT_FALSE(is_rvalue_reference(mem_obj_ptr_info));
    EXPECT_FALSE(is_member_function_pointer(mem_obj_ptr_info));
    EXPECT_FALSE(is_fundamental(mem_obj_ptr_info));
    EXPECT_FALSE(is_arithmetic(mem_obj_ptr_info));
    EXPECT_TRUE(is_scalar(mem_obj_ptr_info));
    EXPECT_TRUE(is_object(mem_obj_ptr_info));
    EXPECT_TRUE(is_compound(mem_obj_ptr_info));
    EXPECT_FALSE(is_reference(mem_obj_ptr_info));
    EXPECT_TRUE(is_member_pointer(mem_obj_ptr_info));
    EXPECT_FALSE(is_const(mem_obj_ptr_info));
    EXPECT_FALSE(is_volatile(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivial(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_copyable(mem_obj_ptr_info));
    EXPECT_TRUE(is_standard_layout(mem_obj_ptr_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(mem_obj_ptr_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(mem_obj_ptr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(mem_obj_ptr_info));
#endif
    EXPECT_FALSE(is_empty(mem_obj_ptr_info));
    EXPECT_FALSE(is_polymorphic(mem_obj_ptr_info));
    EXPECT_FALSE(is_abstract(mem_obj_ptr_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(mem_obj_ptr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(mem_obj_ptr_info));
#endif
    EXPECT_FALSE(is_signed(mem_obj_ptr_info));
    EXPECT_FALSE(is_unsigned(mem_obj_ptr_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(mem_obj_ptr_info));
    EXPECT_FALSE(is_unbounded_array(mem_obj_ptr_info));
#endif
    EXPECT_TRUE(is_default_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_default_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_nothrow_default_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_copy_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_copy_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_move_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_move_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_nothrow_move_constructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_copy_assignable(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_copy_assignable(mem_obj_ptr_info));
    EXPECT_TRUE(is_move_assignable(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_move_assignable(mem_obj_ptr_info));
    EXPECT_TRUE(is_nothrow_move_assignable(mem_obj_ptr_info));
    EXPECT_TRUE(is_destructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_trivially_destructible(mem_obj_ptr_info));
    EXPECT_TRUE(is_nothrow_destructible(mem_obj_ptr_info));
    EXPECT_FALSE(has_virtual_destructor(mem_obj_ptr_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(mem_obj_ptr_info));
    EXPECT_TRUE(is_nothrow_swappable(mem_obj_ptr_info));
#endif
  }

  // member func
  {
    EXPECT_FALSE(is_void(mem_fun_ptr_info));
    EXPECT_FALSE(is_null_pointer(mem_fun_ptr_info));
    EXPECT_FALSE(is_integral(mem_fun_ptr_info));
    EXPECT_FALSE(is_floating_point(mem_fun_ptr_info));
    EXPECT_FALSE(is_array(mem_fun_ptr_info));
    EXPECT_FALSE(is_enum(mem_fun_ptr_info));
    EXPECT_FALSE(is_union(mem_fun_ptr_info));
    EXPECT_FALSE(is_class(mem_fun_ptr_info));
    EXPECT_FALSE(is_function(mem_fun_ptr_info));
    EXPECT_FALSE(is_pointer(mem_fun_ptr_info));
    EXPECT_FALSE(is_lvalue_reference(mem_fun_ptr_info));
    EXPECT_FALSE(is_rvalue_reference(mem_fun_ptr_info));
    EXPECT_TRUE(is_member_function_pointer(mem_fun_ptr_info));
    EXPECT_FALSE(is_fundamental(mem_fun_ptr_info));
    EXPECT_FALSE(is_arithmetic(mem_fun_ptr_info));
    EXPECT_TRUE(is_scalar(mem_fun_ptr_info));
    EXPECT_TRUE(is_object(mem_fun_ptr_info));
    EXPECT_TRUE(is_compound(mem_fun_ptr_info));
    EXPECT_FALSE(is_reference(mem_fun_ptr_info));
    EXPECT_TRUE(is_member_pointer(mem_fun_ptr_info));
    EXPECT_FALSE(is_const(mem_fun_ptr_info));
    EXPECT_FALSE(is_volatile(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivial(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_copyable(mem_fun_ptr_info));
    EXPECT_TRUE(is_standard_layout(mem_fun_ptr_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(mem_fun_ptr_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(mem_fun_ptr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(mem_fun_ptr_info));
#endif
    EXPECT_FALSE(is_empty(mem_fun_ptr_info));
    EXPECT_FALSE(is_polymorphic(mem_fun_ptr_info));
    EXPECT_FALSE(is_abstract(mem_fun_ptr_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(mem_fun_ptr_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(mem_fun_ptr_info));
#endif
    EXPECT_FALSE(is_signed(mem_fun_ptr_info));
    EXPECT_FALSE(is_unsigned(mem_fun_ptr_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(mem_fun_ptr_info));
    EXPECT_FALSE(is_unbounded_array(mem_fun_ptr_info));
#endif
    EXPECT_TRUE(is_default_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_default_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_nothrow_default_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_copy_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_copy_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_move_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_move_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_nothrow_move_constructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_copy_assignable(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_copy_assignable(mem_fun_ptr_info));
    EXPECT_TRUE(is_move_assignable(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_move_assignable(mem_fun_ptr_info));
    EXPECT_TRUE(is_nothrow_move_assignable(mem_fun_ptr_info));
    EXPECT_TRUE(is_destructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_trivially_destructible(mem_fun_ptr_info));
    EXPECT_TRUE(is_nothrow_destructible(mem_fun_ptr_info));
    EXPECT_FALSE(has_virtual_destructor(mem_fun_ptr_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(mem_fun_ptr_info));
    EXPECT_TRUE(is_nothrow_swappable(mem_fun_ptr_info));
#endif
  }

  // pod
  {
    EXPECT_FALSE(is_void(pod_info));
    EXPECT_FALSE(is_null_pointer(pod_info));
    EXPECT_FALSE(is_integral(pod_info));
    EXPECT_FALSE(is_floating_point(pod_info));
    EXPECT_FALSE(is_array(pod_info));
    EXPECT_FALSE(is_enum(pod_info));
    EXPECT_FALSE(is_union(pod_info));
    EXPECT_TRUE(is_class(pod_info));
    EXPECT_FALSE(is_function(pod_info));
    EXPECT_FALSE(is_pointer(pod_info));
    EXPECT_FALSE(is_lvalue_reference(pod_info));
    EXPECT_FALSE(is_rvalue_reference(pod_info));
    EXPECT_FALSE(is_member_function_pointer(pod_info));
    EXPECT_FALSE(is_fundamental(pod_info));
    EXPECT_FALSE(is_arithmetic(pod_info));
    EXPECT_FALSE(is_scalar(pod_info));
    EXPECT_TRUE(is_object(pod_info));
    EXPECT_TRUE(is_compound(pod_info));
    EXPECT_FALSE(is_reference(pod_info));
    EXPECT_FALSE(is_member_pointer(pod_info));
    EXPECT_FALSE(is_const(pod_info));
    EXPECT_FALSE(is_volatile(pod_info));
    EXPECT_TRUE(is_trivial(pod_info));
    EXPECT_TRUE(is_trivially_copyable(pod_info));
    EXPECT_TRUE(is_standard_layout(pod_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(pod_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(pod_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(has_unique_object_representations(pod_info));
#endif
    EXPECT_FALSE(is_empty(pod_info));
    EXPECT_FALSE(is_polymorphic(pod_info));
    EXPECT_FALSE(is_abstract(pod_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(pod_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(pod_info));
#endif
    EXPECT_FALSE(is_signed(pod_info));
    EXPECT_FALSE(is_unsigned(pod_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(pod_info));
    EXPECT_FALSE(is_unbounded_array(pod_info));
#endif
    EXPECT_TRUE(is_default_constructible(pod_info));
    EXPECT_TRUE(is_trivially_default_constructible(pod_info));
    EXPECT_TRUE(is_nothrow_default_constructible(pod_info));
    EXPECT_TRUE(is_copy_constructible(pod_info));
    EXPECT_TRUE(is_trivially_copy_constructible(pod_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(pod_info));
    EXPECT_TRUE(is_move_constructible(pod_info));
    EXPECT_TRUE(is_trivially_move_constructible(pod_info));
    EXPECT_TRUE(is_nothrow_move_constructible(pod_info));
    EXPECT_TRUE(is_copy_assignable(pod_info));
    EXPECT_TRUE(is_trivially_copy_assignable(pod_info));
    EXPECT_TRUE(is_move_assignable(pod_info));
    EXPECT_TRUE(is_trivially_move_assignable(pod_info));
    EXPECT_TRUE(is_nothrow_move_assignable(pod_info));
    EXPECT_TRUE(is_destructible(pod_info));
    EXPECT_TRUE(is_trivially_destructible(pod_info));
    EXPECT_TRUE(is_nothrow_destructible(pod_info));
    EXPECT_FALSE(has_virtual_destructor(pod_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(pod_info));
    EXPECT_TRUE(is_nothrow_swappable(pod_info));
#endif
  }

  // abstract
  {
    EXPECT_FALSE(is_void(abstract_info));
    EXPECT_FALSE(is_null_pointer(abstract_info));
    EXPECT_FALSE(is_integral(abstract_info));
    EXPECT_FALSE(is_floating_point(abstract_info));
    EXPECT_FALSE(is_array(abstract_info));
    EXPECT_FALSE(is_enum(abstract_info));
    EXPECT_FALSE(is_union(abstract_info));
    EXPECT_TRUE(is_class(abstract_info));
    EXPECT_FALSE(is_function(abstract_info));
    EXPECT_FALSE(is_pointer(abstract_info));
    EXPECT_FALSE(is_lvalue_reference(abstract_info));
    EXPECT_FALSE(is_rvalue_reference(abstract_info));
    EXPECT_FALSE(is_member_function_pointer(abstract_info));
    EXPECT_FALSE(is_fundamental(abstract_info));
    EXPECT_FALSE(is_arithmetic(abstract_info));
    EXPECT_FALSE(is_scalar(abstract_info));
    EXPECT_TRUE(is_object(abstract_info));
    EXPECT_TRUE(is_compound(abstract_info));
    EXPECT_FALSE(is_reference(abstract_info));
    EXPECT_FALSE(is_member_pointer(abstract_info));
    EXPECT_FALSE(is_const(abstract_info));
    EXPECT_FALSE(is_volatile(abstract_info));
    EXPECT_FALSE(is_trivial(abstract_info));
    EXPECT_FALSE(is_trivially_copyable(abstract_info));
    EXPECT_FALSE(is_standard_layout(abstract_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(abstract_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_FALSE(is_literal_type(abstract_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(abstract_info));
#endif
    EXPECT_FALSE(is_empty(abstract_info));
    EXPECT_TRUE(is_polymorphic(abstract_info));
    EXPECT_TRUE(is_abstract(abstract_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(abstract_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(abstract_info));
#endif
    EXPECT_FALSE(is_signed(abstract_info));
    EXPECT_FALSE(is_unsigned(abstract_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(abstract_info));
    EXPECT_FALSE(is_unbounded_array(abstract_info));
#endif
    EXPECT_FALSE(is_default_constructible(abstract_info));
    EXPECT_FALSE(is_trivially_default_constructible(abstract_info));
    EXPECT_FALSE(is_nothrow_default_constructible(abstract_info));
    EXPECT_FALSE(is_copy_constructible(abstract_info));
    EXPECT_FALSE(is_trivially_copy_constructible(abstract_info));
    EXPECT_FALSE(is_nothrow_copy_constructible(abstract_info));
    EXPECT_FALSE(is_move_constructible(abstract_info));
    EXPECT_FALSE(is_trivially_move_constructible(abstract_info));
    EXPECT_FALSE(is_nothrow_move_constructible(abstract_info));
    EXPECT_TRUE(is_copy_assignable(abstract_info));
    EXPECT_FALSE(is_trivially_copy_assignable(abstract_info));
    EXPECT_TRUE(is_move_assignable(abstract_info));
    EXPECT_FALSE(is_trivially_move_assignable(abstract_info));
    EXPECT_TRUE(is_nothrow_move_assignable(abstract_info));
    EXPECT_TRUE(is_destructible(abstract_info));
    EXPECT_FALSE(is_trivially_destructible(abstract_info));
    EXPECT_TRUE(is_nothrow_destructible(abstract_info));
    EXPECT_TRUE(has_virtual_destructor(abstract_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_swappable(abstract_info));
    EXPECT_FALSE(is_nothrow_swappable(abstract_info));
#endif
  }

  // final
  {
    EXPECT_FALSE(is_void(final_info));
    EXPECT_FALSE(is_null_pointer(final_info));
    EXPECT_FALSE(is_integral(final_info));
    EXPECT_FALSE(is_floating_point(final_info));
    EXPECT_FALSE(is_array(final_info));
    EXPECT_FALSE(is_enum(final_info));
    EXPECT_FALSE(is_union(final_info));
    EXPECT_TRUE(is_class(final_info));
    EXPECT_FALSE(is_function(final_info));
    EXPECT_FALSE(is_pointer(final_info));
    EXPECT_FALSE(is_lvalue_reference(final_info));
    EXPECT_FALSE(is_rvalue_reference(final_info));
    EXPECT_FALSE(is_member_function_pointer(final_info));
    EXPECT_FALSE(is_fundamental(final_info));
    EXPECT_FALSE(is_arithmetic(final_info));
    EXPECT_FALSE(is_scalar(final_info));
    EXPECT_TRUE(is_object(final_info));
    EXPECT_TRUE(is_compound(final_info));
    EXPECT_FALSE(is_reference(final_info));
    EXPECT_FALSE(is_member_pointer(final_info));
    EXPECT_FALSE(is_const(final_info));
    EXPECT_FALSE(is_volatile(final_info));
    EXPECT_TRUE(is_trivial(final_info));
    EXPECT_TRUE(is_trivially_copyable(final_info));
    EXPECT_TRUE(is_standard_layout(final_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_TRUE(is_pod(final_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_TRUE(is_literal_type(final_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(final_info));
#endif
    EXPECT_TRUE(is_empty(final_info));
    EXPECT_FALSE(is_polymorphic(final_info));
    EXPECT_FALSE(is_abstract(final_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_TRUE(is_final(final_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_aggregate(final_info));
#endif
    EXPECT_FALSE(is_signed(final_info));
    EXPECT_FALSE(is_unsigned(final_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(final_info));
    EXPECT_FALSE(is_unbounded_array(final_info));
#endif
    EXPECT_TRUE(is_default_constructible(final_info));
    EXPECT_TRUE(is_trivially_default_constructible(final_info));
    EXPECT_TRUE(is_nothrow_default_constructible(final_info));
    EXPECT_TRUE(is_copy_constructible(final_info));
    EXPECT_TRUE(is_trivially_copy_constructible(final_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(final_info));
    EXPECT_TRUE(is_move_constructible(final_info));
    EXPECT_TRUE(is_trivially_move_constructible(final_info));
    EXPECT_TRUE(is_nothrow_move_constructible(final_info));
    EXPECT_TRUE(is_copy_assignable(final_info));
    EXPECT_TRUE(is_trivially_copy_assignable(final_info));
    EXPECT_TRUE(is_move_assignable(final_info));
    EXPECT_TRUE(is_trivially_move_assignable(final_info));
    EXPECT_TRUE(is_nothrow_move_assignable(final_info));
    EXPECT_TRUE(is_destructible(final_info));
    EXPECT_TRUE(is_trivially_destructible(final_info));
    EXPECT_TRUE(is_nothrow_destructible(final_info));
    EXPECT_FALSE(has_virtual_destructor(final_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(final_info));
    EXPECT_TRUE(is_nothrow_swappable(final_info));
#endif
  }

  // base1
  {
    EXPECT_FALSE(is_void(dbase1_info));
    EXPECT_FALSE(is_null_pointer(dbase1_info));
    EXPECT_FALSE(is_integral(dbase1_info));
    EXPECT_FALSE(is_floating_point(dbase1_info));
    EXPECT_FALSE(is_array(dbase1_info));
    EXPECT_FALSE(is_enum(dbase1_info));
    EXPECT_FALSE(is_union(dbase1_info));
    EXPECT_TRUE(is_class(dbase1_info));
    EXPECT_FALSE(is_function(dbase1_info));
    EXPECT_FALSE(is_pointer(dbase1_info));
    EXPECT_FALSE(is_lvalue_reference(dbase1_info));
    EXPECT_FALSE(is_rvalue_reference(dbase1_info));
    EXPECT_FALSE(is_member_function_pointer(dbase1_info));
    EXPECT_FALSE(is_fundamental(dbase1_info));
    EXPECT_FALSE(is_arithmetic(dbase1_info));
    EXPECT_FALSE(is_scalar(dbase1_info));
    EXPECT_TRUE(is_object(dbase1_info));
    EXPECT_TRUE(is_compound(dbase1_info));
    EXPECT_FALSE(is_reference(dbase1_info));
    EXPECT_FALSE(is_member_pointer(dbase1_info));
    EXPECT_FALSE(is_const(dbase1_info));
    EXPECT_FALSE(is_volatile(dbase1_info));
    EXPECT_FALSE(is_trivial(dbase1_info));
    EXPECT_FALSE(is_trivially_copyable(dbase1_info));
    EXPECT_FALSE(is_standard_layout(dbase1_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(dbase1_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_FALSE(is_literal_type(dbase1_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(dbase1_info));
#endif
    EXPECT_FALSE(is_empty(dbase1_info));
    EXPECT_TRUE(is_polymorphic(dbase1_info));
    EXPECT_FALSE(is_abstract(dbase1_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(dbase1_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(dbase1_info));
#endif
    EXPECT_FALSE(is_signed(dbase1_info));
    EXPECT_FALSE(is_unsigned(dbase1_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(dbase1_info));
    EXPECT_FALSE(is_unbounded_array(dbase1_info));
#endif
    EXPECT_TRUE(is_default_constructible(dbase1_info));
    EXPECT_FALSE(is_trivially_default_constructible(dbase1_info));
    EXPECT_TRUE(is_nothrow_default_constructible(dbase1_info));
    EXPECT_TRUE(is_copy_constructible(dbase1_info));
    EXPECT_FALSE(is_trivially_copy_constructible(dbase1_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(dbase1_info));
    EXPECT_TRUE(is_move_constructible(dbase1_info));
    EXPECT_FALSE(is_trivially_move_constructible(dbase1_info));
    EXPECT_TRUE(is_nothrow_move_constructible(dbase1_info));
    EXPECT_TRUE(is_copy_assignable(dbase1_info));
    EXPECT_FALSE(is_trivially_copy_assignable(dbase1_info));
    EXPECT_TRUE(is_move_assignable(dbase1_info));
    EXPECT_FALSE(is_trivially_move_assignable(dbase1_info));
    EXPECT_TRUE(is_nothrow_move_assignable(dbase1_info));
    EXPECT_TRUE(is_destructible(dbase1_info));
    EXPECT_FALSE(is_trivially_destructible(dbase1_info));
    EXPECT_TRUE(is_nothrow_destructible(dbase1_info));
    EXPECT_TRUE(has_virtual_destructor(dbase1_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(dbase1_info));
    EXPECT_TRUE(is_nothrow_swappable(dbase1_info));
#endif
  }

  // dderived
  {
    EXPECT_FALSE(is_void(dderived_info));
    EXPECT_FALSE(is_null_pointer(dderived_info));
    EXPECT_FALSE(is_integral(dderived_info));
    EXPECT_FALSE(is_floating_point(dderived_info));
    EXPECT_FALSE(is_array(dderived_info));
    EXPECT_FALSE(is_enum(dderived_info));
    EXPECT_FALSE(is_union(dderived_info));
    EXPECT_TRUE(is_class(dderived_info));
    EXPECT_FALSE(is_function(dderived_info));
    EXPECT_FALSE(is_pointer(dderived_info));
    EXPECT_FALSE(is_lvalue_reference(dderived_info));
    EXPECT_FALSE(is_rvalue_reference(dderived_info));
    EXPECT_FALSE(is_member_function_pointer(dderived_info));
    EXPECT_FALSE(is_fundamental(dderived_info));
    EXPECT_FALSE(is_arithmetic(dderived_info));
    EXPECT_FALSE(is_scalar(dderived_info));
    EXPECT_TRUE(is_object(dderived_info));
    EXPECT_TRUE(is_compound(dderived_info));
    EXPECT_FALSE(is_reference(dderived_info));
    EXPECT_FALSE(is_member_pointer(dderived_info));
    EXPECT_FALSE(is_const(dderived_info));
    EXPECT_FALSE(is_volatile(dderived_info));
    EXPECT_FALSE(is_trivial(dderived_info));
    EXPECT_FALSE(is_trivially_copyable(dderived_info));
    EXPECT_FALSE(is_standard_layout(dderived_info));
#if __cplusplus < CPP20_STANDARD
    EXPECT_FALSE(is_pod(dderived_info));
#endif
#if __cplusplus < CPP17_STANDARD
    EXPECT_FALSE(is_literal_type(dderived_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(has_unique_object_representations(dderived_info));
#endif
    EXPECT_FALSE(is_empty(dderived_info));
    EXPECT_TRUE(is_polymorphic(dderived_info));
    EXPECT_FALSE(is_abstract(dderived_info));
#if __cplusplus >= CPP14_STANDARD
    EXPECT_FALSE(is_final(dderived_info));
#endif
#if __cplusplus >= CPP17_STANDARD
    EXPECT_FALSE(is_aggregate(dderived_info));
#endif
    EXPECT_FALSE(is_signed(dderived_info));
    EXPECT_FALSE(is_unsigned(dderived_info));
#if __cplusplus >= CPP20_STANDARD
    EXPECT_FALSE(is_bounded_array(dderived_info));
    EXPECT_FALSE(is_unbounded_array(dderived_info));
#endif
    EXPECT_TRUE(is_default_constructible(dderived_info));
    EXPECT_FALSE(is_trivially_default_constructible(dderived_info));
    EXPECT_TRUE(is_nothrow_default_constructible(dderived_info));
    EXPECT_TRUE(is_copy_constructible(dderived_info));
    EXPECT_FALSE(is_trivially_copy_constructible(dderived_info));
    EXPECT_TRUE(is_nothrow_copy_constructible(dderived_info));
    EXPECT_TRUE(is_move_constructible(dderived_info));
    EXPECT_FALSE(is_trivially_move_constructible(dderived_info));
    EXPECT_TRUE(is_nothrow_move_constructible(dderived_info));
    EXPECT_TRUE(is_copy_assignable(dderived_info));
    EXPECT_FALSE(is_trivially_copy_assignable(dderived_info));
    EXPECT_TRUE(is_move_assignable(dderived_info));
    EXPECT_FALSE(is_trivially_move_assignable(dderived_info));
    EXPECT_TRUE(is_nothrow_move_assignable(dderived_info));
    EXPECT_TRUE(is_destructible(dderived_info));
    EXPECT_FALSE(is_trivially_destructible(dderived_info));
    EXPECT_TRUE(is_nothrow_destructible(dderived_info));
    EXPECT_TRUE(has_virtual_destructor(dderived_info));
#if __cplusplus >= CPP17_STANDARD
    EXPECT_TRUE(is_swappable(dderived_info));
    EXPECT_TRUE(is_nothrow_swappable(dderived_info));
#endif
  }
}

TEST(TypeInfo, IsTypeOf) {
  EXPECT_TRUE(is_type_of<int>(signed_int_info));
  EXPECT_FALSE(is_type_of<float>(double_info));

  constexpr bool eq1 = is_type_of<signed int>(signed_int_info);
  constexpr bool eq2 = is_type_of<signed int>(unsigned_int_info);
  EXPECT_TRUE(eq1);
  EXPECT_FALSE(eq2);

  type_base * null = nullptr;
  type_base const * si = &signed_int_info;
  type_base const * di = &double_info;

  EXPECT_TRUE(is_type_of<int>(si));
  EXPECT_FALSE(is_type_of<int>(null));
  EXPECT_FALSE(is_type_of<double>(null));
  EXPECT_TRUE(is_type_of<double>(di));
  EXPECT_FALSE(is_type_of<float>(di));

  constexpr type_base * cnull = nullptr;
  constexpr type_base const * csi = &signed_int_info;
  constexpr type_base const * cdi = &double_info;

  constexpr bool eq3 = is_type_of<int>(csi);
  constexpr bool eq4 = is_type_of<int>(cnull);
  constexpr bool eq5 = is_type_of<double>(cnull);
  constexpr bool eq6 = is_type_of<double>(cdi);
  constexpr bool eq7 = is_type_of<float>(cdi);

  EXPECT_TRUE(eq3);
  EXPECT_FALSE(eq4);
  EXPECT_FALSE(eq5);
  EXPECT_TRUE(eq6);
  EXPECT_FALSE(eq7);
}
