/**
 * @file test_messaging.cpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <gtest/gtest.h>
#include <messaging/process_manager.hpp>
#include <util/attributes.hpp>
#include <util/logger.hpp>
#include <util/traits.hpp>

using namespace util::logger;

struct some_message {
  int a = 1;
  some_message() { debug << "some_message::default constructor" << std::endl; }
  some_message(int a_) : a(a_) { debug << "some_message::init_constructor" << std::endl; }
  some_message(const some_message & o) {
    a = o.a;
    debug << "some_message::copy constructor const" << std::endl;
  }
  some_message(some_message && o) noexcept {
    a = o.a;
    o.a = 0;
    debug << "some_message::move constructor" << std::endl;
  }
  some_message & operator=(const some_message & o) {
    a = o.a;
    debug << "some_message::copy operator=" << std::endl;
    return *this;
  }
  some_message & operator=(some_message && o) {
    a = o.a;
    o.a = 0;
    debug << "some_message::move operator=" << std::endl;
    return *this;
  }
  virtual ~some_message() noexcept { debug << "some_message::destructor with a = " << a << std::endl; };
  virtual void print() { debug << "some_message::print a = " << a << std::endl; }
  virtual void print() const { debug << "some_message::print const a = " << a << std::endl; }
};

struct some_other_message : some_message {
  some_other_message() { debug << "some_other_message::default_constructor" << std::endl; }
  some_other_message(int a) : some_message(a) { debug << "some_other_message::init_constructor" << std::endl; }
  some_other_message(const some_other_message & o) {
    a = o.a;
    debug << "some_other_message::copy constructor const" << std::endl;
  }
  some_other_message(some_other_message && o) noexcept {
    a = o.a;
    o.a = 0;
    debug << "some_other_message::move constructor" << std::endl;
  }
  some_other_message & operator=(const some_other_message & o) {
    a = o.a;
    debug << "some_other_message::copy operator=" << std::endl;
    return *this;
  }
  some_other_message & operator=(some_other_message && o) {
    a = o.a;
    o.a = 0;
    debug << "some_other_message::move operator=" << std::endl;
    return *this;
  }
  ~some_other_message() noexcept override { debug << "some_other_message::destructor with a = " << a << std::endl; }
  void print() override { debug << "some_other_message::print a = " << a << std::endl; }
  void print() const override { debug << "some_other_message::print const a = " << a << std::endl; }
};

struct state_t {};
using my_function_t = void (*)(state_t &);
void my_state_handler(state_t &) {
  debug << "Handling the state" << std::endl;
}

struct non_copy_construct_message {
  non_copy_construct_message() {}

  non_copy_construct_message(non_copy_construct_message &&) {}
  non_copy_construct_message & operator=(non_copy_construct_message &&) { return *this; }

  non_copy_construct_message(non_copy_construct_message const &) = delete;
  non_copy_construct_message & operator=(non_copy_construct_message const &) { return *this; }
};

struct non_copy_assign_message {
  non_copy_assign_message() {}

  non_copy_assign_message(non_copy_assign_message &&) {}
  non_copy_assign_message & operator=(non_copy_assign_message &&) { return *this; }

  non_copy_assign_message(non_copy_assign_message const &) {}
  non_copy_assign_message & operator=(non_copy_assign_message const &) = delete;
};

struct non_move_construct_message {
  non_move_construct_message() {}

  non_move_construct_message(non_move_construct_message &&) = delete;
  non_move_construct_message & operator=(non_move_construct_message &&) { return *this; }

  non_move_construct_message(non_move_construct_message const &) {}
  non_move_construct_message & operator=(non_move_construct_message const &) { return *this; }
};

struct non_move_assign_message {
  non_move_assign_message() {}

  non_move_assign_message(non_move_assign_message &&) {}
  non_move_assign_message & operator=(non_move_assign_message &&) = delete;

  non_move_assign_message(non_move_assign_message const &) {}
  non_move_assign_message & operator=(non_move_assign_message const &) { return *this; }
};

struct non_copy_message {
  non_copy_message() {}

  non_copy_message(non_copy_message &&) {}
  non_copy_message & operator=(non_copy_message &&) { return *this; }

  non_copy_message(non_copy_message const &) = delete;
  non_copy_message & operator=(non_copy_message const &) = delete;
};

struct non_move_message {
  non_move_message() {}

  non_move_message(non_move_message &&) = delete;
  non_move_message & operator=(non_move_message &&) = delete;

  non_move_message(non_move_message const &) {}
  non_move_message & operator=(non_move_message const &) { return *this; }
};

enum class wind_direction { south, north, west, east };

std::ostream & operator<<(std::ostream & out, wind_direction w) {
  switch (w) {
  case wind_direction::south: out << "south"; break;
  case wind_direction::north: out << "north"; break;
  case wind_direction::west: out << "west"; break;
  case wind_direction::east: out << "east"; break;
  }
  return out;
}

enum class humidity { high, normal, low };

std::ostream & operator<<(std::ostream & out, humidity h) {
  switch (h) {
  case humidity::high: out << "high"; break;
  case humidity::normal: out << "normal"; break;
  case humidity::low: out << "low"; break;
  }
  return out;
}

struct lvalue_reference_test {
} lvalue;

std::ostream & operator<<(std::ostream & out, lvalue_reference_test const & o) {
  return out << (void *)(&o);
}

template <typename Process>
class some_process : public Process {
  using dispatcher_type = typename Process::dispatcher_type;

  state_t some_state;

  void dispatch(dispatcher_type & dispatcher) override {
    // clang-format off
    dispatcher
    //* Classes & polymorphism
    .template handle<some_message>([&](some_message & msg) {
      debug << "Class:: handle some_message: ";
      msg.print();
    })
    .template handle<const some_message>([&](some_message const& msg) {
      debug << "Class:: Handle const some_message: ";
      msg.print();
    })
    .template handle<some_other_message>([&](some_other_message & msg) {
      debug << "Class:: Handle some_other_message: ";
      msg.print();
    })
    .template handle<const some_other_message>([&](some_other_message const& msg) {
      debug << "Class:: Handle const some_other_message: ";
      msg.print();
    })
    //* Basic types
    .template handle<int>([&](int value) {
      debug << "Basic:: Received int = " << value << std::endl;
    })
    .template handle<std::nullptr_t>([&](std::nullptr_t) {
      debug << "Basic:: Received nullptr" << std::endl;
    })
    .template handle<my_function_t>([&](my_function_t f) {
      debug << "Basic:: Received a function, going to call it with some state object." << std::endl;
      if (f) f(some_state);
    })
    .template handle<wind_direction>([&](wind_direction w) {
      debug << "Basic:: Wind direction " << w << std::endl;
    })
    .template handle<humidity>([&](humidity h) {
      debug << "Basic:: humidity " << h << std::endl;
    })
    // .template handle<lvalue_reference_test&>([&](lvalue_reference_test &l) {
    //     debug << "Basic:: reference " << l << std::endl;
    // })
    .template handle<std::unique_ptr<int>>([&](std::unique_ptr<int> &p) {
      debug << "Basic:: unique_ptr<int> " << (bool)p << ' ' << *p << std::endl;
    })
    //* Cripled classes
    .template handle<non_copy_construct_message>([&](non_copy_construct_message &) {
      debug << "Cripled:: non_copy_construct_message" << std::endl;
    })
    .template handle<non_copy_assign_message>([&](non_copy_assign_message &) {
      debug << "Cripled:: non_copy_assign_message" << std::endl;
    })
    .template handle<non_copy_message>([&](non_copy_message &) {
      debug << "Cripled:: non_copy_message" << std::endl;
    })
    .template handle<non_move_construct_message>([&](non_move_construct_message &) {
      debug << "Cripled:: non_move_construct_message" << std::endl;
    })
    .template handle<non_move_assign_message>([&](non_move_assign_message &) {
      debug << "Cripled:: non_move_assign_message" << std::endl;
    })
    .template handle<non_move_message>([&](non_move_message &) {
      debug << "Cripled:: non_move_message" << std::endl;
    })
    .template handle<const non_copy_construct_message>([&](non_copy_construct_message const&) {
      debug << "Cripled:: const non_copy_construct_message" << std::endl;
    })
    .template handle<const non_copy_assign_message>([&](non_copy_assign_message const&) {
      debug << "Cripled:: const non_copy_assign_message" << std::endl;
    })
    .template handle<const non_copy_message>([&](non_copy_message const&) {
      debug << "Cripled:: const non_copy_message" << std::endl;
    })
    .template handle<const non_move_construct_message>([&](non_move_construct_message const&) {
      debug << "Cripled:: const non_move_construct_message" << std::endl;
    })
    .template handle<const non_move_assign_message>([&](non_move_assign_message const&) {
      debug << "Cripled:: const non_move_assign_message" << std::endl;
    })
    .template handle<const non_move_message>([&](non_move_message const&) {
      debug << "Cripled:: const non_move_message" << std::endl;
    })
    ;
  }
  // clang-format on
};

//! @note A factory is a good way to avoid lock-in into a certain 'type' of 'process'
namespace factory {

template <typename Types, typename T = some_process<typename Types::process_type>, typename... Args>
auto create_some_process(Args &&... args) {
  return std::make_shared<T>(std::forward<Args>(args)...);
}

}; // namespace factory

TEST(Messaging, CheckIfTypesCanBeHandled) {
#ifdef WITH_BOOST_COROUTINES
  using coroutine_types = messaging::coroutine::boost_coroutine2_types;
  using selected_types = coroutine_types;
#else
  using multithread_types = messaging::multithread::std_thread_types;
  using selected_types = multithread_types;
#endif

  //! @note You can use one or multiple task types for the process_manager
  //!     messaging::process_manager<coroutine_types, multithread_types> manager;
  //! or
  //!     messaging::process_manager<coroutine_types> manager;
  //! or
  //!     messaging::process_manager<multithread_types> manager;

  messaging::process_manager<selected_types> manager;
  manager.add<selected_types>("proc", factory::create_some_process<selected_types>());
  manager.add<selected_types>("func", [&](MAYBE_UNUSED messaging::stop_token token, MAYBE_UNUSED selected_types::yield_type & yield) {
    auto proc = manager.get_sender("proc");

    //! @note 'volatile' types are not supported by the message system

    //! @note For lvalues the copy constructor of the type will be called
    //! @note For rvalues the move constructor of the type will be called

    //! @note The message type will be deduced by 'send', however:
    //!       - if the provided message object is a const-rvalue the corresponding handler must accept 'const of Message type'
    //!         or you have to specify the non-const message type as template parameter to send
    //!       - if the provided message object is an lvalue or const-lvalue the non-const handler will be used

    //! @note You are free to use const or not in the receiving function argument (but const is needed for const-rvalues)

    //! @note It is adviced to use reference in the receiving function argument to avoid unwanted copying

    //! @note The dispatcher searches for exact matches, so sending a derivate type will by default not be caught by
    //!       a base-class handler. Do have the base class handler also handle derived types you need to provide the
    //!       base type as a template argument to 'send'.

    //! @note Providing 'yield' handlers to 'send' may improve responsiveness for coroutines, but it is not a requirement.
    //!       If you depend on 'ordered' text output you SHOULD provide the 'yield' and don't mix multi-threaded with coroutines.

    // clang-format off
#if 1
     // non-const l-values
     { some_message msg(2); proc.send( msg, yield ) ; msg.print(); }
#endif

#if 1
    // non-const r-values
    { auto msg = some_message(3); proc.send( std::move(msg), yield ); }
    { proc.send( some_message(9), yield ); }
    { proc.send<some_message>( some_message(10), yield ); }
    { proc.send<some_message>( some_other_message(18), yield ); }
    { proc.send<some_other_message>( some_other_message(19), yield ); }

#endif

#if 1
    // cv l-values
    { auto const msg = some_message(4); proc.send( msg, yield ); }
    { auto const msg = some_other_message(5); proc.send( msg, yield ); }
    { auto const msg = some_other_message(5); proc.send<const some_message>( msg, yield ); }
//  { auto volatile msg = some_message(5); proc.send( msg, yield ); }
#endif

#if 1
    // cv r-values
    { proc.send<const some_message>(std::add_const<some_message>::type(30), yield); }
    // { proc.send<volatile some_message>( std::add_volatile<some_message>::type(31), yield ); }
    { proc.send(std::add_const<some_message>::type(20), yield); }
    { proc.send(std::add_const<some_other_message>::type(21), yield); }
    { proc.send<const some_message>(std::add_const<some_other_message>::type(21), yield); }
//      { proc.send( std::add_volatile<some_message>::type(), yield ); }
#endif

#if 1
    proc.send(512, yield);
    proc.send(nullptr, yield);
    proc.send<my_function_t>(&my_state_handler, yield);
    proc.send(humidity::high, yield);
    proc.send(wind_direction::south, yield);
    // proc.send<lvalue_reference_test&>( lvalue );
    proc.send(std::make_unique<int>(18));
#endif

#if 1
    { proc.send(non_copy_construct_message(), yield); }
    { proc.send(non_copy_assign_message(), yield); }
    { proc.send(non_move_construct_message(), yield); }
    { proc.send(non_move_assign_message(), yield); }
    { proc.send(non_move_message(), yield); }
    { proc.send(non_copy_message(), yield); }
#endif

#if 1
    // { proc.send( std::add_const<non_copy_construct_message>::type(), yield ); }
    { proc.send(std::add_const<non_copy_assign_message>::type(), yield); }
    { proc.send(std::add_const<non_move_construct_message>::type(), yield); }
    { proc.send(std::add_const<non_move_assign_message>::type(), yield); }
    { proc.send(std::add_const<non_move_message>::type(), yield); }
//      { proc.send( std::add_const<non_copy_message>::type(), yield ); }
#endif

#if 1
    { non_copy_construct_message msg; proc.send( msg, yield ); }
    { non_copy_assign_message msg; proc.send( msg, yield ); }
    { non_move_construct_message msg; proc.send( msg, yield ); }
    { non_move_assign_message msg; proc.send( msg, yield ); }
    { non_move_message msg; proc.send( msg, yield ); }
//      { non_copy_message msg; proc.send( msg, yield ); }
#endif

#if 1
//   { const non_copy_construct_message msg; proc.send( msg, yield ); }
     { const non_copy_assign_message msg; proc.send( msg, yield ); }
     { const non_move_construct_message msg; proc.send( msg, yield ); }
     { const non_move_assign_message msg; proc.send( msg, yield ); }
     { const non_move_message msg; proc.send( msg, yield ); }
//   { const non_copy_message msg; proc.send( msg, yield ); }
#endif
    // clang-format on

    manager.done();
  });

  //* Push coroutines forward and wait until all processes are finished
  using namespace std::chrono_literals;
  manager.run_every(100ms);
}
