/**
 * @file test_pmte.cpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <sstream>

#include <util/attributes.hpp>

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
#include <util/allocator.hpp>
#include <memory_resource>
#endif

#include <gtest/gtest.h>
#include <util/pmte.hpp>

using namespace util;
using namespace util::pmte;

enum enum1 { enum1_value };
struct class1 {
  explicit class1() : a(0) {}
  explicit class1(int a_) : a(a_) {}
  int a;
};

struct class2 : class1 {
  explicit class2() : class1(), f(0.0f) {}
  explicit class2(int a_, float f_) : class1(a_), f(f_) {}
  float f;
};

struct class3 : class2 {
  explicit class3() : class2(), d(0.0) {}
  explicit class3(int a_, float f_, double d_) : class2(a_, f_), d(d_) {}
  double d;
};

struct class4 {
  std::vector<int> v;
};

union uni {
  int a;
  double d;
};

TEST(PMTE, CreateTypeList) {
  type_list<> l1;
  EXPECT_EQ(std::tuple_size<decltype(l1)>::value, 0);

  type_list<int> l2;
  EXPECT_EQ(std::tuple_size<decltype(l2)>::value, 1);

  type_list<float> l3;
  EXPECT_EQ(std::tuple_size<decltype(l3)>::value, 1);

  type_list<int, float> l4;
  EXPECT_EQ(std::tuple_size<decltype(l4)>::value, 2);

  type_list<int, float, class1, class2, class3> l5;
  EXPECT_EQ(std::tuple_size<decltype(l5)>::value, 5);
}

template <typename T, typename ReverseT, typename NotT, typename O>
void test_pmte_value(O && o) {
  EXPECT_EQ(o.get(), 0);
  EXPECT_TRUE(is_type_of<T>(o.type()));
  EXPECT_FALSE(is_type_of<ReverseT>(o.type()));
  EXPECT_EQ(o.index(type_info<T> {}), 0);
  EXPECT_EQ(o.index(type_info<NotT> {}), -1);
  EXPECT_TRUE(o.is_castable_to(type_info<T> {}));
  EXPECT_FALSE(o.is_castable_to(type_info<NotT> {}));
  EXPECT_GE(o.size(), 8);
  ASSERT_NE(o.template get_if<T>(), nullptr);
  EXPECT_EQ(o.template get_if<NotT>(), nullptr);
  EXPECT_EQ(*o.template get_if<T>(), 0);
  EXPECT_FALSE(o.has_deleter);
  std::ostringstream ss;
  o.print(ss);
  EXPECT_EQ(ss.str(), "0");
  EXPECT_EQ(o.type().traits.size, sizeof(T));
  auto c = o.clone();
  if (std::is_copy_constructible<T>::value) EXPECT_EQ(*c->template get_if<T>(), o.get());
  else
    EXPECT_EQ(c, nullptr);
  delete c;
}

template <typename T, typename ReverseT, typename NotT>
constexpr void ctest_default() {
  CPP20_CONSTEXPR auto o = build_pmte<T>();
  CPP20_CONSTEXPR auto eq1 = o.get();
  EXPECT_EQ(eq1, 0);
  CPP20_CONSTEXPR auto eq2 = is_type_of<T>(o.type());
  EXPECT_TRUE(eq2);
  CPP20_CONSTEXPR auto eq3 = is_type_of<ReverseT>(o.type());
  EXPECT_FALSE(eq3);
  CPP20_CONSTEXPR auto eq4 = o.index(type_info<T> {});
  EXPECT_EQ(eq4, 0);
  CPP20_CONSTEXPR auto eq5 = o.index(type_info<NotT> {});
  EXPECT_EQ(eq5, -1);
  CPP20_CONSTEXPR auto eq6 = o.is_castable_to(type_info<T> {});
  EXPECT_TRUE(eq6);
  CPP20_CONSTEXPR auto eq7 = o.is_castable_to(type_info<NotT> {});
  EXPECT_FALSE(eq7);
  CPP20_CONSTEXPR auto eq8 = o.size();
  EXPECT_GE(eq8, 8);
}

template <typename T, typename ReverseT, typename NotT, typename O>
void test_pmte_value_pointer(O && o) {
  EXPECT_EQ(o.get(), nullptr);
  EXPECT_TRUE(is_type_of<T>(o.type()));
  EXPECT_FALSE(is_type_of<ReverseT>(o.type()));
  EXPECT_EQ(o.index(type_info<T> {}), 0);
  EXPECT_EQ(o.index(type_info<NotT> {}), -1);
  EXPECT_TRUE(o.is_castable_to(type_info<T> {}));
  EXPECT_FALSE(o.is_castable_to(type_info<NotT> {}));
  EXPECT_GE(o.size(), 8);
  EXPECT_EQ(o.template get_if<T>(), nullptr);
  EXPECT_EQ(o.template get_if<NotT>(), nullptr);
  EXPECT_FALSE(o.has_deleter);
  std::ostringstream ss;
  o.print(ss);
  EXPECT_EQ(ss.str(), "0");
  EXPECT_EQ(o.type().traits.size, sizeof(T));
  auto c = o.clone();
  delete c;
}

TEST(PMTE, BuildValueStoreDefault) {
  test_pmte_value<int, const int, float>(build_pmte<int>());
  test_pmte_value<unsigned long, const unsigned long, float>(build_pmte<unsigned long>());
  test_pmte_value<float, const float, int>(build_pmte<float>());
  test_pmte_value<double, const double, int>(build_pmte<double>());
  test_pmte_value<enum1, const enum1, float>(build_pmte<enum1>());

  {
    using T = class1;
    using ReverseT = const class1;
    using NotT = int;
    auto o = build_pmte<T>();
    EXPECT_EQ(o.get().a, 0);
    EXPECT_TRUE(is_type_of<T>(o.type()));
    EXPECT_FALSE(is_type_of<ReverseT>(o.type()));
    EXPECT_EQ(o.index(type_info<T> {}), 0);
    EXPECT_EQ(o.index(type_info<NotT> {}), -1);
    EXPECT_TRUE(o.is_castable_to(type_info<T> {}));
    EXPECT_FALSE(o.is_castable_to(type_info<NotT> {}));
    EXPECT_GE(o.size(), 8);
    ASSERT_NE(o.template get_if<T>(), nullptr);
    EXPECT_EQ(o.template get_if<NotT>(), nullptr);
    EXPECT_EQ(o.template get_if<T>()->a, 0);
    EXPECT_FALSE(o.has_deleter);
    EXPECT_TRUE(o.is_move_constructible);
    EXPECT_TRUE(o.is_copy_constructible);
    EXPECT_TRUE(o.is_move_assignable);
    EXPECT_TRUE(o.is_copy_assignable);
    std::ostringstream ss;
    o.print(ss);
    EXPECT_EQ(ss.str(), "<unprintable>");
    EXPECT_EQ(o.type().traits.size, sizeof(T));
    auto c = o.clone();
    EXPECT_EQ(c->template get_if<T>()->a, o.get().a);
    delete c;
  }

  {
    using T = std::unique_ptr<int>;
    using ReverseT = const std::unique_ptr<int>;
    using NotT = std::unique_ptr<float>;
    auto o = build_pmte<T>();
    EXPECT_TRUE(is_type_of<T>(o.type()));
    EXPECT_FALSE(is_type_of<ReverseT>(o.type()));
    EXPECT_EQ(o.index(type_info<T> {}), 0);
    EXPECT_EQ(o.index(type_info<NotT> {}), -1);
    EXPECT_TRUE(o.is_castable_to(type_info<T> {}));
    EXPECT_FALSE(o.is_castable_to(type_info<NotT> {}));
    EXPECT_GE(o.size(), 8);
    ASSERT_NE(o.template get_if<T>(), nullptr);
    EXPECT_EQ(o.template get_if<NotT>(), nullptr);
    EXPECT_FALSE(o.has_deleter);
    EXPECT_TRUE(o.is_move_constructible);
    EXPECT_FALSE(o.is_copy_constructible);
    EXPECT_TRUE(o.is_move_assignable);
    EXPECT_FALSE(o.is_copy_assignable);
    std::ostringstream ss;
    o.print(ss);
#if __cplusplus >= CPP20_STANDARD
    // C++20 supports sending std::unique_ptr to std::ostream while C++17 and below don't
    EXPECT_EQ(ss.str(), "0");
#else
    EXPECT_EQ(ss.str(), "<unprintable>");
#endif
    EXPECT_EQ(o.type().traits.size, sizeof(T));
    auto c = o.clone();
    EXPECT_EQ(c, nullptr);
    delete c;
  }

  {
    using T = uni;
    using ReverseT = const uni;
    using NotT = int;
    auto o = build_pmte<T>();
    EXPECT_EQ(o.get().a, 0);
    EXPECT_TRUE(is_type_of<T>(o.type()));
    EXPECT_FALSE(is_type_of<ReverseT>(o.type()));
    EXPECT_EQ(o.index(type_info<T> {}), 0);
    EXPECT_EQ(o.index(type_info<NotT> {}), -1);
    EXPECT_TRUE(o.is_castable_to(type_info<T> {}));
    EXPECT_FALSE(o.is_castable_to(type_info<NotT> {}));
    EXPECT_GE(o.size(), 8);
    ASSERT_NE(o.template get_if<T>(), nullptr);
    EXPECT_EQ(o.template get_if<NotT>(), nullptr);
    EXPECT_EQ(o.template get_if<T>()->a, 0);
    EXPECT_FALSE(o.has_deleter);
    EXPECT_TRUE(o.is_move_constructible);
    EXPECT_TRUE(o.is_copy_constructible);
    EXPECT_TRUE(o.is_move_assignable);
    EXPECT_TRUE(o.is_copy_assignable);
    std::ostringstream ss;
    o.print(ss);
    EXPECT_EQ(ss.str(), "<unprintable>");
    EXPECT_EQ(o.type().traits.size, sizeof(T));
    auto c = o.clone();
    EXPECT_EQ(c->template get_if<T>()->a, o.get().a);
    delete c;
  }

  test_pmte_value<const int, int, const float>(build_pmte<const int>());
  test_pmte_value<const unsigned long, unsigned long, float>(build_pmte<const unsigned long>());
  test_pmte_value<const float, float, int>(build_pmte<const float>());
  test_pmte_value<const double, double, int>(build_pmte<const double>());
  test_pmte_value<const enum1, enum1, float>(build_pmte<const enum1>());

  test_pmte_value_pointer<int *, const int *, float>(build_pmte<int *>());
  test_pmte_value_pointer<double *, const double *, float>(build_pmte<double *>());
  test_pmte_value_pointer<const int *, int *, float>(build_pmte<const int *>());
  test_pmte_value_pointer<const double *, double *, float>(build_pmte<const double *>());

  ctest_default<int, const int, float>();
  ctest_default<unsigned long, const unsigned long, float>();
  ctest_default<float, const float, int>();
  ctest_default<double, const double, int>();

  ctest_default<const int, int, float>();
  ctest_default<const unsigned int, unsigned int, float>();
  ctest_default<const float, float, int>();
  ctest_default<const double, double, int>();
}

TEST(PMTE, BuildValueStoreFromObject) {
  int i = 9;
  float f = 8.39f;
  double d = 17.8;
  uni u {.d = 8};
  class3 c(i, f, d);
  class4 c2;
  c2.v.push_back(5);
  c2.v.push_back(16);

  auto o0 = build_pmte(5);
  auto o1 = build_pmte(5.7f);
  auto o2 = build_pmte(0xFFAAUL);
  auto o3 = build_pmte<float>(5);     // casting
  auto o4 = build_pmte<double>(6.7f); // casting
  auto o5 = build_pmte<enum1>(enum1_value);
  auto o6 = build_pmte<class1>(class1 {4});
  auto o7 = build_pmte<class1>(class2 {8, 5.7f}); // reference
  auto o8 = build_pmte<uni>(uni {.a = 5});
  auto o9 = build_pmte(new class1);
  auto o10 = build_pmte<class1 *>(new class2);

  auto o11 = build_pmte(i);
  auto o12 = build_pmte(f);
  auto o13 = build_pmte(d);
  auto o14 = build_pmte(u);
  auto o15 = build_pmte(c);

  auto o16 = build_pmte<unsigned int>(i);
  auto o17 = build_pmte<double>(f);
  auto o18 = build_pmte<float>(d);
  auto o19 = build_pmte<uni>(u);
  auto o20 = build_pmte<class2>(c);

  auto o21 = build_pmte(class3 {i, f, d}, type_list<class1> {});
  auto o22 = build_pmte<class2>(class3 {i, f, d}, type_list<class1> {});
  auto o23 = build_pmte(c, type_list<class1, class3> {});
  auto o24 = build_pmte<class2>(c, type_list<class1, class3> {});

  {
    auto o25 = build_pmte(c2);
    ASSERT_EQ(c2.v.size(), 2);
    EXPECT_EQ(c2.v[0], 5);
    EXPECT_EQ(c2.v[1], 16);
    EXPECT_TRUE(is_type_of<class4>(o25));
    auto p = get_if<class4>(o25);
    ASSERT_EQ(p->v.size(), 2);
    EXPECT_EQ(p->v[0], 5);
    EXPECT_EQ(p->v[1], 16);
  }

  EXPECT_TRUE(is_type_of<int>(o0));
  EXPECT_TRUE(is_type_of<float>(o1));
  EXPECT_TRUE(is_type_of<unsigned long>(o2));
  EXPECT_TRUE(is_type_of<float>(o3));
  EXPECT_TRUE(is_type_of<double>(o4));
  EXPECT_TRUE(is_type_of<enum1>(o5));
  EXPECT_TRUE(is_type_of<class1>(o6));
  EXPECT_TRUE(is_type_of<class2>(o7));
  EXPECT_TRUE(is_type_of<uni>(o8));
  EXPECT_TRUE(is_type_of<class1 *>(o9));
  EXPECT_TRUE(is_type_of<class1 *>(o10));

  EXPECT_TRUE(is_type_of<int>(o11));
  EXPECT_TRUE(is_type_of<float>(o12));
  EXPECT_TRUE(is_type_of<double>(o13));
  EXPECT_TRUE(is_type_of<uni>(o14));
  EXPECT_TRUE(is_type_of<class3>(o15));
  EXPECT_TRUE(is_type_of<unsigned int>(o16));
  EXPECT_TRUE(is_type_of<double>(o17));
  EXPECT_TRUE(is_type_of<float>(o18));
  EXPECT_TRUE(is_type_of<uni>(o19));
  EXPECT_TRUE(is_type_of<class3>(o20));

  EXPECT_TRUE(is_type_of<class3>(o21));
  EXPECT_TRUE(is_type_of<class3>(o22));
  EXPECT_TRUE(is_type_of<class3>(o23));
  EXPECT_TRUE(is_type_of<class3>(o24));

  EXPECT_TRUE(is_castable_to<int>(o0));
  EXPECT_TRUE(is_castable_to<float>(o1));
  EXPECT_TRUE(is_castable_to<unsigned long>(o2));
  EXPECT_TRUE(is_castable_to<float>(o3));
  EXPECT_TRUE(is_castable_to<double>(o4));
  EXPECT_TRUE(is_castable_to<enum1>(o5));
  EXPECT_TRUE(is_castable_to<class1>(o6));
  EXPECT_TRUE(is_castable_to<class1>(o7));
  EXPECT_TRUE(is_castable_to<class2>(o7));
  EXPECT_TRUE(is_castable_to<uni>(o8));
  EXPECT_TRUE(is_castable_to<class1 *>(o9));
  EXPECT_TRUE(is_castable_to<class1 *>(o10));
  EXPECT_FALSE(is_castable_to<class2 *>(o10));

  EXPECT_TRUE(is_castable_to<int>(o11));
  EXPECT_TRUE(is_castable_to<float>(o12));
  EXPECT_TRUE(is_castable_to<double>(o13));
  EXPECT_TRUE(is_castable_to<uni>(o14));
  EXPECT_TRUE(is_castable_to<class3>(o15));
  EXPECT_TRUE(is_castable_to<unsigned int>(o16));
  EXPECT_TRUE(is_castable_to<double>(o17));
  EXPECT_TRUE(is_castable_to<float>(o18));
  EXPECT_TRUE(is_castable_to<uni>(o19));
  EXPECT_TRUE(is_castable_to<class2>(o20));
  EXPECT_TRUE(is_castable_to<class3>(o20));
  EXPECT_TRUE(is_castable_to<class3>(o21));
  EXPECT_TRUE(is_castable_to<const class3>(o21));
  EXPECT_TRUE(is_castable_to<class1>(o21));
  EXPECT_TRUE(is_castable_to<const class1>(o21));
  EXPECT_FALSE(is_castable_to<class2>(o21));
  EXPECT_FALSE(is_castable_to<const class2>(o21));
  EXPECT_TRUE(is_castable_to<class1>(o22));
  EXPECT_TRUE(is_castable_to<class2>(o22));
  EXPECT_TRUE(is_castable_to<class3>(o22));
  EXPECT_TRUE(is_castable_to<class1>(o23));
  EXPECT_FALSE(is_castable_to<class2>(o23));
  EXPECT_TRUE(is_castable_to<class3>(o23));
  EXPECT_TRUE(is_castable_to<class1>(o24));
  EXPECT_TRUE(is_castable_to<class2>(o24));
  EXPECT_TRUE(is_castable_to<class3>(o24));

  EXPECT_FALSE(is_castable_to<unsigned int>(o0));
  EXPECT_FALSE(is_castable_to<double>(o1));
  EXPECT_FALSE(is_castable_to<long>(o2));
  EXPECT_FALSE(is_castable_to<int>(o3));
  EXPECT_FALSE(is_castable_to<float>(o4));
  EXPECT_FALSE(is_castable_to<int>(o5));
  EXPECT_FALSE(is_castable_to<class2>(o6));
  EXPECT_FALSE(is_castable_to<class3>(o7));
  EXPECT_FALSE(is_castable_to<uni>(o7));
  EXPECT_FALSE(is_castable_to<class1>(o8));
  EXPECT_FALSE(is_castable_to<class2 *>(o9));
  EXPECT_FALSE(is_castable_to<float *>(o10));

#if __GNUC__ >= 8
  {
    bool deleter_invoked = false;
    {
      auto o = build_pmte(new char[3], [&](char p[]) {
        EXPECT_NE(p, nullptr);
        delete[] p;
        deleter_invoked = true;
      });
    }
    EXPECT_TRUE(deleter_invoked);
  }
#endif

  {
    bool deleter_invoked = false;
    {
      // just a test, don't use weak C arrays in real code
      auto o = build_pmte<class1 *>(
        new class3[3],
        [&](class1 p[]) {
          EXPECT_NE(p, nullptr);
          delete[] p;
          deleter_invoked = true;
        },
        type_list<class2 *, class3 *> {});
      EXPECT_TRUE(is_type_of<class1 *>(o));
      EXPECT_NE(get_if<class3 *>(o), nullptr);
      EXPECT_NE(get_if<class2 *>(o), nullptr);
      EXPECT_NE(get_if<class1 *>(o), nullptr);
      EXPECT_NE(get_if<const class3 *>(o), nullptr);
      EXPECT_NE(get_if<const class2 *>(o), nullptr);
      EXPECT_NE(get_if<const class1 *>(o), nullptr);
      get_if<class3 *>(o)[0].d = 5.978;
      get_if<class3 *>(o)[1].f = 19.7f;
      get_if<class3 *>(o)[2].a = 7;
      EXPECT_EQ(get_if<class3 *>(o)[0].d, 5.978);
      EXPECT_EQ(get_if<class3 *>(o)[1].f, 19.7f);
      EXPECT_EQ(get_if<class3 *>(o)[2].a, 7);
    }
    EXPECT_TRUE(deleter_invoked);
  }

  {
    bool deleter_invoked = false;
    {
      // just a test, don't use weak C arrays in real code
      auto o = build_pmte(
        new class3[3],
        [&](class3 p[]) {
          EXPECT_NE(p, nullptr);
          delete[] p;
          deleter_invoked = true;
        },
        type_list<class1 *, class2 *> {});
      EXPECT_TRUE(is_type_of<class3 *>(o));
      EXPECT_NE(get_if<class3 *>(o), nullptr);
      EXPECT_NE(get_if<class2 *>(o), nullptr);
      EXPECT_NE(get_if<class1 *>(o), nullptr);
      EXPECT_NE(get_if<const class3 *>(o), nullptr);
      EXPECT_NE(get_if<const class2 *>(o), nullptr);
      EXPECT_NE(get_if<const class1 *>(o), nullptr);
      get_if<class3 *>(o)[0].d = 5.978;
      get_if<class3 *>(o)[1].f = 19.7f;
      get_if<class3 *>(o)[2].a = 7;
      EXPECT_EQ(get_if<class3 *>(o)[0].d, 5.978);
      EXPECT_EQ(get_if<class3 *>(o)[1].f, 19.7f);
      EXPECT_EQ(get_if<class3 *>(o)[2].a, 7);
    }
    EXPECT_TRUE(deleter_invoked);
  }
}

TEST(PMTE, ConstructValueStoreAt) {
  unsigned char buffer[1024];
  pmte_value * p;

  int i = 9;
  float f = 8.39f;
  double d = 17.8;
  uni u {.d = 8};
  class3 c {i, f, d};
  const class3 cc {i, f, d};

  p = construct_pmte_at(buffer, 1);
  EXPECT_TRUE(is_type_of<int>(p));
  ASSERT_NE(p->get_if<int>(), nullptr);
  EXPECT_EQ(*p->get_if<int>(), 1);
  p->~pmte_value();

  p = construct_pmte_at<int>(buffer, 1.6f);
  EXPECT_TRUE(is_type_of<int>(p));
  ASSERT_NE(p->get_if<int>(), nullptr);
  EXPECT_EQ(*p->get_if<int>(), 1);
  p->~pmte_value();

  p = construct_pmte_at(buffer, 5.4f);
  EXPECT_TRUE(is_type_of<float>(p));
  ASSERT_NE(p->get_if<float>(), nullptr);
  EXPECT_EQ(*p->get_if<float>(), 5.4f);
  p->~pmte_value();

  p = construct_pmte_at<double>(buffer, 0.4f);
  EXPECT_TRUE(is_type_of<double>(p));
  ASSERT_NE(p->get_if<double>(), nullptr);
  EXPECT_EQ(*p->get_if<double>(), 0.4f);
  p->~pmte_value();

  {
    double d = 0.97;
    p = construct_pmte_at(buffer, &d);
    EXPECT_TRUE(is_type_of<double *>(p));
    ASSERT_NE(p->get_if<double *>(), nullptr);
    EXPECT_EQ(*p->get_if<double *>(), 0.97);
    p->~pmte_value();
  }

  {
    float f = 0.98f;
    p = construct_pmte_at(buffer, &f);
    EXPECT_TRUE(is_type_of<float *>(p));
    ASSERT_NE(p->get_if<float *>(), nullptr);
    EXPECT_EQ(*p->get_if<float *>(), 0.98f);
    p->~pmte_value();
  }

  {
    const float cf = 0.98f;
    p = construct_pmte_at(buffer, &cf, type_list<const float *, const void *> {});
    EXPECT_TRUE(is_type_of<const float *>(p));
    ASSERT_NE(p->get_if<const float *>(), nullptr);
    EXPECT_EQ(*p->get_if<const float *>(), 0.98f);
    p->~pmte_value();
  }

  p = construct_pmte_at(buffer, class1 {5});
  EXPECT_TRUE(is_type_of<class1>(p));
  ASSERT_NE(p->get_if<class1>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 5);
  p->~pmte_value();

  p = construct_pmte_at(buffer, class2 {5, 19.3f});
  EXPECT_TRUE(is_type_of<class2>(p));
  EXPECT_FALSE(is_type_of<class1>(p));
  ASSERT_NE(p->get_if<class2>(), nullptr);
  EXPECT_EQ(p->get_if<class2>()->a, 5);
  EXPECT_EQ(p->get_if<class2>()->f, 19.3f);
  p->~pmte_value();

  p = construct_pmte_at<class1>(buffer, class2 {8, 5.97f});
  EXPECT_TRUE(is_type_of<class2>(p));
  ASSERT_NE(p->get_if<class2>(), nullptr);
  ASSERT_NE(p->get_if<class1>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 8);
  p->~pmte_value();

  p = construct_pmte_at<class1>(buffer, class3 {8, 5.97f, 99.9}, type_list<class2, class3> {});
  EXPECT_TRUE(is_type_of<class3>(p));
  ASSERT_NE(p->get_if<class3>(), nullptr);
  ASSERT_NE(p->get_if<const class3>(), nullptr);
  ASSERT_NE(p->get_if<class2>(), nullptr);
  ASSERT_NE(p->get_if<const class2>(), nullptr);
  ASSERT_NE(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<const class1>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 8);
  EXPECT_EQ(p->get_if<class2>()->f, 5.97f);
  EXPECT_EQ(p->get_if<class3>()->d, 99.9);
  EXPECT_EQ(p->get_if<const class1>()->a, 8);
  EXPECT_EQ(p->get_if<const class2>()->f, 5.97f);
  EXPECT_EQ(p->get_if<const class3>()->d, 99.9);
  p->~pmte_value();

  p = construct_pmte_at(buffer, class3 {8, 5.97f, 99.9}, type_list<class2, class1> {});
  EXPECT_TRUE(is_type_of<class3>(p));
  ASSERT_NE(p->get_if<class3>(), nullptr);
  ASSERT_NE(p->get_if<const class3>(), nullptr);
  ASSERT_NE(p->get_if<class2>(), nullptr);
  ASSERT_NE(p->get_if<const class2>(), nullptr);
  ASSERT_NE(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<const class1>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 8);
  EXPECT_EQ(p->get_if<class2>()->f, 5.97f);
  EXPECT_EQ(p->get_if<class3>()->d, 99.9);
  EXPECT_EQ(p->get_if<const class1>()->a, 8);
  EXPECT_EQ(p->get_if<const class2>()->f, 5.97f);
  EXPECT_EQ(p->get_if<const class3>()->d, 99.9);
  p->~pmte_value();

  p = construct_pmte_at(buffer, std::add_const_t<class3> {8, 5.97f, 99.9}, type_list<const class2, const class1> {});
  EXPECT_FALSE(is_type_of<class3>(p));
  EXPECT_TRUE(is_type_of<const class3>(p));
  ASSERT_EQ(p->get_if<class3>(), nullptr);
  ASSERT_NE(p->get_if<const class3>(), nullptr);
  ASSERT_EQ(p->get_if<class2>(), nullptr);
  ASSERT_NE(p->get_if<const class2>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<const class1>(), nullptr);
  EXPECT_EQ(p->get_if<const class1>()->a, 8);
  EXPECT_EQ(p->get_if<const class2>()->f, 5.97f);
  EXPECT_EQ(p->get_if<const class3>()->d, 99.9);
  p->~pmte_value();

  p = construct_pmte_at(buffer, i);
  EXPECT_TRUE(is_type_of<int>(p));
  EXPECT_TRUE(is_castable_to<const int>(p));
  p->~pmte_value();

  p = construct_pmte_at(buffer, f);
  EXPECT_TRUE(is_type_of<float>(p));
  EXPECT_TRUE(is_castable_to<const float>(p));
  p->~pmte_value();

  p = construct_pmte_at(buffer, d);
  EXPECT_TRUE(is_type_of<double>(p));
  EXPECT_TRUE(is_castable_to<const double>(p));
  p->~pmte_value();

  p = construct_pmte_at(buffer, u);
  EXPECT_TRUE(is_type_of<uni>(p));
  EXPECT_TRUE(is_castable_to<const uni>(p));
  p->~pmte_value();

  p = construct_pmte_at(buffer, c);
  EXPECT_TRUE(is_type_of<class3>(p));
  EXPECT_TRUE(is_castable_to<const class3>(p));
  p->~pmte_value();

  p = construct_pmte_at(buffer, cc);
  EXPECT_TRUE(is_type_of<const class3>(p));
  EXPECT_FALSE(is_castable_to<class3>(p));
  p->~pmte_value();

#if __GNUC__ >= 8
  {
    bool deleter_invoked = false;
    pmte_value * p = construct_pmte_at(buffer, new class3, [&](class3 * p) {
      deleter_invoked = true;
      delete p;
    });
    p->~pmte_value();
    EXPECT_TRUE(deleter_invoked);
  }

  {
    bool deleter_invoked = false;
    pmte_value * p = construct_pmte_at<class2 *>(buffer, new class3, [&](class2 * p) {
      deleter_invoked = true;
      delete p;
    });
    p->~pmte_value();
    EXPECT_TRUE(deleter_invoked);
  }
#endif

  {
    bool deleter_invoked = false;
    pmte_value * p = construct_pmte_at(
      buffer, new class3,
      [&](class3 * p) {
        deleter_invoked = true;
        delete p;
      },
      type_list<class1 *, class2 *> {});
    p->~pmte_value();
    EXPECT_TRUE(deleter_invoked);
  }
}

TEST(PMTE, MakePmte) {
  pmte_value * p;

  int i = 9;
  float f = 8.39f;
  double d = 17.8;
  uni u {.d = 8};
  class3 c {i, f, d};
  const class3 cc {i, f, d};

  p = make_pmte(5);
  EXPECT_TRUE(is_type_of<int>(p));
  ASSERT_NE(p->get_if<int>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(*p->get_if<int>(), 5);
  EXPECT_EQ(p->index(type_info<int> {}), 0);
  EXPECT_EQ(p->index(type_info<const int> {}), 1);
  EXPECT_EQ(p->index(type_info<float>()), -1);
  delete p;

  p = make_pmte(5.4f);
  EXPECT_TRUE(is_type_of<float>(p));
  ASSERT_NE(p->get_if<float>(), nullptr);
  ASSERT_EQ(p->get_if<enum1>(), nullptr);
  EXPECT_EQ(*p->get_if<float>(), 5.4f);
  EXPECT_EQ(p->index(type_info<float> {}), 0);
  EXPECT_EQ(p->index(type_info<const float> {}), 1);
  EXPECT_EQ(p->index(type_info<int>()), -1);
  delete p;

  p = make_pmte(5.97);
  EXPECT_TRUE(is_type_of<double>(p));
  ASSERT_NE(p->get_if<double>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(*p->get_if<double>(), 5.97);
  EXPECT_EQ(p->index(type_info<double> {}), 0);
  EXPECT_EQ(p->index(type_info<class2>()), -1);
  delete p;

  p = make_pmte(enum1_value);
  EXPECT_TRUE(is_type_of<enum1>(p));
  ASSERT_NE(p->get_if<enum1>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(*p->get_if<enum1>(), enum1_value);
  EXPECT_EQ(p->index(type_info<enum1> {}), 0);
  EXPECT_EQ(p->index(type_info<const enum1> {}), 1);
  EXPECT_EQ(p->index(type_info<int>()), -1);
  delete p;

  p = make_pmte(uni {.d = 97.58});
  EXPECT_TRUE(is_type_of<uni>(p));
  ASSERT_NE(p->get_if<uni>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(p->get_if<uni>()->d, 97.58);
  EXPECT_EQ(p->index(type_info<uni> {}), 0);
  EXPECT_EQ(p->index(type_info<const uni> {}), 1);
  EXPECT_EQ(p->index(type_info<class2>()), -1);
  delete p;

  p = make_pmte(class1 {87});
  EXPECT_TRUE(is_type_of<class1>(p));
  ASSERT_NE(p->get_if<class1>(), nullptr);
  ASSERT_EQ(p->get_if<uni>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 87);
  EXPECT_EQ(p->index(type_info<class1> {}), 0);
  EXPECT_EQ(p->index(type_info<const class1>()), 1);
  EXPECT_EQ(p->index(type_info<class2>()), -1);
  EXPECT_EQ(p->index(type_info<const class2>()), -1);
  delete p;

  p = make_pmte(class2 {51, 0.1589f});
  EXPECT_TRUE(is_type_of<class2>(p));
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<class2>(), nullptr);
  EXPECT_EQ(p->get_if<class2>()->a, 51);
  EXPECT_EQ(p->get_if<class2>()->f, 0.1589f);
  EXPECT_EQ(p->index(type_info<class2> {}), 0);
  EXPECT_EQ(p->index(type_info<const class2> {}), 1);
  EXPECT_EQ(p->index(type_info<class1>()), -1);
  EXPECT_EQ(p->index(type_info<const class1>()), -1);
  delete p;

  p = make_pmte(class3 {51, 0.1589f, 127.88}, type_list<class2> {});
  EXPECT_TRUE(is_type_of<class3>(p));
  ASSERT_NE(p->get_if<class3>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<class2>(), nullptr);
  EXPECT_EQ(p->get_if<class3>()->a, 51);
  EXPECT_EQ(p->get_if<class3>()->f, 0.1589f);
  EXPECT_EQ(p->get_if<class3>()->d, 127.88);
  EXPECT_EQ(p->index(type_info<class3> {}), 0);
  EXPECT_EQ(p->index(type_info<const class3> {}), 1);
  EXPECT_EQ(p->index(type_info<class2> {}), 2);
  EXPECT_EQ(p->index(type_info<const class2> {}), 3);
  EXPECT_EQ(p->index(type_info<class1>()), -1);
  EXPECT_EQ(p->index(type_info<const class1>()), -1);
  delete p;

  p = make_pmte<int>(5.2);
  EXPECT_TRUE(is_type_of<int>(p));
  ASSERT_NE(p->get_if<int>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(*p->get_if<int>(), 5);
  EXPECT_EQ(p->index(type_info<int> {}), 0);
  EXPECT_EQ(p->index(type_info<const int> {}), 1);
  EXPECT_EQ(p->index(type_info<class3> {}), -1);
  EXPECT_EQ(p->index(type_info<const class3> {}), -1);
  delete p;

  p = make_pmte<float>(5.4);
  EXPECT_TRUE(is_type_of<float>(p));
  ASSERT_NE(p->get_if<float>(), nullptr);
  ASSERT_EQ(p->get_if<enum1>(), nullptr);
  EXPECT_EQ(*p->get_if<float>(), 5.4f);
  EXPECT_EQ(p->index(type_info<float> {}), 0);
  EXPECT_EQ(p->index(type_info<const float> {}), 1);
  EXPECT_EQ(p->index(type_info<int>()), -1);
  delete p;

  p = make_pmte<double>(5.97);
  EXPECT_TRUE(is_type_of<double>(p));
  ASSERT_NE(p->get_if<double>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(*p->get_if<double>(), 5.97);
  EXPECT_EQ(p->index(type_info<double> {}), 0);
  EXPECT_EQ(p->index(type_info<class2>()), -1);
  delete p;

  p = make_pmte<enum1>(enum1_value);
  EXPECT_TRUE(is_type_of<enum1>(p));
  ASSERT_NE(p->get_if<enum1>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(*p->get_if<enum1>(), enum1_value);
  EXPECT_EQ(p->index(type_info<enum1> {}), 0);
  EXPECT_EQ(p->index(type_info<const enum1> {}), 1);
  EXPECT_EQ(p->index(type_info<int>()), -1);
  delete p;

  p = make_pmte<uni>(uni {.d = 97.58});
  EXPECT_TRUE(is_type_of<uni>(p));
  ASSERT_NE(p->get_if<uni>(), nullptr);
  ASSERT_EQ(p->get_if<class1>(), nullptr);
  EXPECT_EQ(p->get_if<uni>()->d, 97.58);
  EXPECT_EQ(p->index(type_info<uni> {}), 0);
  EXPECT_EQ(p->index(type_info<const uni> {}), 1);
  EXPECT_EQ(p->index(type_info<class2>()), -1);
  delete p;

  p = make_pmte<class1>(class1 {87});
  EXPECT_TRUE(is_type_of<class1>(p));
  ASSERT_NE(p->get_if<class1>(), nullptr);
  ASSERT_EQ(p->get_if<uni>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 87);
  EXPECT_EQ(p->index(type_info<class1> {}), 0);
  EXPECT_EQ(p->index(type_info<const class1>()), 1);
  EXPECT_EQ(p->index(type_info<class2>()), -1);
  EXPECT_EQ(p->index(type_info<const class2>()), -1);
  delete p;

  p = make_pmte<class1>(class2 {51, 0.1589f});
  EXPECT_TRUE(is_type_of<class2>(p));
  ASSERT_NE(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<class2>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 51);
  EXPECT_EQ(p->index(type_info<class2>()), 0);
  EXPECT_EQ(p->index(type_info<const class2>()), 1);
  EXPECT_EQ(p->index(type_info<class1>()), 2);
  EXPECT_EQ(p->index(type_info<const class1>()), 3);
  delete p;

  {
    p = make_pmte<class1>(class2 {}, type_list<class1, class2> {});
    EXPECT_TRUE(is_type_of<class2>(p));
    delete p;

    p = make_pmte<void *>(new class2 {}, type_list<void *, class2 *> {});
    EXPECT_TRUE(is_type_of<void *>(p));
    delete p;

    p = make_pmte<class2>(class2 {}, type_list<class2, class1> {});
    EXPECT_TRUE(is_type_of<class2>(p));
    delete p;
  }

  p = make_pmte<class1>(class3 {51, 0.1589f, 127.88}, type_list<class3, class2, class1> {});
  EXPECT_TRUE(is_type_of<class3>(p));
  ASSERT_NE(p->get_if<class3>(), nullptr);
  ASSERT_NE(p->get_if<class1>(), nullptr);
  ASSERT_NE(p->get_if<class2>(), nullptr);
  EXPECT_EQ(p->get_if<class1>()->a, 51);
  EXPECT_EQ(p->get_if<class2>()->f, 0.1589f);
  EXPECT_EQ(p->get_if<class3>()->d, 127.88);
  EXPECT_EQ(p->index(type_info<class1>()), 4);
  EXPECT_EQ(p->index(type_info<const class1>()), 5);
  EXPECT_EQ(p->index(type_info<class2> {}), 2);
  EXPECT_EQ(p->index(type_info<const class2> {}), 3);
  EXPECT_EQ(p->index(type_info<class3> {}), 0);
  EXPECT_EQ(p->index(type_info<const class3> {}), 1);
  delete p;

  p = make_pmte(i);
  EXPECT_TRUE(is_type_of<int>(p));
  EXPECT_TRUE(is_castable_to<const int>(p));
  delete p;

  p = make_pmte(f);
  EXPECT_TRUE(is_type_of<float>(p));
  EXPECT_TRUE(is_castable_to<const float>(p));
  delete p;

  p = make_pmte(d);
  EXPECT_TRUE(is_type_of<double>(p));
  EXPECT_TRUE(is_castable_to<const double>(p));
  delete p;

  p = make_pmte(u);
  EXPECT_TRUE(is_type_of<uni>(p));
  EXPECT_TRUE(is_castable_to<const uni>(p));
  delete p;

  p = make_pmte(c);
  EXPECT_TRUE(is_type_of<class3>(p));
  EXPECT_TRUE(is_castable_to<const class3>(p));
  delete p;

  p = make_pmte(cc);
  EXPECT_TRUE(is_type_of<const class3>(p));
  EXPECT_FALSE(is_castable_to<class3>(p));
  delete p;
}

TEST(PMTE, MakePmtePointerTypes) {
  pmte_value * p;

  char c = 'A';
  int i = 15;
  class1 c1 {18};
  class3 c3 {19, 47.5f, 88.03};

  const char cc = 'A';
  const int ci = 15;
  const class1 cc1 {18};
  const class3 cc3 {19, 47.5f, 88.03};

  {
    auto p = make_pmte(&c);
    EXPECT_FALSE(p->has_deleter);
    EXPECT_GE(p->size(), 8);
    EXPECT_EQ(p->type(), type_info<char *> {});
    delete p;
  }

  p = make_pmte(&c);
  EXPECT_TRUE(is_type_of<char *>(p));
  EXPECT_FALSE(is_type_of<int *>(p));
  EXPECT_TRUE(is_castable_to<char *>(p));
  EXPECT_FALSE(is_castable_to<int *>(p));
  delete p;

  p = make_pmte(&i);
  EXPECT_TRUE(is_type_of<int *>(p));
  EXPECT_TRUE(is_castable_to<int *>(p));
  EXPECT_TRUE(is_castable_to<const int *>(p));
  EXPECT_FALSE(is_castable_to<char *>(p));
  delete p;

  p = make_pmte(&c1);
  EXPECT_TRUE(is_type_of<class1 *>(p));
  EXPECT_TRUE(is_castable_to<class1 *>(p));
  EXPECT_TRUE(is_castable_to<const class1 *>(p));
  EXPECT_FALSE(is_castable_to<class2 *>(p));
  delete p;

  p = make_pmte(&c3);
  EXPECT_TRUE(is_type_of<class3 *>(p));
  EXPECT_EQ(p->index(type_info<class3 *> {}), 0);
  EXPECT_EQ(p->index(type_info<const class3 *> {}), 1);
  EXPECT_EQ(p->index(type_info<class1 *> {}), -1);
  delete p;

  p = make_pmte<char *>(&c);
  EXPECT_TRUE(is_type_of<char *>(p));
  EXPECT_EQ(p->index(type_info<char *> {}), 0);
  EXPECT_EQ(p->index(type_info<const char *> {}), 1);
  EXPECT_EQ(p->index(type_info<int *> {}), -1);
  EXPECT_EQ(p->get_if<char *>(), &c);
  delete p;

  p = make_pmte<int *>(&i);
  EXPECT_TRUE(is_type_of<int *>(p));
  EXPECT_EQ(p->get_if<const int *>(), &i);
  delete p;

  p = make_pmte<class1 *>(&c1);
  EXPECT_TRUE(is_type_of<class1 *>(p));
  delete p;

  p = make_pmte<class3 *>(&c3);
  EXPECT_TRUE(is_type_of<class3 *>(p));
  delete p;

  p = make_pmte<const char *>(&c);
  EXPECT_TRUE(is_type_of<const char *>(p));
  delete p;

  p = make_pmte<const int *>(&i);
  EXPECT_TRUE(is_type_of<const int *>(p));
  delete p;

  p = make_pmte<const class1 *>(&c1);
  EXPECT_TRUE(is_type_of<const class1 *>(p));
  EXPECT_EQ(p->get_if<class1 *>(), nullptr);
  delete p;

  p = make_pmte<const class3 *>(&c3);
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  delete p;

  p = make_pmte<void *>(&c3);
  EXPECT_TRUE(is_type_of<void *>(p));
  delete p;

  p = make_pmte<const class3 *>(&c3, type_list<const class1 *> {});
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  EXPECT_TRUE(is_castable_to<const class3 *>(p));
  EXPECT_FALSE(is_castable_to<const class2 *>(p));
  EXPECT_TRUE(is_castable_to<const class1 *>(p));
  EXPECT_FALSE(is_castable_to<class1 *>(p));
  delete p;

  p = make_pmte(&cc);
  EXPECT_TRUE(is_type_of<const char *>(p));
  delete p;

  p = make_pmte(&ci);
  EXPECT_TRUE(is_type_of<const int *>(p));
  delete p;

  p = make_pmte(&cc1);
  EXPECT_TRUE(is_type_of<const class1 *>(p));
  delete p;

  p = make_pmte(&cc3);
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  delete p;

  p = make_pmte(&cc3);
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  delete p;

  p = make_pmte(&cc3, type_list<const class1 *> {});
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  EXPECT_TRUE(is_castable_to<const class3 *>(p));
  EXPECT_FALSE(is_castable_to<class3 *>(p));
  delete p;

  p = make_pmte<const char *>(&cc);
  EXPECT_TRUE(is_type_of<const char *>(p));
  delete p;

  p = make_pmte<const int *>(&ci);
  EXPECT_TRUE(is_type_of<const int *>(p));
  delete p;

  p = make_pmte<const class1 *>(&cc1);
  EXPECT_TRUE(is_type_of<const class1 *>(p));
  delete p;

  p = make_pmte<const class3 *>(&cc3);
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  delete p;

  p = make_pmte<const void *>(&cc3);
  EXPECT_TRUE(is_type_of<const void *>(p));
  delete p;

  p = make_pmte<const class3 *>(&cc3, type_list<const class1 *> {});
  EXPECT_TRUE(is_type_of<const class3 *>(p));
  delete p;

#if __GNUC__ >= 8
  {
    bool deleter_called = false;
    auto p = make_pmte(new char[128], [&](char p[]) {
      delete[] p;
      deleter_called = true;
    });
    EXPECT_TRUE(p->has_deleter);
    EXPECT_TRUE(is_type_of<char *>(p));
    EXPECT_FALSE(is_type_of<char[]>(p));
    delete p;
    EXPECT_TRUE(deleter_called);
  }

  {
    bool deleter_called = false;
    auto p = make_pmte(new class3, [&](class3 * p) {
      delete[] p;
      deleter_called = true;
    });
    EXPECT_TRUE(p->has_deleter);
    EXPECT_TRUE(is_type_of<class3 *>(p));
    EXPECT_TRUE(is_castable_to<class3 *>(p));
    EXPECT_TRUE(is_castable_to<const class3 *>(p));
    delete p;
    EXPECT_TRUE(deleter_called);
  }
#endif

  {
    bool deleter_called = false;
    auto p = make_pmte(
      new class3,
      [&](class3 * p) {
        delete[] p;
        deleter_called = true;
      },
      type_list<class2 *, class1 *> {});
    EXPECT_TRUE(p->has_deleter);
    EXPECT_TRUE(is_type_of<class3 *>(p));
    EXPECT_TRUE(is_castable_to<class1 *>(p));
    EXPECT_TRUE(is_castable_to<const class1 *>(p));
    EXPECT_TRUE(is_castable_to<class2 *>(p));
    EXPECT_TRUE(is_castable_to<const class2 *>(p));
    EXPECT_TRUE(is_castable_to<class3 *>(p));
    EXPECT_TRUE(is_castable_to<const class3 *>(p));
    delete p;
    EXPECT_TRUE(deleter_called);
  }
}

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
TEST(PMTE, MakePmteWithResource) {

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    auto o0 = make_pmte(counter, 5);
    EXPECT_TRUE(is_type_of<int>(o0));
    EXPECT_TRUE(is_castable_to<int>(o0));
    EXPECT_FALSE(is_castable_to<float>(o0));
    EXPECT_FALSE(o0->has_deleter);
    EXPECT_EQ(o0->index(type_info<int> {}), 0);
    EXPECT_EQ(o0->index(type_info<const int> {}), 1);
    EXPECT_EQ(o0->index(type_info<float> {}), -1);
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    EXPECT_EQ(o0->size(), platform_is64bit ? 16 : 8);
    EXPECT_EQ(o0->type(), type_info<int> {});
    EXPECT_EQ(o0->get(), 5);
    EXPECT_NE(get_if<int>(o0), nullptr);
    EXPECT_NE(get_if<const int>(o0), nullptr);
    EXPECT_EQ(get_if<float>(o0), nullptr);
    void * clone_address = counter.allocate(o0->size());
    auto o1 = o0->clone(clone_address);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_TRUE(is_type_of<int>(o1));
    EXPECT_EQ(*get_if<int>(o0), *get_if<int>(o1));
    destroy(counter, o0);
    o0 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 1);
    destroy(counter, o1);
    o1 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    destroy(counter, o0);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    auto o0 = make_pmte(counter, class3 {17, 8.6f, 19.7});
    EXPECT_TRUE(is_type_of<class3>(o0));
    EXPECT_TRUE(is_castable_to<class3>(o0));
    EXPECT_FALSE(is_castable_to<class1>(o0));
    EXPECT_FALSE(is_castable_to<class2>(o0));
    EXPECT_FALSE(o0->has_deleter);
    EXPECT_EQ(o0->index(type_info<class3> {}), 0);
    EXPECT_EQ(o0->index(type_info<const class3> {}), 1);
    EXPECT_EQ(o0->index(type_info<class2> {}), -1);
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 24 : 20);
    EXPECT_EQ(o0->size(), platform_is64bit ? 24 : 20);
    EXPECT_EQ(o0->type(), type_info<class3> {});
    EXPECT_EQ(o0->get().a, 17);
    EXPECT_EQ(o0->get().f, 8.6f);
    EXPECT_EQ(o0->get().d, 19.7);
    EXPECT_NE(get_if<class3>(o0), nullptr);
    EXPECT_NE(get_if<const class3>(o0), nullptr);
    EXPECT_EQ(get_if<class2>(o0), nullptr);
    void * clone_address = counter.allocate(o0->size());
    auto o1 = o0->clone(clone_address);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 48 : 40);
    ASSERT_TRUE(is_type_of<class3>(o1));
    EXPECT_EQ(get_if<class3>(o0)->a, get_if<class3>(o1)->a);
    EXPECT_EQ(get_if<class3>(o0)->f, get_if<class3>(o1)->f);
    EXPECT_EQ(get_if<class3>(o0)->d, get_if<class3>(o1)->d);
    destroy(counter, o0);
    o0 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 1);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 24 : 20);
    destroy(counter, o1);
    o1 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    EXPECT_EQ(counter.allocated_memory(), 0);
    destroy(counter, o0);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    EXPECT_EQ(counter.allocated_memory(), 0);
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    auto o0 = make_pmte<const class1>(counter, class3 {17, 8.6f, 19.7}, type_list<const class3, const class2> {});
    EXPECT_TRUE(is_type_of<class3>(o0));
    EXPECT_FALSE(is_type_of<const class1>(o0));
    EXPECT_TRUE(is_castable_to<class3>(o0));
    EXPECT_TRUE(is_castable_to<const class3>(o0));
    EXPECT_FALSE(is_castable_to<class1>(o0));
    EXPECT_TRUE(is_castable_to<const class1>(o0));
    EXPECT_FALSE(is_castable_to<class2>(o0));
    EXPECT_TRUE(is_castable_to<const class2>(o0));
    EXPECT_FALSE(o0->has_deleter);
    EXPECT_EQ(o0->index(type_info<class3> {}), 0);
    EXPECT_EQ(o0->index(type_info<const class3> {}), 1);
    EXPECT_EQ(o0->index(type_info<class2> {}), -1);
    EXPECT_EQ(o0->index(type_info<const class2> {}), 2);
    EXPECT_EQ(o0->index(type_info<class1> {}), -1);
    EXPECT_EQ(o0->index(type_info<const class1> {}), 3);
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 24 : 20);
    EXPECT_EQ(o0->size(), platform_is64bit ? 24 : 20);
    EXPECT_EQ(o0->type(), type_info<class3> {});
    EXPECT_EQ(o0->get().a, 17);
    EXPECT_EQ(o0->get().f, 8.6f);
    EXPECT_EQ(o0->get().d, 19.7);
    EXPECT_NE(get_if<class3>(o0), nullptr);
    EXPECT_NE(get_if<const class3>(o0), nullptr);
    EXPECT_EQ(get_if<class2>(o0), nullptr);
    EXPECT_NE(get_if<const class2>(o0), nullptr);
    EXPECT_EQ(get_if<class1>(o0), nullptr);
    EXPECT_NE(get_if<const class1>(o0), nullptr);
    void * clone_address = counter.allocate(o0->size());
    auto o1 = o0->clone(clone_address);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 48 : 40);
    ASSERT_TRUE(is_type_of<class3>(o1));
    EXPECT_EQ(get_if<const class3>(o0)->a, get_if<const class3>(o1)->a);
    EXPECT_EQ(get_if<const class3>(o0)->f, get_if<const class3>(o1)->f);
    EXPECT_EQ(get_if<const class3>(o0)->d, get_if<const class3>(o1)->d);
    destroy(counter, o0);
    o0 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 1);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 24 : 20);
    destroy(counter, o1);
    o1 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    EXPECT_EQ(counter.allocated_memory(), 0);
    destroy(counter, o0);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    EXPECT_EQ(counter.allocated_memory(), 0);
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    auto o0 = make_pmte<const class1>(counter, std::add_const_t<class3> {17, 8.6f, 19.7}, type_list<const class2> {});
    EXPECT_FALSE(is_type_of<const class1>(o0));
    EXPECT_TRUE(is_type_of<const class3>(o0));
    EXPECT_FALSE(is_castable_to<class3>(o0));
    EXPECT_TRUE(is_castable_to<const class3>(o0));
    EXPECT_FALSE(is_castable_to<class1>(o0));
    EXPECT_TRUE(is_castable_to<const class1>(o0));
    EXPECT_FALSE(is_castable_to<class2>(o0));
    EXPECT_TRUE(is_castable_to<const class2>(o0));
    EXPECT_FALSE(o0->has_deleter);
    EXPECT_EQ(o0->index(type_info<class3> {}), -1);
    EXPECT_EQ(o0->index(type_info<const class3> {}), 0);
    EXPECT_EQ(o0->index(type_info<class2> {}), -1);
    EXPECT_EQ(o0->index(type_info<const class2> {}), 1);
    EXPECT_EQ(o0->index(type_info<class1> {}), -1);
    EXPECT_EQ(o0->index(type_info<const class1> {}), 2);
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 24 : 20);
    EXPECT_EQ(o0->size(), platform_is64bit ? 24 : 20);
    EXPECT_EQ(o0->type(), type_info<const class3> {});
    EXPECT_NE(o0->type(), type_info<const class1> {});
    EXPECT_EQ(o0->get().a, 17);
    EXPECT_EQ(o0->get().f, 8.6f);
    EXPECT_EQ(o0->get().d, 19.7);
    EXPECT_EQ(get_if<class3>(o0), nullptr);
    EXPECT_NE(get_if<const class3>(o0), nullptr);
    EXPECT_EQ(get_if<class2>(o0), nullptr);
    EXPECT_NE(get_if<const class2>(o0), nullptr);
    EXPECT_EQ(get_if<class1>(o0), nullptr);
    EXPECT_NE(get_if<const class1>(o0), nullptr);
    void * clone_address = counter.allocate(o0->size());
    auto o1 = o0->clone(clone_address);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 48 : 40);
    ASSERT_TRUE(is_type_of<const class3>(o1));
    EXPECT_EQ(get_if<const class2>(o0)->a, get_if<const class1>(o1)->a);
    EXPECT_EQ(get_if<const class2>(o0)->f, get_if<const class2>(o1)->f);
    destroy(counter, o0);
    o0 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 1);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 24 : 20);
    destroy(counter, o1);
    o1 = nullptr;
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    EXPECT_EQ(counter.allocated_memory(), 0);
    destroy(counter, o0);
    EXPECT_EQ(counter.allocations(), 2);
    EXPECT_EQ(counter.deallocations(), 2);
    EXPECT_EQ(counter.allocated_memory(), 0);
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    bool deleter_called = false;
    auto p = make_pmte(counter, new char[128], [&](char p[]) {
      delete[] p;
      deleter_called = true;
    });
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 32 : 16);
    EXPECT_TRUE(p->has_deleter);
    EXPECT_TRUE(is_type_of<char *>(p));
    EXPECT_FALSE(is_type_of<char[]>(p));
    destroy(counter, p);
    EXPECT_TRUE(deleter_called);
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 1);
    EXPECT_EQ(counter.allocated_memory(), 0);
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    bool deleter_called = false;
    auto p = make_pmte(counter, new class3, [&](class3 * p) {
      delete[] p;
      deleter_called = true;
    });
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 0);
    EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 32 : 16);
    EXPECT_TRUE(p->has_deleter);
    EXPECT_TRUE(is_type_of<class3 *>(p));
    EXPECT_TRUE(is_castable_to<class3 *>(p));
    EXPECT_TRUE(is_castable_to<const class3 *>(p));
    destroy(counter, p);
    EXPECT_TRUE(deleter_called);
    EXPECT_EQ(counter.allocations(), 1);
    EXPECT_EQ(counter.deallocations(), 1);
    EXPECT_EQ(counter.allocated_memory(), 0);
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);
    bool deleter_called = false;
    auto p = make_pmte(
      counter, new class3,
      [&](class3 * p) {
        delete[] p;
        deleter_called = true;
      },
      type_list<class2 *, class1 *> {});
    EXPECT_TRUE(p->has_deleter);
    EXPECT_TRUE(is_type_of<class3 *>(p));
    EXPECT_TRUE(is_castable_to<class1 *>(p));
    EXPECT_TRUE(is_castable_to<const class1 *>(p));
    EXPECT_TRUE(is_castable_to<class2 *>(p));
    EXPECT_TRUE(is_castable_to<const class2 *>(p));
    EXPECT_TRUE(is_castable_to<class3 *>(p));
    EXPECT_TRUE(is_castable_to<const class3 *>(p));
    destroy(counter, p);
    EXPECT_TRUE(deleter_called);
  }
}

TEST(PMTE, MakePmteWithResourcePointerTypes) {
  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    int i = 5;
    float f = 8.88f;
    double d = 9.99;
    uni u {.d = 10.11};
    class3 c {7, 5.9f, 10.88};
    const class3 cc {i, f, d};

    {
      auto o = make_pmte(counter, &i);
      EXPECT_TRUE(is_type_of<int *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, &f);
      EXPECT_TRUE(is_type_of<float *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, &d);
      EXPECT_TRUE(is_type_of<double *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, &u);
      EXPECT_TRUE(is_type_of<uni *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, &c);
      EXPECT_TRUE(is_type_of<class3 *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, &cc);
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      destroy(counter, o);
    }
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    int i = 5;
    float f = 8.88f;
    double d = 9.99;
    uni u {.d = 10.11};
    class3 c {7, 5.9f, 10.88};
    const class3 cc {i, f, d};

    {
      auto o = make_pmte<int *>(counter, &i);
      EXPECT_TRUE(is_type_of<int *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<float *>(counter, &f);
      EXPECT_TRUE(is_type_of<float *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<double *>(counter, &d);
      EXPECT_TRUE(is_type_of<double *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<uni *>(counter, &u);
      EXPECT_TRUE(is_type_of<uni *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<class2 *>(counter, &c);
      EXPECT_TRUE(is_type_of<class2 *>(o));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<const class3 *>(counter, &cc, type_list<const class1 *> {});
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      destroy(counter, o);
    }

    {
      bool deleter_invoked = false;
      auto o = make_pmte(
        counter, new class3 {},
        [&](const class3 * p) {
          delete p;
          deleter_invoked = true;
        },
        type_list<const class1 *> {});
      EXPECT_TRUE(is_type_of<class3 *>(o));
      destroy(counter, o);
      EXPECT_TRUE(deleter_invoked);
    }

    {
      bool deleter_invoked = false;
      auto o = make_pmte(counter, new class3 {}, [&](const class3 * p) {
        delete p;
        deleter_invoked = true;
      });
      EXPECT_TRUE(is_type_of<class3 *>(o));
      destroy(counter, o);
      EXPECT_TRUE(deleter_invoked);
    }

    {
      bool deleter_invoked = false;
      auto o = make_pmte<class2 *>(counter, new class3 {}, [&](class2 * p) {
        delete p;
        deleter_invoked = true;
      });
      EXPECT_TRUE(is_type_of<class2 *>(o));
      destroy(counter, o);
      EXPECT_TRUE(deleter_invoked);
    }
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    {
      auto o = make_pmte(counter, new (counter.allocate(sizeof(int))) int(5));
      EXPECT_TRUE(is_type_of<int *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, new (counter.allocate(sizeof(float))) float(8.88f));
      EXPECT_TRUE(is_type_of<float *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<double *>(counter, new (counter.allocate(sizeof(double))) double(9.99));
      EXPECT_TRUE(is_type_of<double *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, new (counter.allocate(sizeof(uni))) uni {.d = 15.4});
      EXPECT_TRUE(is_type_of<uni *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, new (counter.allocate(sizeof(class3))) class3 {5, 4.0f, 8.9});
      EXPECT_TRUE(is_type_of<class3 *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<class2 *>(counter, new (counter.allocate(sizeof(class3))) class3 {5, 4.0f, 8.9});
      EXPECT_TRUE(is_type_of<class2 *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, new (counter.allocate(sizeof(class3))) class3 {5, 4.0f, 8.9}, type_list<class2 *, class1 *> {});
      EXPECT_TRUE(is_type_of<class3 *>(o));
      counter.deallocate(o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte(counter, new (counter.allocate(sizeof(class3))) std::add_const_t<class3> {5, 4.0f, 8.9});
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      counter.deallocate((void *)o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<const class2 *>(counter, new (counter.allocate(sizeof(class3))) std::add_const_t<class3> {5, 4.0f, 8.9});
      EXPECT_TRUE(is_type_of<const class2 *>(o));
      counter.deallocate((void *)o->get(), get_size(o->type()));
      destroy(counter, o);
    }

    {
      auto o = make_pmte<const class2 *>(counter, new (counter.allocate(sizeof(class3))) std::add_const_t<class3> {5, 4.0f, 8.9},
        type_list<const class1 *> {});
      EXPECT_TRUE(is_type_of<const class2 *>(o));
      counter.deallocate((void *)o->get(), get_size(o->type()));
      destroy(counter, o);
    }
  }
}
#endif

TEST(PMTE, MakeUnique) {
  {
    auto p = make_unique_pmte(5);
    EXPECT_TRUE(p);
    EXPECT_TRUE((std::is_same<decltype(p), std::unique_ptr<decltype(build_pmte(5))>>::value));
    EXPECT_TRUE(is_type_of<int>(p));
    ASSERT_NE(get_if<int>(p), nullptr);
    EXPECT_EQ(*get_if<int>(p), 5);
    EXPECT_TRUE(p->is_castable_to(type_info<int> {}));
    EXPECT_TRUE(is_castable_to<int>(p));
    EXPECT_FALSE(p->is_castable_to(type_info<double> {}));
    EXPECT_FALSE(is_castable_to<float>(p));
  }

  {
    auto p = make_unique_pmte(5.7f);
    EXPECT_TRUE(p);
    EXPECT_TRUE((std::is_same<decltype(p), std::unique_ptr<decltype(build_pmte(5.7f))>>::value));
    EXPECT_TRUE(is_type_of<float>(p));
    ASSERT_NE(get_if<float>(p), nullptr);
    EXPECT_EQ(*get_if<float>(p), 5.7f);
    EXPECT_TRUE(p->is_castable_to(type_info<float> {}));
    EXPECT_TRUE(is_castable_to<float>(p));
    EXPECT_FALSE(p->is_castable_to(type_info<double> {}));
    EXPECT_FALSE(is_castable_to<int>(p));
  }

  {
    float f = 5.7f;
    auto p = make_unique_pmte(&f);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<float *>(p));
    ASSERT_NE(get_if<float *>(p), nullptr);
    EXPECT_EQ(*get_if<float *>(p), 5.7f);
    EXPECT_TRUE(p->is_castable_to(type_info<float *> {}));
    EXPECT_TRUE(is_castable_to<float *>(p));
    EXPECT_FALSE(p->is_castable_to(type_info<double> {}));
    EXPECT_FALSE(is_castable_to<int *>(p));
  }

  {
    float f = 5.7f;
    auto p = make_unique_pmte<const float *>(&f);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const float *>(p));
    ASSERT_NE(get_if<const float *>(p), nullptr);
    EXPECT_EQ(*get_if<const float *>(p), 5.7f);
    EXPECT_TRUE(p->is_castable_to(type_info<const float *> {}));
    EXPECT_TRUE(is_castable_to<const float *>(p));
    EXPECT_FALSE(p->is_castable_to(type_info<float *> {}));
    EXPECT_FALSE(is_castable_to<const int *>(p));
  }

  {
    auto p = make_unique_pmte(class3 {5, 5.5f, 5.55});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
    EXPECT_TRUE(p->is_castable_to(type_info<class3> {}));
    EXPECT_TRUE(p->is_castable_to(type_info<const class3> {}));
    EXPECT_TRUE(is_castable_to<class3>(p));
    EXPECT_TRUE(is_castable_to<const class3>(p));
    EXPECT_FALSE(p->is_castable_to(type_info<class2> {}));
    EXPECT_FALSE(is_castable_to<class3 *>(p));
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(c, type_list<class2> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    auto p = make_unique_pmte(class3 {5, 5.5f, 5.55}, type_list<class2> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(&c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3 *>(p));
    ASSERT_NE(get_if<class3 *>(p), nullptr);
    EXPECT_EQ(get_if<class3 *>(p)->a, 5);
    EXPECT_EQ(get_if<class3 *>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3 *>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte<class2 *>(&c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class2 *>(p));
    ASSERT_NE(get_if<class2 *>(p), nullptr);
    EXPECT_NE(get_if<const class2 *>(p), nullptr);
    EXPECT_EQ(get_if<class2 *>(p)->a, 5);
    EXPECT_EQ(get_if<class2 *>(p)->f, 5.5f);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte<class2 *>(&c, type_list<class1 *> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class2 *>(p));
    ASSERT_NE(get_if<class2 *>(p), nullptr);
    EXPECT_NE(get_if<const class2 *>(p), nullptr);
    EXPECT_EQ(get_if<class3 *>(p), nullptr);
    EXPECT_EQ(get_if<class1 *>(p)->a, 5);
    EXPECT_EQ(get_if<class2 *>(p)->f, 5.5f);
  }

#if __GNUC__ >= 8
  {
    bool deleter_invoked = false;
    {
      auto p = make_unique_pmte(new class3 {5, 5.5f, 5.55}, [&](class3 * p) {
        delete p;
        deleter_invoked = true;
      });
      EXPECT_TRUE(p);
      EXPECT_TRUE(is_type_of<class3 *>(p));
      ASSERT_NE(get_if<class3 *>(p), nullptr);
      EXPECT_EQ(get_if<class3 *>(p)->a, 5);
      EXPECT_EQ(get_if<class3 *>(p)->f, 5.5f);
      EXPECT_EQ(get_if<class3 *>(p)->d, 5.55);
    }
    EXPECT_TRUE(deleter_invoked);
  }
#endif

  {
    bool deleter_invoked = false;
    {
      auto p = make_unique_pmte<class2 *>(
        new class3 {5, 5.5f, 5.55},
        [&](class2 * p) {
          delete p;
          deleter_invoked = true;
        },
        type_list<class1 *, class2 *, class3 *> {});
      EXPECT_TRUE(p);
      EXPECT_TRUE(is_type_of<class2 *>(p));

      EXPECT_EQ(p->index(type_info<class1 *> {}), 4);
      EXPECT_EQ(p->index(type_info<const class1 *> {}), 5);
      EXPECT_EQ(p->index(type_info<class2 *> {}), 2);
      EXPECT_EQ(p->index(type_info<const class2 *> {}), 3);
      EXPECT_EQ(p->index(type_info<class3 *> {}), 0);
      EXPECT_EQ(p->index(type_info<const class3 *> {}), 1);

      ASSERT_NE(get_if<class3 *>(p), nullptr);
      ASSERT_NE(get_if<class2 *>(p), nullptr);
      ASSERT_NE(get_if<class1 *>(p), nullptr);
      EXPECT_EQ(get_if<class1 *>(p)->a, 5);
      EXPECT_EQ(get_if<class2 *>(p)->f, 5.5f);
      EXPECT_EQ(get_if<class3 *>(p)->d, 5.55);
    }
    EXPECT_TRUE(deleter_invoked);
  }

  {
    auto p = make_unique_pmte(class3 {5, 5.5f, 5.55});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    ASSERT_NE(get_if<const class3>(p), nullptr);
    EXPECT_EQ(get_if<const class3>(p)->a, 5);
    EXPECT_EQ(get_if<const class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class3>(p)->d, 5.55);
  }

  {
    auto p = make_unique_pmte<class2>(class3 {5, 5.5f, 5.55});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte<class2>(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte<const class2>(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    ASSERT_NE(get_if<const class2>(p), nullptr);
    EXPECT_EQ(get_if<const class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
  }

  {
    auto p = make_unique_pmte(class3 {5, 5.5f, 5.55}, type_list<class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    EXPECT_FALSE(is_type_of<class2>(p));
    EXPECT_FALSE(is_type_of<class1>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class1>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(c, type_list<class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    EXPECT_FALSE(is_type_of<class2>(p));
    EXPECT_FALSE(is_type_of<class1>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte(c, type_list<const class2, const class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    EXPECT_FALSE(is_type_of<const class2>(p));
    EXPECT_FALSE(is_type_of<const class1>(p));
    ASSERT_NE(get_if<const class2>(p), nullptr);
    EXPECT_EQ(get_if<const class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class3>(p)->d, 5.55);
  }

  {
    auto p = make_unique_pmte<class1>(class3 {5, 5.5f, 5.55}, type_list<class1, class2, class3> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class1>(p), nullptr);
    ASSERT_NE(get_if<class2>(p), nullptr);
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte<class1>(c, type_list<class2, class1, class3> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class1>(p), nullptr);
    ASSERT_NE(get_if<class2>(p), nullptr);
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_unique_pmte<const class1>(c, type_list<const class3, const class2, const class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    ASSERT_NE(get_if<const class1>(p), nullptr);
    ASSERT_NE(get_if<const class2>(p), nullptr);
    ASSERT_NE(get_if<const class3>(p), nullptr);
    EXPECT_EQ(get_if<const class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class3>(p)->d, 5.55);
  }
}

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
TEST(PMTE, MakeUniqueWithResource) {
  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    {
      auto o = make_unique_pmte(counter, 5);
      EXPECT_TRUE(is_type_of<int>(o));
      EXPECT_EQ(counter.allocations(), 1);
      EXPECT_EQ(counter.deallocations(), 0);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      auto o = make_unique_pmte(counter, 5.7f);
      EXPECT_TRUE(is_type_of<float>(o));
      EXPECT_EQ(counter.allocations(), 2);
      EXPECT_EQ(counter.deallocations(), 1);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      auto o = make_unique_pmte(counter, 5.97);
      EXPECT_TRUE(is_type_of<double>(o));
      EXPECT_EQ(counter.allocations(), 3);
      EXPECT_EQ(counter.deallocations(), 2);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 12);
    }

    {
      auto o = make_unique_pmte(counter, enum1_value);
      EXPECT_TRUE(is_type_of<enum1>(o));
      EXPECT_EQ(counter.allocations(), 4);
      EXPECT_EQ(counter.deallocations(), 3);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      int i = 5;
      auto o = make_unique_pmte(counter, &i);
      EXPECT_TRUE(is_type_of<int *>(o));
      EXPECT_EQ(counter.allocations(), 5);
      EXPECT_EQ(counter.deallocations(), 4);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      float f = 5;
      auto o = make_unique_pmte(counter, &f);
      EXPECT_TRUE(is_type_of<float *>(o));
      EXPECT_EQ(counter.allocations(), 6);
      EXPECT_EQ(counter.deallocations(), 5);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_unique_pmte(counter, &c);
      EXPECT_TRUE(is_type_of<class3 *>(o));
      EXPECT_EQ(counter.allocations(), 7);
      EXPECT_EQ(counter.deallocations(), 6);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      const class3 c {5, 5.4f, 5.55};
      auto o = make_unique_pmte(counter, &c);
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      EXPECT_EQ(counter.allocations(), 8);
      EXPECT_EQ(counter.deallocations(), 7);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_unique_pmte(counter, &c, type_list<class2 *, class1 *> {});
      EXPECT_TRUE(is_type_of<class3 *>(o));
      EXPECT_EQ(counter.allocations(), 9);
      EXPECT_EQ(counter.deallocations(), 8);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      const class3 c {5, 5.4f, 5.55};
      auto o = make_unique_pmte(counter, &c, type_list<const class2 *, const class1 *> {});
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      EXPECT_EQ(counter.allocations(), 10);
      EXPECT_EQ(counter.deallocations(), 9);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_unique_pmte(counter, new class3 {5, 5.4f, 5.55}, [&](class3 * p) {
          delete p;
          deleter_invoked = true;
        });
        EXPECT_TRUE(is_type_of<class3 *>(o));
        EXPECT_EQ(counter.allocations(), 11);
        EXPECT_EQ(counter.deallocations(), 10);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 32 : 16);
      }
      EXPECT_TRUE(deleter_invoked);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_unique_pmte(
          counter, new class3 {5, 5.4f, 5.55},
          [&](class3 * p) {
            delete p;
            deleter_invoked = true;
          },
          type_list<class2 *, class1 *> {});
        EXPECT_TRUE(is_type_of<class3 *>(o));
        EXPECT_EQ(counter.allocations(), 12);
        EXPECT_EQ(counter.deallocations(), 11);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 32 : 16);
      }
      EXPECT_TRUE(deleter_invoked);
    }
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    {
      auto o = make_unique_pmte<double>(counter, 5);
      EXPECT_TRUE(is_type_of<double>(o));
      EXPECT_EQ(counter.allocations(), 1);
      EXPECT_EQ(counter.deallocations(), 0);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 12);
    }

    {
      auto o = make_unique_pmte<int>(counter, 5.7f);
      EXPECT_TRUE(is_type_of<int>(o));
      EXPECT_EQ(counter.allocations(), 2);
      EXPECT_EQ(counter.deallocations(), 1);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      auto o = make_unique_pmte<float>(counter, 5.97);
      EXPECT_TRUE(is_type_of<float>(o));
      EXPECT_EQ(counter.allocations(), 3);
      EXPECT_EQ(counter.deallocations(), 2);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      auto o = make_unique_pmte<enum1>(counter, enum1_value);
      EXPECT_TRUE(is_type_of<enum1>(o));
      EXPECT_EQ(counter.allocations(), 4);
      EXPECT_EQ(counter.deallocations(), 3);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      int i = 5;
      auto o = make_unique_pmte<int *>(counter, &i);
      EXPECT_TRUE(is_type_of<int *>(o));
      EXPECT_EQ(counter.allocations(), 5);
      EXPECT_EQ(counter.deallocations(), 4);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      float f = 5;
      auto o = make_unique_pmte<float *>(counter, &f);
      EXPECT_TRUE(is_type_of<float *>(o));
      EXPECT_EQ(counter.allocations(), 6);
      EXPECT_EQ(counter.deallocations(), 5);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_unique_pmte<class2 *>(counter, &c);
      EXPECT_TRUE(is_type_of<class2 *>(o));
      EXPECT_EQ(counter.allocations(), 7);
      EXPECT_EQ(counter.deallocations(), 6);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_unique_pmte<class2 *>(counter, &c, type_list<class2 *, class1 *> {});
      EXPECT_TRUE(is_type_of<class2 *>(o));
      EXPECT_EQ(counter.allocations(), 8);
      EXPECT_EQ(counter.deallocations(), 7);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 16 : 8);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_unique_pmte<class2 *>(counter, new class3 {5, 5.4f, 5.55}, [&](class2 * p) {
          delete p;
          deleter_invoked = true;
        });
        EXPECT_TRUE(is_type_of<class2 *>(o));
        EXPECT_EQ(counter.allocations(), 9);
        EXPECT_EQ(counter.deallocations(), 8);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 32 : 16);
      }
      EXPECT_TRUE(deleter_invoked);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_unique_pmte<class1 *>(
          counter, new class3 {5, 5.4f, 5.55},
          [&](class1 * p) {
            delete p;
            deleter_invoked = true;
          },
          type_list<class2 *, class1 *> {});
        EXPECT_TRUE(is_type_of<class1 *>(o));
        EXPECT_EQ(counter.allocations(), 10);
        EXPECT_EQ(counter.deallocations(), 9);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 32 : 16);
      }
      EXPECT_TRUE(deleter_invoked);
    }
  }
}
#endif

TEST(PMTE, MakeShared) {
  {
    auto p = make_shared_pmte(5);
    EXPECT_TRUE(p);
    EXPECT_TRUE((std::is_same<decltype(p), std::shared_ptr<decltype(build_pmte(5))>>::value));
    EXPECT_TRUE(is_type_of<int>(p));
    ASSERT_NE(get_if<int>(p), nullptr);
    EXPECT_EQ(*get_if<int>(p), 5);
  }

  {
    auto p = make_shared_pmte(5.7f);
    EXPECT_TRUE(p);
    EXPECT_TRUE((std::is_same<decltype(p), std::shared_ptr<decltype(build_pmte(5.7f))>>::value));
    EXPECT_TRUE(is_type_of<float>(p));
    ASSERT_NE(get_if<float>(p), nullptr);
    EXPECT_EQ(*get_if<float>(p), 5.7f);
  }

  {
    float f = 5.7f;
    auto p = make_shared_pmte(&f);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<float *>(p));
    ASSERT_NE(get_if<float *>(p), nullptr);
    EXPECT_EQ(*get_if<float *>(p), 5.7f);
  }

  {
    float f = 5.7f;
    auto p = make_shared_pmte<const float *>(&f);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const float *>(p));
    ASSERT_NE(get_if<const float *>(p), nullptr);
    EXPECT_EQ(*get_if<const float *>(p), 5.7f);
  }

  {
    auto p = make_shared_pmte(class3 {5, 5.5f, 5.55});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(c, type_list<class2> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    auto p = make_shared_pmte(class3 {5, 5.5f, 5.55}, type_list<class2> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(&c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3 *>(p));
    ASSERT_NE(get_if<class3 *>(p), nullptr);
    EXPECT_EQ(get_if<class3 *>(p)->a, 5);
    EXPECT_EQ(get_if<class3 *>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3 *>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte<class2 *>(&c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class2 *>(p));
    ASSERT_NE(get_if<class2 *>(p), nullptr);
    EXPECT_NE(get_if<const class2 *>(p), nullptr);
    EXPECT_EQ(get_if<class2 *>(p)->a, 5);
    EXPECT_EQ(get_if<class2 *>(p)->f, 5.5f);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte<class2 *>(&c, type_list<class1 *> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class2 *>(p));
    ASSERT_NE(get_if<class2 *>(p), nullptr);
    EXPECT_NE(get_if<const class2 *>(p), nullptr);
    EXPECT_EQ(get_if<class3 *>(p), nullptr);
    EXPECT_EQ(get_if<class1 *>(p)->a, 5);
    EXPECT_EQ(get_if<class2 *>(p)->f, 5.5f);
  }

#if __GNUC__ >= 8
  {
    bool deleter_invoked = false;
    {
      auto p = make_shared_pmte(new class3 {5, 5.5f, 5.55}, [&](class3 * p) {
        delete p;
        deleter_invoked = true;
      });
      EXPECT_TRUE(p);
      EXPECT_TRUE(is_type_of<class3 *>(p));
      ASSERT_NE(get_if<class3 *>(p), nullptr);
      EXPECT_EQ(get_if<class3 *>(p)->a, 5);
      EXPECT_EQ(get_if<class3 *>(p)->f, 5.5f);
      EXPECT_EQ(get_if<class3 *>(p)->d, 5.55);
    }
    EXPECT_TRUE(deleter_invoked);
  }
#endif

  {
    bool deleter_invoked = false;
    {
      auto p = make_shared_pmte<class2 *>(
        new class3 {5, 5.5f, 5.55},
        [&](class2 * p) {
          delete p;
          deleter_invoked = true;
        },
        type_list<class1 *, class3 *> {});
      EXPECT_TRUE(p);
      EXPECT_TRUE(is_type_of<class2 *>(p));
      ASSERT_NE(get_if<class3 *>(p), nullptr);
      ASSERT_NE(get_if<class2 *>(p), nullptr);
      ASSERT_NE(get_if<class1 *>(p), nullptr);
      EXPECT_EQ(get_if<class1 *>(p)->a, 5);
      EXPECT_EQ(get_if<class2 *>(p)->f, 5.5f);
      EXPECT_EQ(get_if<class3 *>(p)->d, 5.55);
    }
    EXPECT_TRUE(deleter_invoked);
  }

  {
    auto p = make_shared_pmte(class3 {5, 5.5f, 5.55});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    ASSERT_NE(get_if<const class3>(p), nullptr);
    EXPECT_EQ(get_if<const class3>(p)->a, 5);
    EXPECT_EQ(get_if<const class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class3>(p)->d, 5.55);
  }

  {
    auto p = make_shared_pmte<class2>(class3 {5, 5.5f, 5.55});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte<class2>(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte<const class2>(c);
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    ASSERT_NE(get_if<const class2>(p), nullptr);
    EXPECT_EQ(get_if<const class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
  }

  {
    auto p = make_shared_pmte(class3 {5, 5.5f, 5.55}, type_list<class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    EXPECT_FALSE(is_type_of<class2>(p));
    EXPECT_FALSE(is_type_of<class1>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(c, type_list<class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    EXPECT_FALSE(is_type_of<class2>(p));
    EXPECT_FALSE(is_type_of<class1>(p));
    ASSERT_NE(get_if<class2>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte(c, type_list<const class2, const class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    EXPECT_FALSE(is_type_of<const class2>(p));
    EXPECT_FALSE(is_type_of<const class1>(p));
    ASSERT_NE(get_if<const class2>(p), nullptr);
    EXPECT_EQ(get_if<const class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class3>(p)->d, 5.55);
  }

  {
    auto p = make_shared_pmte<class1>(class3 {5, 5.5f, 5.55}, type_list<class3, class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class1>(p), nullptr);
    ASSERT_NE(get_if<class2>(p), nullptr);
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte<class1>(c, type_list<class3, class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class1>(p), nullptr);
    ASSERT_NE(get_if<class2>(p), nullptr);
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class2>(p)->a, 5);
    EXPECT_EQ(get_if<class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }

  {
    const class3 c {5, 5.5f, 5.55};
    auto p = make_shared_pmte<const class1>(c, type_list<const class3, const class2, const class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<const class3>(p));
    EXPECT_TRUE(is_castable_to<const class1>(p));
    ASSERT_NE(get_if<const class1>(p), nullptr);
    ASSERT_NE(get_if<const class2>(p), nullptr);
    ASSERT_NE(get_if<const class3>(p), nullptr);
    EXPECT_EQ(get_if<const class2>(p)->a, 5);
    EXPECT_EQ(get_if<const class2>(p)->f, 5.5f);
    EXPECT_EQ(get_if<const class3>(p)->d, 5.55);
  }
}

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
TEST(PMTE, MakeSharedWithResource) {
  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    {
      auto o = make_shared_pmte(counter, 5);
      EXPECT_TRUE(is_type_of<int>(o));
      EXPECT_EQ(counter.allocations(), 1);
      EXPECT_EQ(counter.deallocations(), 0);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      auto o = make_shared_pmte(counter, 5.7f);
      EXPECT_TRUE(is_type_of<float>(o));
      EXPECT_EQ(counter.allocations(), 2);
      EXPECT_EQ(counter.deallocations(), 1);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      auto o = make_shared_pmte(counter, 5.97);
      EXPECT_TRUE(is_type_of<double>(o));
      EXPECT_EQ(counter.allocations(), 3);
      EXPECT_EQ(counter.deallocations(), 2);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 28);
    }

    {
      auto o = make_shared_pmte(counter, enum1_value);
      EXPECT_TRUE(is_type_of<enum1>(o));
      EXPECT_EQ(counter.allocations(), 4);
      EXPECT_EQ(counter.deallocations(), 3);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      int i = 5;
      auto o = make_shared_pmte(counter, &i);
      EXPECT_TRUE(is_type_of<int *>(o));
      EXPECT_EQ(counter.allocations(), 5);
      EXPECT_EQ(counter.deallocations(), 4);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      float f = 5;
      auto o = make_shared_pmte(counter, &f);
      EXPECT_TRUE(is_type_of<float *>(o));
      EXPECT_EQ(counter.allocations(), 6);
      EXPECT_EQ(counter.deallocations(), 5);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_shared_pmte(counter, &c);
      EXPECT_TRUE(is_type_of<class3 *>(o));
      EXPECT_EQ(counter.allocations(), 7);
      EXPECT_EQ(counter.deallocations(), 6);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      const class3 c {5, 5.4f, 5.55};
      auto o = make_shared_pmte(counter, &c);
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      EXPECT_EQ(counter.allocations(), 8);
      EXPECT_EQ(counter.deallocations(), 7);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_shared_pmte(counter, &c, type_list<class2 *, class1 *> {});
      EXPECT_TRUE(is_type_of<class3 *>(o));
      EXPECT_EQ(counter.allocations(), 9);
      EXPECT_EQ(counter.deallocations(), 8);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      const class3 c {5, 5.4f, 5.55};
      auto o = make_shared_pmte(counter, &c, type_list<const class2 *, const class1 *> {});
      EXPECT_TRUE(is_type_of<const class3 *>(o));
      EXPECT_EQ(counter.allocations(), 10);
      EXPECT_EQ(counter.deallocations(), 9);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_shared_pmte(counter, new class3 {5, 5.4f, 5.55}, [&](class3 * p) {
          delete p;
          deleter_invoked = true;
        });
        EXPECT_TRUE(is_type_of<class3 *>(o));
        EXPECT_EQ(counter.allocations(), 11);
        EXPECT_EQ(counter.deallocations(), 10);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 56 : 32);
      }
      EXPECT_TRUE(deleter_invoked);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_shared_pmte(
          counter, new class3 {5, 5.4f, 5.55},
          [&](class3 * p) {
            delete p;
            deleter_invoked = true;
          },
          type_list<class2 *, class1 *> {});
        EXPECT_TRUE(is_type_of<class3 *>(o));
        EXPECT_EQ(counter.allocations(), 12);
        EXPECT_EQ(counter.deallocations(), 11);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 56 : 32);
      }
      EXPECT_TRUE(deleter_invoked);
    }
  }

  {
    std::pmr::monotonic_buffer_resource resource;
    util::memory_resource_counter counter(&resource);

    {
      auto o = make_shared_pmte<double>(counter, 5);
      EXPECT_TRUE(is_type_of<double>(o));
      EXPECT_EQ(counter.allocations(), 1);
      EXPECT_EQ(counter.deallocations(), 0);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 28);
    }

    {
      auto o = make_shared_pmte<int>(counter, 5.7f);
      EXPECT_TRUE(is_type_of<int>(o));
      EXPECT_EQ(counter.allocations(), 2);
      EXPECT_EQ(counter.deallocations(), 1);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      auto o = make_shared_pmte<float>(counter, 5.97);
      EXPECT_TRUE(is_type_of<float>(o));
      EXPECT_EQ(counter.allocations(), 3);
      EXPECT_EQ(counter.deallocations(), 2);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      auto o = make_shared_pmte<enum1>(counter, enum1_value);
      EXPECT_TRUE(is_type_of<enum1>(o));
      EXPECT_EQ(counter.allocations(), 4);
      EXPECT_EQ(counter.deallocations(), 3);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      int i = 5;
      auto o = make_shared_pmte<int *>(counter, &i);
      EXPECT_TRUE(is_type_of<int *>(o));
      EXPECT_EQ(counter.allocations(), 5);
      EXPECT_EQ(counter.deallocations(), 4);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      float f = 5;
      auto o = make_shared_pmte<float *>(counter, &f);
      EXPECT_TRUE(is_type_of<float *>(o));
      EXPECT_EQ(counter.allocations(), 6);
      EXPECT_EQ(counter.deallocations(), 5);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_shared_pmte<class2 *>(counter, &c);
      EXPECT_TRUE(is_type_of<class2 *>(o));
      EXPECT_EQ(counter.allocations(), 7);
      EXPECT_EQ(counter.deallocations(), 6);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      class3 c {5, 5.4f, 5.55};
      auto o = make_shared_pmte<class2 *>(counter, &c, type_list<class2 *, class1 *> {});
      EXPECT_TRUE(is_type_of<class2 *>(o));
      EXPECT_EQ(counter.allocations(), 8);
      EXPECT_EQ(counter.deallocations(), 7);
      EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 40 : 24);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_shared_pmte<class2 *>(counter, new class3 {5, 5.4f, 5.55}, [&](class2 * p) {
          delete p;
          deleter_invoked = true;
        });
        EXPECT_TRUE(is_type_of<class2 *>(o));
        EXPECT_EQ(counter.allocations(), 9);
        EXPECT_EQ(counter.deallocations(), 8);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 56 : 32);
      }
      EXPECT_TRUE(deleter_invoked);
    }

    {
      bool deleter_invoked = false;
      {
        auto o = make_shared_pmte<class1 *>(
          counter, new class3 {5, 5.4f, 5.55},
          [&](class1 * p) {
            delete p;
            deleter_invoked = true;
          },
          type_list<class2 *, class1 *> {});
        EXPECT_TRUE(is_type_of<class1 *>(o));
        EXPECT_EQ(counter.allocations(), 10);
        EXPECT_EQ(counter.deallocations(), 9);
        EXPECT_EQ(counter.allocated_memory(), platform_is64bit ? 56 : 32);
      }
      EXPECT_TRUE(deleter_invoked);
    }
  }
}
#endif

TEST(PMTE, NoDefaultConstructor) {

  struct class1 {
    virtual ~class1() noexcept = default;
    explicit class1(int a_) : a(a_) {}
    int a;
  };

  struct class2 : class1 {
    explicit class2(int a_, float f_) : class1(a_), f(f_) {}
    float f;
  };

  struct class3 : class2 {
    explicit class3(int a_, float f_, double d_) : class2(a_, f_), d(d_) {}
    double d;
  };

  {
    auto p = make_shared_pmte(class3 {5, 5.5f, 5.55}, type_list<class3, class2, class1> {});
    EXPECT_TRUE(p);
    EXPECT_TRUE(is_type_of<class3>(p));
    ASSERT_NE(get_if<class3>(p), nullptr);
    EXPECT_EQ(get_if<class3>(p)->a, 5);
    EXPECT_EQ(get_if<class3>(p)->f, 5.5f);
    EXPECT_EQ(get_if<class3>(p)->d, 5.55);
  }
}

TEST(PMTE, HaveSameType) {
  {
    EXPECT_TRUE(have_same_type(type_info<int> {}, type_info<int> {}));
    EXPECT_FALSE(have_same_type(type_info<int> {}, type_info<float> {}));
  }

  {
    type_info<int> lhs;
    type_info<int> rhs;
    type_info<float> f;
    EXPECT_TRUE(have_same_type(&lhs, &rhs));
    EXPECT_FALSE(have_same_type(&lhs, &f));
  }

  {
    auto lhs = build_pmte(5);
    auto rhs = build_pmte(17);
    auto f = build_pmte(5.7f);
    EXPECT_TRUE(have_same_type(lhs, rhs));
    EXPECT_FALSE(have_same_type(lhs, f));
  }

  {
    auto lhs = make_pmte(5);
    auto rhs = make_pmte(17);
    auto f = make_pmte(5.7f);
    EXPECT_TRUE(have_same_type(lhs, rhs));
    EXPECT_FALSE(have_same_type(lhs, f));
    delete lhs;
    delete rhs;
    delete f;
  }

  {
    auto lhs = make_unique_pmte(5);
    auto rhs = make_unique_pmte(17);
    auto f = make_unique_pmte(5.7f);
    EXPECT_TRUE(have_same_type(lhs, rhs));
    EXPECT_FALSE(have_same_type(lhs, f));
  }

  {
    auto lhs = make_shared_pmte(5);
    auto rhs = make_shared_pmte(17);
    auto f = make_shared_pmte(5.7f);
    EXPECT_TRUE(have_same_type(lhs, rhs));
    EXPECT_FALSE(have_same_type(lhs, f));
  }
}
