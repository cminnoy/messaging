/**
 * @file util__debug.cpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <cstdarg>
#include <cstdio>
#include <iostream>
#include <string>
#include <thread>
#include <map>
#include <mutex>
#include <atomic>
#include <stack>
#include <chrono>
#include <sstream>
#include <algorithm>

#include <util/attributes.hpp>
#include <util/debug.hpp>
#include <util/chrono_io.hpp>
#include <util/traits.hpp>

namespace {

using namespace ::util::logger;

// clang-format off
#define CHANNEL_DEBUG   "debug"
#define CHANNEL_TRACE   "trace"
#define CHANNEL_INFO    "info"
#define CHANNEL_WARNING "warning"
#define CHANNEL_ERROR   "error"
#define CHANNEL_STATS   "stats"
#define CHANNEL_TEST    "test"

constexpr std::size_t determine_max_channel_banner_width() {
  return std::max( { sizeof(CHANNEL_DEBUG),
                     sizeof(CHANNEL_TRACE),
                     sizeof(CHANNEL_INFO),
                     sizeof(CHANNEL_WARNING),
                     sizeof(CHANNEL_ERROR),
                     sizeof(CHANNEL_STATS),
                     sizeof(CHANNEL_TEST)
                 }
        ) - 1;
}
// clang-format on

constexpr std::size_t max_channel_banner_width = determine_max_channel_banner_width();
constexpr std::size_t extra_indent = 0;

std::string time_format = "%Y/%m/%d %H:%M:%S";

std::string time_banner(std::chrono::time_point<std::chrono::system_clock> now) {
  std::ostringstream s;
  auto time = std::chrono::system_clock::to_time_t(now);
  struct tm tm;
  localtime_r(&time, &tm);
  s << std::put_time(&tm, time_format.c_str());
  return s.str();
}

std::size_t time_banner_width = time_banner(std::chrono::system_clock::now()).size();

using module_map_t = std::map<std::string /*module_name*/, std::pair<bool /*enable*/, std::string /*banner*/>>;
module_map_t & modules() {
  static module_map_t g_modules;
  return g_modules;
}

const char * const MAIN_MODULE_NAME = "global";
const char * const MAIN_MODULE = "GLB";
const std::string & g_module_name = register_module(MAIN_MODULE_NAME, MAIN_MODULE);
thread_local std::stack<module_map_t::iterator> g_active_module;

std::atomic<unsigned int> g_thread_count(0);
std::atomic<unsigned int> g_line_number(0);
thread_local auto g_thread_id = g_thread_count.fetch_add(1);
std::mutex g_output_mutex;

struct costreambuf : std::streambuf {
  std::vector<attribute> channel_attributes;
  std::string channel_txt;
  std::ostream * output_stream = &std::clog;
  bool enabled = true;
  bool allow_ansi = true;
  bool allow_indent = true;
  bool show_time = false;
  bool show_thread = false;
  bool show_module = false;
  bool show_linenumber = false;

  void indent();

#if __cplusplus >= 201703L
  std::mutex storage_lock;
#else
  std::unique_ptr<std::mutex> storage_lock = std::make_unique<std::mutex>();
#endif
  std::map<std::size_t, std::tuple<std::string /*buffer*/, bool /*ansi_attribute_detected*/>> thread_storage;
};

void costreambuf::indent() {
  bool module_enabled = true;
  if (g_active_module.empty()) {
    module_enabled = modules()[MAIN_MODULE_NAME].first;
  } else {
    module_enabled = g_active_module.top()->second.first;
  }
  if (enabled and module_enabled and allow_indent) {
    std::size_t indent = 3 + extra_indent;
    if (show_time) indent += time_banner_width + 1;
    if (show_linenumber) indent += 7;
    if (show_module) {
      if (g_active_module.empty()) { //! Take global banner if no active module
        indent += modules()[MAIN_MODULE_NAME].second.size();
      } else {
        indent += g_active_module.top()->second.second.size();
      }
      indent += 1;
    }
    if (show_thread) indent += 8 + std::to_string(g_thread_id).size();
    indent += max_channel_banner_width;
    indent += 3;

#if __cplusplus >= 201703L
    auto && [buffer, ansi_attribute_detected] = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(storage_lock);
      return thread_storage[g_thread_id];
    }();
#else
    auto & tmp = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(*storage_lock);
      return thread_storage[g_thread_id];
    }();
    auto & buffer = std::get<0>(tmp);
#endif

    buffer += std::string(indent, ' ');
  }
}

template <typename Callback>
struct callback_ostreambuf : costreambuf {
  using callback_t = Callback;

  callback_ostreambuf(Callback & cb, const char a_channel_txt[], std::vector<attribute> attributes, bool a_enabled) : callback_(cb) {
    channel_txt = a_channel_txt;
    channel_attributes = std::move(attributes);
    enabled = a_enabled;
  }

protected:

  std::streamsize xsputn(const char_type * s, std::streamsize n) override {
    bool module_enabled = true;
    if (g_active_module.empty()) {
      module_enabled = modules()[MAIN_MODULE_NAME].first;
    } else {
      module_enabled = g_active_module.top()->second.first;
    }

    if (not enabled or not module_enabled) return n;

#if __cplusplus >= 201703L
    auto && [buffer, ansi_attribute_detected] = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(storage_lock);
      return thread_storage[g_thread_id];
    }();
#else
    auto & tmp = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(*storage_lock);
      return thread_storage[g_thread_id];
    }();
    auto & buffer = std::get<0>(tmp);
    auto & ansi_attribute_detected = std::get<1>(tmp);
#endif
    std::string tokens(s, n);
    if (tokens.find("\033[")) ansi_attribute_detected = true;
    buffer.append(tokens);
    return n;
  }

  int_type overflow(int_type ch) override {
    bool module_enabled = true;
    if (g_active_module.empty()) {
      module_enabled = modules()[MAIN_MODULE_NAME].first;
    } else {
      module_enabled = g_active_module.top()->second.first;
    }

    if (not enabled or not module_enabled or ch == std::char_traits<char>::eof()) {
      return 0;
    }

#if __cplusplus >= 201703L
    auto && [buffer, ansi_attribute_detected] = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(storage_lock);
      return thread_storage[g_thread_id];
    }();
#else
    auto & tmp = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(*storage_lock);
      return thread_storage[g_thread_id];
    }();
    auto & buffer = std::get<0>(tmp);
    auto & ansi_attribute_detected = std::get<1>(tmp);
#endif

    buffer = create_banner() + buffer;
    if (ansi_attribute_detected) {
      ansi_attribute_detected = false;
      buffer.append("\033[0m");
    }
    buffer.append(1, '\n');

    //* Filter-out ANSI tokens
    if (not allow_ansi) {
      for (;;) {
        auto start_position = buffer.find("\033[");
        if (start_position == std::string::npos) break;
        auto end_position = buffer.find("m", start_position);
        if (end_position != std::string::npos) {
          buffer.erase(start_position, end_position - start_position + 1);
        }
      }
    }

    std::streamsize result = callback_(*output_stream, buffer.c_str(), buffer.size());
    buffer.clear();
    return static_cast<int_type>(result);
  }

private:

  std::string create_banner() {
    std::string buffer;
    if (show_time) {
      std::ostringstream buf;
      buf << fg_white() << italic() << time_banner(std::chrono::system_clock::now()) << plain();
      buffer.append(buf.str());
      buffer.append(" ");
    }
    if (show_linenumber) {
      buffer.append(ANSI_FG_GRAY);
      char s[12];
      snprintf(s, sizeof(s), "%06d", g_line_number.fetch_add(1));
      buffer.append(s);
      buffer.append(" ");
    }
    if (show_module) {
      buffer.append(ANSI_FG_BLUE);
      if (g_active_module.empty()) { //! Take global banner if no active module
        buffer.append(modules()[MAIN_MODULE_NAME].second);
      } else {
        buffer.append(g_active_module.top()->second.second);
      }
      buffer.append(" ");
    }
    if (show_thread) {
      buffer.append(ANSI_FG_GREEN "thread ");
      buffer.append(std::to_string(g_thread_id));
      buffer.append(" ");
    }
    buffer.append(ANSI_NRM "[");
    for (auto && att : channel_attributes) {
      buffer.append("\033[");
      buffer.append(std::to_string(att.value));
      buffer.append("m");
    }
    buffer.append(channel_txt);
    if (channel_txt.size() < max_channel_banner_width) buffer.append(std::string(max_channel_banner_width - channel_txt.size(), ' '));
    buffer.append("\033[0m] ");
    return buffer;
  }

  callback_t & callback_;
};

struct null_ostreambuf : costreambuf {
protected:
  std::streamsize xsputn(const char_type *, std::streamsize n) override { return n; }
  int_type overflow(int_type) override { return 0; }
};

template <typename Callback>
auto make_callback_ostreambuf(Callback cb, const char channel_txt[], std::vector<attribute> channel_attributes, bool enabled) {
  return callback_ostreambuf<Callback>(cb, channel_txt, channel_attributes, enabled);
}

const auto callback = [](MAYBE_UNUSED std::ostream & output_stream, const void * buf, std::streamsize sz) -> std::streamsize {
  char * const buffer = new char[sz + 1];
  std::snprintf(buffer, static_cast<int>(sz + 1), "%.*s", static_cast<int>(sz), static_cast<const char *>(buf));
  std::lock_guard<std::mutex> guard(g_output_mutex);
  output_stream << buffer;
  output_stream.flush();
  delete[] buffer;
  return sz;
};

auto debug_buf = make_callback_ostreambuf(callback, CHANNEL_DEBUG, {fg_bblue {}}, false);
auto trace_buf = make_callback_ostreambuf(callback, CHANNEL_TRACE, {fg_bmagenta {}}, false);
auto info_buf = make_callback_ostreambuf(callback, CHANNEL_INFO, {fg_bcyan {}}, true);
auto warning_buf = make_callback_ostreambuf(callback, CHANNEL_WARNING, {fg_byellow {}}, true);
auto error_buf = make_callback_ostreambuf(callback, CHANNEL_ERROR, {fg_bred {}}, true);
auto stats_buf = make_callback_ostreambuf(callback, CHANNEL_STATS, {fg_bwhite {}}, false);
auto null_buf = null_ostreambuf();
auto test_buf = make_callback_ostreambuf(callback, CHANNEL_TEST, {fg_bgreen {}}, false);

} // namespace

const std::string & module_name = g_module_name;

void util::throw_not_implemented(char const * file_name, char const * function_name, int linenumber) {
  std::string s(file_name);
  s += ":";
  s += function_name;
  s += ":";
  s += std::to_string(linenumber);
  s += " => throwing std::runtime_exception because function is not implemented!";
  throw std::runtime_error(s);
}

bool util::logger::costream::enable(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->enabled;
  buf->enabled = flag;
  return previous;
}

bool util::logger::costream::is_enabled() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return buf->enabled;
}

bool util::logger::costream::allow_ansi(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->allow_ansi;
  buf->allow_ansi = flag;
  return previous;
}

bool util::logger::costream::show_time(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_time;
  buf->show_time = flag;
  return previous;
}

bool util::logger::costream::show_thread(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_thread;
  buf->show_thread = flag;
  return previous;
}

bool util::logger::costream::show_linenumber(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_linenumber;
  buf->show_linenumber = flag;
  return previous;
}

bool util::logger::costream::show_module(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_module;
  buf->show_module = flag;
  return previous;
}

bool util::logger::costream::show_linenumber() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return buf->show_linenumber;
}

bool util::logger::costream::allow_indent(bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->allow_indent;
  buf->allow_indent = flag;
  return previous;
}

bool util::logger::costream::allow_indent() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return buf->allow_indent;
}

void util::logger::costream::indent() {
  auto buf = static_cast<costreambuf *>(rdbuf());
  buf->indent();
}

void util::logger::costream::set_stream(std::ostream & new_stream) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  buf->output_stream = &new_stream;
}

std::ostream & util::logger::costream::get_stream() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return *buf->output_stream;
}

void util::logger::costream::clear() {
  auto buf = static_cast<costreambuf *>(rdbuf());
  buf->thread_storage.clear();
}

unsigned int util::logger::costream::get_linenumber() {
  return g_line_number.load();
}

const std::string & util::logger::register_module(std::string module_name, std::string module_banner) {
  return (modules()[module_name] = std::make_pair(true, module_banner)).second;
}

void util::logger::enter_module(const std::string & module_name) {
  auto itt = modules().find(module_name);
  if (itt != modules().end()) {
    g_active_module.push(itt);
  }
}

void util::logger::leave_module() {
  if (not g_active_module.empty()) g_active_module.pop();
}

bool util::logger::enable_module(std::string module_name, bool flag) {
  auto itt = modules().find(module_name);
  if (itt != modules().end()) {
    bool old = itt->second.first;
    itt->second.first = flag;
    return old;
  }
  return false;
}

const std::string & util::logger::active_module() {
  if (g_active_module.empty()) {
    return g_module_name;
  }
  return g_active_module.top()->first;
}

util::logger::costream util::logger::debug(&debug_buf);
util::logger::costream util::logger::trace(&trace_buf);
util::logger::costream util::logger::info(&info_buf);
util::logger::costream util::logger::warning(&warning_buf);
util::logger::costream util::logger::error(&error_buf);
util::logger::costream util::logger::stats(&stats_buf);
util::logger::costream util::logger::null(&null_buf);
util::logger::costream util::logger::test(&test_buf);

std::ostream & util::logger::operator<<(std::ostream & out, util::logger::banner o) {
  if (g_active_module.empty()) { //! Take global banner if no active module
    modules()[MAIN_MODULE_NAME].second = o.value;
  } else {
    g_active_module.top()->second.second = o.value;
  }
  return out;
}

std::ostream & util::logger::operator<<(std::ostream & out, const util::logger::attribute & o) {
  out << "\033[" << o.value << 'm';
  return out;
}

std::ostream & util::logger::operator<<(std::ostream & out, const std::initializer_list<util::logger::attribute> & l) {
  for (const util::logger::attribute & a : l) util::logger::operator<<(out, a);
  return out;
}

std::ostream & util::logger::operator<<(std::ostream & out, const std::vector<util::logger::attribute> & l) {
  for (const util::logger::attribute & a : l) util::logger::operator<<(out, a);
  return out;
}
