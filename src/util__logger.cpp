/**
 * @file util__logger.cpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <cstdarg>
#include <cstdio>
#include <ctime>
#include <iostream>
#include <string>
#include <thread>
#include <map>
#include <mutex>
#include <atomic>
#include <stack>
#include <chrono>
#include <sstream>
#include <algorithm>

#include <util/attributes.hpp>
#include <util/logger.hpp>
#include <util/chrono_io.hpp>
#include <util/traits.hpp>

namespace {

using namespace ::util::logger;

// clang-format off
#define CHANNEL_DEBUG   "debug"
#define CHANNEL_TRACE   "trace"
#define CHANNEL_INFO    "info"
#define CHANNEL_WARNING "warning"
#define CHANNEL_ERROR   "error"
#define CHANNEL_STATS   "stats"
#define CHANNEL_TEST    "test"

constexpr std::size_t determine_max_channel_banner_width() {
  return std::max( { sizeof(CHANNEL_DEBUG),
                     sizeof(CHANNEL_TRACE),
                     sizeof(CHANNEL_INFO),
                     sizeof(CHANNEL_WARNING),
                     sizeof(CHANNEL_ERROR),
                     sizeof(CHANNEL_STATS),
                     sizeof(CHANNEL_TEST)
                 }
        ) - 1;
}
// clang-format on

constexpr std::size_t max_channel_banner_width = determine_max_channel_banner_width();
constexpr std::size_t extra_indent = 0;
constexpr std::size_t short_module_name_max_size = 3;

std::string time_format = "%Y/%m/%d %H:%M:%S";

std::string time_banner(std::chrono::time_point<std::chrono::system_clock> now) {
  std::ostringstream s;
  std::time_t time = std::chrono::system_clock::to_time_t(now);
  struct tm tm;
#if defined(_MSC_VER)
  localtime_s(&tm, &time);
#else
  localtime_r(&time, &tm);
#endif
  s << std::put_time(&tm, time_format.c_str());
  return s.str();
}

std::size_t time_banner_width = time_banner(std::chrono::system_clock::now()).size();

using module_map_t = std::map<std::string /*module_name*/, std::pair<bool /*enable*/, std::string /*banner*/>>;
module_map_t g_modules;
module_map_t & modules() { return g_modules; }

const char * const MAIN_MODULE_NAME = "global";
const char * const MAIN_MODULE = "GLB";
const std::string g_module_name = register_module(MAIN_MODULE_NAME, MAIN_MODULE);
thread_local std::stack<module_map_t::iterator> g_active_module;

std::atomic<unsigned int> g_thread_count(0);
std::atomic<unsigned int> g_line_number(0);
thread_local auto g_thread_id = g_thread_count.fetch_add(1);
std::mutex g_output_mutex;

struct costreambuf : std::streambuf {
  std::vector<attribute> channel_attributes;
  std::string channel_txt;
  std::ostream * output_stream = &std::clog;
  bool enabled = true;
  bool allow_ansi = true;
  bool allow_indent = true;
  bool show_time = false;
  bool show_thread = false;
  bool show_module = false;
  bool show_linenumber = false;

  void indent();

#if __cplusplus >= 201703L
  std::mutex storage_lock;
#else
  std::unique_ptr<std::mutex> storage_lock = std::make_unique<std::mutex>();
#endif
  std::map<std::size_t, std::tuple<std::string /*buffer*/, bool /*ansi_attribute_detected*/>> thread_storage;
};

void costreambuf::indent() {
  bool module_enabled;
  if (g_active_module.empty()) {
    module_enabled = modules()[MAIN_MODULE_NAME].first;
  } else {
    module_enabled = g_active_module.top()->second.first;
  }
  if (enabled and module_enabled and allow_indent) {
    std::size_t indent = 3 + extra_indent;
    if (show_time) indent += time_banner_width + 1;
    if (show_linenumber) indent += 7;
    if (show_module) {
      if (g_active_module.empty()) { //! Take global banner if no active module
        indent += modules()[MAIN_MODULE_NAME].second.size();
      } else {
        indent += g_active_module.top()->second.second.size();
      }
      indent += 1;
    }
    if (show_thread) indent += 1 + std::to_string(g_thread_count).size();
    indent += max_channel_banner_width;
    indent += 3;

#if __cplusplus >= 201703L
    auto && [buffer, ansi_attribute_detected] = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(storage_lock);
      return thread_storage[g_thread_id];
    }();
#else
    auto & tmp = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(*storage_lock);
      return thread_storage[g_thread_id];
    }();
    auto & buffer = std::get<0>(tmp);
#endif

    buffer += std::string(indent, ' ');
  }
}

template <typename Callback>
struct callback_ostreambuf : costreambuf {
  using callback_t = Callback;

  callback_ostreambuf(Callback & cb, const char a_channel_txt[], std::vector<attribute> attributes, bool a_enabled) : callback_(cb) {
    channel_txt = a_channel_txt;
    channel_attributes = std::move(attributes);
    enabled = a_enabled;
  }

protected:

  std::streamsize xsputn(const char_type * s, std::streamsize n) override {
    bool module_enabled;
    if (g_active_module.empty()) {
      module_enabled = modules()[MAIN_MODULE_NAME].first;
    } else {
      module_enabled = g_active_module.top()->second.first;
    }

    if (enabled == false or module_enabled == false) return n;

#if __cplusplus >= 201703L
    auto && [buffer, ansi_attribute_detected] = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(storage_lock);
      return thread_storage[g_thread_id];
    }();
#else
    auto & tmp = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(*storage_lock);
      return thread_storage[g_thread_id];
    }();
    auto & buffer = std::get<0>(tmp);
    auto & ansi_attribute_detected = std::get<1>(tmp);
#endif
    std::string tokens(s, n);
    if (tokens.find("\033[")) ansi_attribute_detected = true;
    buffer.append(tokens);
    return n;
  }

  int_type overflow(int_type ch) override {
    bool module_enabled;
    if (g_active_module.empty()) {
      module_enabled = modules()[MAIN_MODULE_NAME].first;
    } else {
      module_enabled = g_active_module.top()->second.first;
    }

    if (enabled == false or module_enabled == false or ch == std::char_traits<char>::eof()) {
      return 0;
    }

#if __cplusplus >= 201703L
    auto && [buffer, ansi_attribute_detected] = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(storage_lock);
      return thread_storage[g_thread_id];
    }();
#else
    auto & tmp = [this]() -> auto && {
      std::lock_guard<std::mutex> guard(*storage_lock);
      return thread_storage[g_thread_id];
    }();
    auto & buffer = std::get<0>(tmp);
    auto & ansi_attribute_detected = std::get<1>(tmp);
#endif

    if (ch != '\n') LIKELY {
      buffer.append(1, ch);
    } else {
      buffer = create_banner() + buffer;
      if (ansi_attribute_detected) {
        ansi_attribute_detected = false;
        buffer.append("\033[0m");
      }
      buffer.append(1, '\n');

      //* Filter-out ANSI tokens
      if (not allow_ansi) {
        for (;;) {
          auto start_position = buffer.find("\033[");
          if (start_position == std::string::npos) break;
          auto end_position = buffer.find("m", start_position);
          if (end_position != std::string::npos) {
            buffer.erase(start_position, end_position - start_position + 1);
          }
        }
      }

      std::streamsize result = callback_(*output_stream, buffer.c_str(), buffer.size());
      buffer.clear();
      return static_cast<int_type>(result);
    }
    return (unsigned char)ch;
  }

private:

  std::string create_banner() {
    std::string buffer;
    // time
    if (show_time) {
      std::ostringstream buf;
      buf << fg_white << italic << time_banner(std::chrono::system_clock::now()) << plain;
      buffer.append(buf.str());
      buffer.append(" ");
    }
    // line number
    if (show_linenumber) {
      buffer.append(ANSI_FG_BLACK);
      char s[12];
      std::size_t size = snprintf(s, sizeof(s), "%06d", g_line_number.fetch_add(1));
      for (std::size_t index = 0; index < sizeof(s); ++index) {
        const char c = s[index];
        if (c == 0) break;
        if (c != '0' or index == size - 1) buffer.append(ANSI_FG_WHITE ANSI_BOLD);
        buffer.append(std::string(1, c));
      }
      buffer.append(" " ANSI_NRM);
    }
    // thread id
    if (show_thread) {
      std::string const thread_txt = std::to_string(g_thread_id);
      std::size_t const thread_size = thread_txt.size();
      std::size_t const threads_size = std::to_string(g_thread_count - 1).size();
      buffer.append(ANSI_FG_GREEN);
      if (thread_size < threads_size)
        buffer.append(threads_size - thread_size, ' ');
      buffer.append(thread_txt);
      buffer.append(" ");
    }
    // short module name
    if (show_module) {
      buffer.append(ANSI_FG_BLUE);
      if (g_active_module.empty()) { //! Take short name of global if no active module
        buffer.append(modules()[MAIN_MODULE_NAME].second);
      } else {
        buffer.append(g_active_module.top()->second.second);
      }
      buffer.append(" ");
    }
    // stream name in colour
    buffer.append(ANSI_NRM "[");
    for (auto && att : channel_attributes) {
      buffer.append("\033[");
      buffer.append(std::to_string(att.value));
      buffer.append("m");
    }
    buffer.append(channel_txt);
    if (channel_txt.size() < max_channel_banner_width) buffer.append(std::string(max_channel_banner_width - channel_txt.size(), ' '));
    buffer.append("\033[0m] ");
    return buffer;
  }

  callback_t & callback_;
};

struct null_ostreambuf : costreambuf {
protected:
  std::streamsize xsputn(const char_type *, std::streamsize n) override { return n; }
  int_type overflow(int_type) override { return 0; }
};

template <typename Callback>
auto make_callback_ostreambuf(Callback cb, const char channel_txt[], std::vector<attribute> channel_attributes, bool enabled) {
  return callback_ostreambuf<Callback>(cb, channel_txt, channel_attributes, enabled);
}

const auto callback = [](MAYBE_UNUSED std::ostream & output_stream, const void * buf, std::streamsize sz) -> std::streamsize {
  std::lock_guard<std::mutex> guard(g_output_mutex);
  output_stream.write(static_cast<char const*>(buf), sz);
  output_stream.flush();
  return sz;
};

auto debug_buf = make_callback_ostreambuf(callback, CHANNEL_DEBUG, {fg_bblue}, false);
auto trace_buf = make_callback_ostreambuf(callback, CHANNEL_TRACE, {fg_bmagenta}, false);
auto info_buf = make_callback_ostreambuf(callback, CHANNEL_INFO, {fg_bcyan}, true);
auto warning_buf = make_callback_ostreambuf(callback, CHANNEL_WARNING, {fg_byellow}, true);
auto error_buf = make_callback_ostreambuf(callback, CHANNEL_ERROR, {fg_bred}, true);
auto stats_buf = make_callback_ostreambuf(callback, CHANNEL_STATS, {fg_bwhite}, false);
auto null_buf = null_ostreambuf();
auto test_buf = make_callback_ostreambuf(callback, CHANNEL_TEST, {fg_bgreen}, false);

} // namespace

namespace util {

DLL_PUBLIC void throw_not_implemented(char const * file_name, char const * function_name, int linenumber) {
  std::string s(file_name);
  s += ":";
  s += function_name;
  s += ":";
  s += std::to_string(linenumber);
  s += " => throwing std::runtime_exception because function is not implemented!";
  throw std::runtime_error(s);
}

namespace logger {

const std::string & module_name = g_module_name;

bool costream::enable(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->enabled;
  buf->enabled = flag;
  return previous;
}

bool costream::is_enabled() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return buf->enabled;
}

bool costream::allow_ansi(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->allow_ansi;
  buf->allow_ansi = flag;
  return previous;
}

bool costream::show_time(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_time;
  buf->show_time = flag;
  return previous;
}

bool costream::show_thread(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_thread;
  buf->show_thread = flag;
  return previous;
}

bool costream::show_linenumber(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_linenumber;
  buf->show_linenumber = flag;
  return previous;
}

bool costream::show_module(const bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->show_module;
  buf->show_module = flag;
  return previous;
}

bool costream::show_linenumber() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return buf->show_linenumber;
}

bool costream::allow_indent(bool flag) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  const bool previous = buf->allow_indent;
  buf->allow_indent = flag;
  return previous;
}

bool costream::allow_indent() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return buf->allow_indent;
}

void costream::indent() {
  auto buf = static_cast<costreambuf *>(rdbuf());
  buf->indent();
}

void costream::set_stream(std::ostream & new_stream) {
  auto buf = static_cast<costreambuf *>(rdbuf());
  buf->output_stream = &new_stream;
}

std::ostream & costream::get_stream() const {
  auto buf = static_cast<costreambuf *>(rdbuf());
  return *buf->output_stream;
}

void costream::clear() {
  auto buf = static_cast<costreambuf *>(rdbuf());
  buf->thread_storage.clear();
}

unsigned int costream::get_linenumber() {
  return g_line_number.load();
}

DLL_PUBLIC std::string register_module(std::string module_name) {
  return register_module(module_name, module_name);
}

DLL_PUBLIC std::string register_module(std::string module_name, std::string short_module_name) {
  short_module_name.resize(short_module_name_max_size, ' ');
  std::transform(short_module_name.begin(), short_module_name.end(), short_module_name.begin(),
    [](unsigned char c) { return std::toupper(c); });
  modules()[module_name] = std::make_pair(true, short_module_name);
  modules()[module_name].first = modules()[MAIN_MODULE_NAME].first;
  return module_name;
}

DLL_PUBLIC void unregister_module(std::string module_name) {
  if (not module_name.empty()) {
    module_map_t & mods = modules();
    mods.erase(module_name);
  }
}

DLL_PUBLIC void enter_module(const std::string & module_name) {
  auto itt = modules().find(module_name);
  if (itt != modules().end()) {
    g_active_module.push(itt);
  }
}

DLL_PUBLIC void leave_module() {
  if (not g_active_module.empty()) g_active_module.pop();
}

DLL_PUBLIC bool enable_module(std::string module_name, bool flag) {
  auto itt = modules().find(module_name);
  if (itt != modules().end()) {
    bool old = itt->second.first;
    itt->second.first = flag;
    return old;
  }
  return false;
}

DLL_PUBLIC const std::string & active_module() {
  if (g_active_module.empty()) {
    return g_module_name;
  }
  return g_active_module.top()->first;
}

costream debug(&debug_buf);
costream trace(&trace_buf);
costream info(&info_buf);
costream warning(&warning_buf);
costream error(&error_buf);
costream stats(&stats_buf);
costream null(&null_buf);
costream test(&test_buf);

DLL_PUBLIC std::ostream & operator<<(std::ostream & out, banner o) {
  if (g_active_module.empty()) { //! Take global banner if no active module
    modules()[MAIN_MODULE_NAME].second = o.value;
  } else {
    g_active_module.top()->second.second = o.value;
  }
  return out;
}

DLL_PUBLIC std::ostream & operator<<(std::ostream & out, const struct attribute & o) {
  out << "\033[" << o.value << 'm';
  return out;
}

DLL_PUBLIC std::ostream & operator<<(std::ostream & out, const std::initializer_list<attribute> & l) {
  for (const struct util::logger::attribute & a : l) operator<<(out, a);
  return out;
}

DLL_PUBLIC std::ostream & operator<<(std::ostream & out, const std::vector<struct attribute> & l) {
  for (const struct util::logger::attribute & a : l) operator<<(out, a);
  return out;
}

} // namespace logger

} // namespace util
