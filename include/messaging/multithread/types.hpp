/**
 * @file types.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__MESSAGING__MULTITHREAD__TYPES_HPP
#define INCLUDE__MESSAGING__MULTITHREAD__TYPES_HPP

#include <thread>
#include <functional>
#include <memory>

#include <util/attributes.hpp>

#ifdef WITH_MESSAGE_SET_THREAD_NAME
#include <type_traits>

// Windows
#ifdef _MSC_BUILD

#include <iso646.h>
#include <windows.h>
#include <processthreadsapi.h>

namespace messaging {

namespace details {

inline std::wstring multi2wide(const std::string & str, UINT codePage = CP_THREAD_ACP) {
  if (str.empty()) return std::wstring();

  int required = ::MultiByteToWideChar(codePage, 0, str.data(), (int)str.size(), NULL, 0);
  if (0 == required) return std::wstring();

  std::wstring str2;
  str2.resize(required);

  int converted = ::MultiByteToWideChar(codePage, 0, str.data(), (int)str.size(), &str2[0], str2.capacity());
  if (0 == converted) return std::wstring();

  return str2;
}

} // namespace details

} // namespace messaging

#else

// Linux
#include <pthread.h>

#endif /* _MSC_BUILD */

#endif /* WITH_MESSAGE_SET_THREAD_NAME */

#if defined(WITH_MESSAGE_SET_THREAD_PRIORITY) || defined(WITH_MESSAGE_SET_THREAD_AFFINITY)
#if defined(__linux__)
#include <sched.h>
#endif
#endif /* defined(WITH_MESSAGE_SET_THREAD_PRIORITY) || defined(WITH_MESSAGE_SET_THREAD_AFFINITY) */

#include <messaging/sender.hpp>
#include <messaging/naming.hpp>
#include <messaging/pump.hpp>
#include <messaging/receiver.hpp>
#include <messaging/stop_token.hpp>
#include <messaging/stop_source.hpp>
#include <messaging/dispatcher.hpp>
#include <messaging/template_dispatcher.hpp>
#include <messaging/process.hpp>
#include <messaging/broadcasting_process.hpp>
#include <messaging/multithread/message_queue.hpp>
#include <messaging/time.hpp>

namespace messaging {

struct sleep_until final {
  time_point sleep_time;
}; // struct

struct sleep_for final {
  duration sleep_duration;
}; // struct

#if defined(WITH_MESSAGE_SET_THREAD_NAME)
struct set_thread_name final {
  std::string name;
};
#endif /* WITH_SET_THREAD_NAME */

#if defined(WITH_MESSAGE_SET_THREAD_PRIORITY)
struct set_thread_priority final {
#ifdef __linux__
  int policy = SCHED_OTHER;
  sched_param param = {0};
#endif
};
#endif /* WITH_MESSAGE_SET_THREAD_PRIORITY */

#if defined(WITH_MESSAGE_SET_THREAD_AFFINITY)
struct set_thread_affinity final {
#ifdef __linux__
  cpu_set_t affinity;
#endif
};
#endif /* WITH_MESSAGE_SET_THREAD_AFFINITY */

namespace multithread {

namespace detail {

template <typename TaskType, typename FunctionType, typename YieldType>
class function_wrapper {
public:

  using task_type = TaskType;
  using function_type = FunctionType;

private:

  function_type function;
  task_type task;
  stop_state state;
  stop_source source;
  std::atomic<bool> isstarted {false};
  std::atomic<bool> isfinished {false};

  void run() {
    YieldType yield;
    isstarted.store(true);
    function(source.get_token(), yield);
    isfinished.store(true);
  }

public:

  function_wrapper(function_type function_)
  : function(std::move(function_)), task(std::bind(&function_wrapper::run, this)), source(state) {}

  ~function_wrapper() noexcept { task.join(); }

  inline bool is_started() const { return isstarted; }

  inline bool is_finished() const { return isfinished; }

  inline void push() {}

  void done() { source.request_stop(); }

  inline stop_source get_stop_source() { return source; }
};

template <typename TaskType, typename ProcessType, typename YieldType, typename SenderType>
class process_wrapper {
public:

  using task_type = TaskType;
  using process_type = ProcessType;
  using sender_type = SenderType;

private:

  YieldType yield;
  std::shared_ptr<process_type> process_ptr;
  task_type task;

  void run() { process_ptr->run(yield); }

public:

  template <typename S>
  process_wrapper(MAYBE_UNUSED S name, std::shared_ptr<process_type> process_) : process_ptr(std::move(process_)) {
#if defined(WITH_MESSAGE_SET_THREAD_NAME)
    process_ptr->get_sender().send(set_thread_name {name});
#endif
  }

  ~process_wrapper() noexcept { task.join(); }

  void start() { task = task_type(std::bind(&process_wrapper::run, this)); }

  NO_DISCARD bool is_started() const { return process_ptr->is_started(); }
  NO_DISCARD bool is_ready_for_dispatch() const { return process_ptr->is_ready_for_dispatch(); }
  NO_DISCARD bool is_waiting() const { return process_ptr->is_waiting(); }
  NO_DISCARD bool is_finished() const { return process_ptr->is_finished(); }

  inline void push() {}

  void done() { process_ptr->done(); }

  inline std::shared_ptr<process_type> get() noexcept(true) { return process_ptr; }

  inline const std::shared_ptr<process_type> get() const noexcept(true) { return process_ptr; }
};

struct thread_yield_type {
  void operator()() { std::this_thread::yield(); }
};

template <typename SenderType, typename QueueType, typename YieldType>
class heartbeat_receiver : public receiver<SenderType, QueueType, YieldType> {
public:

  using receiver<SenderType, QueueType, YieldType>::receiver;

  void set_heartbeat(typename QueueType::time_point start, typename QueueType::duration interval) {
    this->q.set_heartbeat(start, interval);
  }

  void unset_heartbeat() { this->q.unset_heartbeat(); }
};

struct sleep_until_handler {
  using message_type = messaging::sleep_until;
  static void handler(message_type & cmd) { std::this_thread::sleep_until(cmd.sleep_time); }
};

struct sleep_for_handler {
  using message_type = messaging::sleep_for;
  static void handler(message_type & cmd) { std::this_thread::sleep_for(cmd.sleep_duration); }
};

#if defined(WITH_MESSAGE_SET_THREAD_NAME)
struct set_thread_name_handler {
  using message_type = messaging::set_thread_name;

  static void handler(message_type & msg) {
    std::string name = msg.name;
#ifdef _MSC_BUILD
    MAYBE_UNUSED HRESULT r = SetThreadDescription(GetCurrentThread(), multi2wide(name));
#else
    if (name.size() > 15) // pthread limits names to 16 characters including \0
      name = name.substr(0, 15);
    pthread_t self = pthread_self();
    MAYBE_UNUSED int rc = pthread_setname_np(self, name.c_str());
#endif
  }
};
#endif /* WITH_MESSAGE_SET_THREAD_NAME */

#if defined(WITH_MESSAGE_SET_THREAD_PRIORITY)
struct set_thread_priority_handler {
  using message_type = messaging::set_thread_priority;

  static void handler(message_type & cmd) {
#ifdef __linux__
    sched_setscheduler(0, cmd.policy, &cmd.param);
#endif
  }
};
#endif /* WITH_MESSAGE_SET_THREAD_PRIORITY */

#if defined(WITH_MESSAGE_SET_THREAD_AFFINITY)
struct set_thread_affinity_handler {
  using message_type = messaging::set_thread_affinity;

  static void handler(message_type & cmd) {
#ifdef __linux__
    sched_setaffinity(0, sizeof(cmd.affinity), &cmd.affinity);
#endif
  }
};
#endif /* WITH_MESSAGE_SET_THREAD_AFFINITY */

} // namespace detail

template <typename TaskType, typename YieldType, typename DictionaryType = process_name_dictionary<>>
struct types {
  using self = types<TaskType, YieldType, DictionaryType>;

  using task_type = TaskType;
  using yield_type = YieldType;
  using dictionary_type = DictionaryType;

  using sender_type = sender_local;
  using dispatcher_type = dispatcher<multithread::queue, yield_type>;
  using receiver_type = detail::heartbeat_receiver<sender_type, multithread::queue, yield_type>;

  using function_type = std::function<void(stop_token, yield_type &)>;

  using process_type = process_base<receiver_type, sender_type, dispatcher_type, dictionary_type, detail::sleep_for_handler, detail::sleep_until_handler
#ifdef WITH_MESSAGE_SET_THREAD_NAME
    ,
    detail::set_thread_name_handler
#endif
#ifdef WITH_MESSAGE_SET_THREAD_PRIORITY
    ,
    detail::set_thread_priority_handler
#endif
#ifdef WITH_MESSAGE_SET_THREAD_AFFINITY
    ,
    detail::set_thread_affinity_handler
#endif
    >;

  using pump_type = messaging::pump<detail::function_wrapper<task_type, function_type, yield_type>,
    detail::process_wrapper<task_type, process_type, yield_type, sender_type>, dictionary_type>;
};

template <typename TaskType, typename YieldType, typename DictionaryType = process_name_dictionary<>>
struct broadcast_types {
  using self = types<TaskType, YieldType, DictionaryType>;

  using task_type = TaskType;
  using yield_type = YieldType;
  using dictionary_type = DictionaryType;

  using sender_type = sender_local;
  using dispatcher_type = dispatcher<multithread::queue, yield_type>;
  using receiver_type = detail::heartbeat_receiver<sender_type, multithread::queue, yield_type>;

  using function_type = std::function<void(stop_token, yield_type &)>;

  using process_type = broadcasting_process_base<receiver_type, sender_type, dispatcher_type, dictionary_type, detail::sleep_for_handler, detail::sleep_until_handler
#ifdef WITH_MESSAGE_SET_THREAD_NAME
    ,
    detail::set_thread_name_handler
#endif
#ifdef WITH_MESSAGE_SET_THREAD_PRIORITY
    ,
    detail::set_thread_priority_handler
#endif
#ifdef WITH_MESSAGE_SET_THREAD_AFFINITY
    ,
    detail::set_thread_affinity_handler
#endif
    >;

  using pump_type = messaging::pump<detail::function_wrapper<task_type, function_type, yield_type>,
    detail::process_wrapper<task_type, process_type, yield_type, sender_type>, dictionary_type>;
};

using std_thread_types = types<std::thread, detail::thread_yield_type>;
using std_thread_types_broadcast = broadcast_types<std::thread, detail::thread_yield_type>;

} // namespace multithread

} // namespace messaging

#endif /* INCLUDE__MESSAGING__MULTITHREAD__TYPES_HPP */
