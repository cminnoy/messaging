/**
 * @file naming.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__MESSAGING__NAMING_HPP
#define INCLUDE__MESSAGING__NAMING_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <iostream>
#include <string>
#include <functional>
#include <mutex>
#include <unordered_set>

namespace messaging {

template <typename StringType = std::string>
class process_name_dictionary {
public:
  using string_type = StringType;
  using reference_type = std::reference_wrapper<const string_type>;

private:

  using mutex_type = std::recursive_mutex;
  using lock_guard_type = std::lock_guard<mutex_type>;
  std::unordered_set<string_type> names;
  mutable mutex_type names_mutex;

public:

  reference_type add(string_type name) {
    lock_guard_type l(names_mutex);
    if (contains(name)) UNLIKELY {
        int index = 1;
        do {
          string_type suffix = string_type(".") + std::to_string(index);
          string_type new_name = name + suffix;
          if (contains(new_name)) {
            ++index;
          } else {
            names.emplace(new_name);
            name = new_name;
            break;
          }
        } while (true);
      }
    else
      LIKELY
    names.insert(name);
    return std::cref(*names.find(name));
  }

  reference_type change(string_type old_name, string_type new_name) {
    lock_guard_type l(names_mutex);
    names.remove(old_name);
    names.add(new_name);
    return std::cref(*names.find(new_name));
  }

  void remove(string_type name) {
    lock_guard_type l(names_mutex);
    names.erase(name);
  }

  bool find(string_type name, reference_type & ref) const {
    lock_guard_type l(names_mutex);
    auto itt = names.find(name);
    if (itt != names.cend()) {
      ref = std::cref(*itt);
      return true;
    }
    return false;
  }

  bool contains(string_type name) const {
    lock_guard_type l(names_mutex);
#if __cplusplus >= CPP20_STANDARD
    return names.contains(name);
#else
    return names.find(name) != names.cend();
#endif
  }

  friend std::ostream & operator<<(std::ostream & out, process_name_dictionary const & o) {
    lock_guard_type l(o.names_mutex);
    out << '{';
    bool comma = false;
    for (auto && e : o.names) {
      if (comma) out << ',';
      out << e;
      comma = true;
    }
    out << '}';
    return out;
  }
};

} // namespace messaging

#endif /* INCLUDE__MESSAGING__NAMING_HPP */
