/**
 * @file process_manager.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__MESSAGING__PROCESS_MANAGER_HPP
#define INCLUDE__MESSAGING__PROCESS_MANAGER_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#ifdef WITH_BOOST_COROUTINES
#include <messaging/coroutine/all.hpp>
#endif
#include <messaging/multithread/all.hpp>
#include <messaging/process.hpp>
#include <messaging/naming.hpp>

#include <map>
#include <tuple>
#include <utility>
#include <type_traits>

namespace messaging {

namespace detail {

template <bool...>
struct bool_pack;

template <bool... v>
using all_true = std::is_same<bool_pack<true, v...>, bool_pack<v..., true>>;

template <typename Type, typename OtherType>
struct is_really_same : std::is_same<typename std::decay<Type>::type, typename std::decay<OtherType>::type> {};

template <typename Type>
struct all_same_sender_type {
  template <typename... OtherTypes>
  struct with : std::integral_constant<bool, all_true<is_really_same<Type, typename OtherTypes::sender_type> {}...>::value> {};
};

template <typename Types, typename PumpType = typename Types::pump_type>
struct process_pump : PumpType {
  using PumpType::PumpType;
};

} // namespace detail

template <typename DictionaryType = process_name_dictionary<std::string>>
struct process_manager_interface {

  using self = process_manager_interface;
  using string_type = typename DictionaryType::string_type;
  using process_type = messaging::process;
  using sender_type = messaging::sender;

  virtual ~process_manager_interface() noexcept = default;

  NO_DISCARD virtual bool contains(string_type name) const = 0;
  NO_DISCARD virtual bool is_started(string_type name) const = 0;
  NO_DISCARD virtual bool is_ready_for_dispatch(string_type name) const = 0;
  NO_DISCARD virtual bool is_waiting(string_type name) const = 0;
  NO_DISCARD virtual bool is_finished(string_type name) const = 0;
  NO_DISCARD virtual sender get_sender(string_type name) const = 0;
  NO_DISCARD virtual bool empty() const noexcept = 0;
  NO_DISCARD virtual std::size_t size() const noexcept = 0;
  NO_DISCARD virtual process get_process(string_type name) const = 0;

  virtual std::shared_ptr<process_interface> add(string_type name, std::shared_ptr<process_interface> process) = 0;
  virtual bool start(string_type name) = 0;
  virtual void done() = 0;
};

template <typename DictionaryType, typename... ProcessTypes>
class basic_process_manager : public process_manager_interface<DictionaryType>, private detail::process_pump<ProcessTypes>... {
public:
  using self = basic_process_manager;
  using string_type = typename DictionaryType::string_type;
  using process_types = std::tuple<ProcessTypes...>;
  using pump_types = std::tuple<typename ProcessTypes::pump_type...>;
  using process_type = messaging::process;
  using sender_type = messaging::sender;

private:

  template <typename T>
  using function_type = typename T::pump_type::function_type;

  DictionaryType dictionary;

public:

  basic_process_manager() : detail::process_pump<ProcessTypes>(dictionary)... {}

  template <typename Types>
  inline auto add(string_type name, function_type<Types> function) {
    return detail::process_pump<Types>::add(name, std::move(function));
  }

  template <typename Types, typename T>
  inline std::shared_ptr<T> add(string_type name, std::shared_ptr<T> process) {
    static_assert(std::is_base_of<typename Types::process_type, T>::value, "Must be derived from process_type");
    return detail::process_pump<Types>::add(name, std::move(process));
  }

  template <typename T>
  std::shared_ptr<T> add(string_type name, std::shared_ptr<T> process) {
    if (add_(std::move(name), std::static_pointer_cast<process_interface>(process))) return process;
    return {};
  }

  inline std::shared_ptr<process_interface> add(string_type name, std::shared_ptr<process_interface> process) override final {
    return add_(std::move(name), std::move(process));
  }

  template <typename Types, template <typename PB> class PT, typename T = PT<typename Types::process_type>, typename... Args>
  inline std::shared_ptr<T> emplace_process(string_type name, Args &&... args) {
    static_assert(std::is_base_of<typename Types::process_type, T>::value, "Must be derived from process_type");
    return detail::process_pump<Types>::template emplace_process<T>(std::move(name), std::forward<Args>(args)...);
  }

  template <typename Types, typename T, typename... Args>
  inline std::shared_ptr<T> emplace_process(string_type name, Args &&... args) {
    static_assert(std::is_base_of<typename Types::process_type, T>::value, "Must be derived from process_type");
    return detail::process_pump<Types>::template emplace_process<T>(std::move(name), std::forward<Args>(args)...);
  }

  bool execute() { return execute_(); }

  NO_DISCARD inline bool contains(string_type name) const override final { return dictionary.contains(std::move(name)); }

  template <typename... Args>
  auto start(string_type name, Args &&... args) {
    return start_(name, std::forward<Args>(args)...);
  }

  inline bool start(string_type name) override final { return start_(std::move(name)); }

  NO_DISCARD inline bool is_started(string_type name) const override final { return is_started_(std::move(name)); }

  NO_DISCARD inline bool is_ready_for_dispatch(string_type name) const override final { return is_ready_for_dispatch_(std::move(name)); }

  NO_DISCARD inline bool is_waiting(string_type name) const override final { return is_waiting_(std::move(name)); }

  NO_DISCARD inline bool is_finished(string_type name) const override final { return is_finished_(std::move(name)); }

  template <typename ProcessType, typename SenderType = typename ProcessType::sender_type>
  NO_DISCARD inline SenderType get_sender(string_type name) const {
    return get_sender_<SenderType>(std::move(name));
  }

  NO_DISCARD inline sender_type get_sender(string_type name) const override final { return get_sender_<sender_type>(std::move(name)); }

  NO_DISCARD inline bool empty() const noexcept override final { return size_() != 0; }
  NO_DISCARD inline explicit operator bool() const noexcept { return empty(); }
  NO_DISCARD inline std::size_t size() const noexcept override final { return size_(); }

  /** Query function names*/
  NO_DISCARD std::vector<string_type> function_names() const { return function_names_(); }

  /** Query process names */
  NO_DISCARD std::vector<string_type> process_names() const { return process_names_(); }

  template <typename Types>
  NO_DISCARD inline const auto & get_function(string_type name) const {
    return detail::process_pump<Types>::get_function(std::move(name));
  }

  template <typename Types>
  NO_DISCARD inline auto & get_function(string_type name) {
    return detail::process_pump<Types>::get_function(std::move(name));
  }

  NO_DISCARD process get_process(string_type name) const override final { return get_process_(std::move(name)); }

  template <typename Types>
  NO_DISCARD inline const auto get_process(string_type name) const {
    return detail::process_pump<Types>::get_process(std::move(name));
  }

  template <typename Types>
  NO_DISCARD inline auto get_process(string_type name) {
    return detail::process_pump<Types>::get_process(std::move(name));
  }

  template <typename... Args>
  void done(Args &&... args) {
    done_(std::forward<Args>(args)...);
  }

  void done() override final { done_(); }

  template <typename Rep, typename Period>
  self & run_every(const std::chrono::duration<Rep, Period> & duration) {
    auto next_time_point = std::chrono::steady_clock::now() + duration;
    while (operator bool()) {
      execute();
      auto now = std::chrono::steady_clock::now();
      while (next_time_point <= now) next_time_point += duration;
      std::this_thread::sleep_until(next_time_point);
    }
    return *this;
  }

  template <typename Rep, typename Period, typename Func>
  self & run_every(const std::chrono::duration<Rep, Period> & duration, Func f) {
    auto next_time_point = std::chrono::steady_clock::now() + duration;
    while (operator bool()) {
      execute();
      f();
      auto now = std::chrono::steady_clock::now();
      while (next_time_point <= now) next_time_point += duration;
      std::this_thread::sleep_until(next_time_point);
    }
    return *this;
  }

  template <typename Msg, typename... Args>
  self & notify_all(const Msg & msg, Args &&... args) {
    notify_all_(msg, std::forward<Args>(args)...);
    return *this;
  }

  friend std::ostream & operator<<(std::ostream & out, const basic_process_manager & o) {
    out << '{';
    o.print_pump_(out);
    out << '}';
    return out;
  }

private:

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD std::shared_ptr<process_interface> add_(string_type name, std::shared_ptr<process_interface> process) {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (auto result = pump_type::add(name, process)) return result;
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      return add_<I + 1>(std::move(name), std::move(process));
    }
    return {};
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, std::shared_ptr<process_interface>>::type add_(string_type name,
    std::shared_ptr<process_interface> process) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::add(std::move(name), std::move(process));
  }

  template <std::size_t I = 0>
    typename std::enable_if <
    I<std::tuple_size<process_types>::value - 1, std::shared_ptr<process_interface>>::type add_(string_type name,
      std::shared_ptr<process_interface> process) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (auto result = pump_type::add(name, process)) return result;
    return add_<I + 1>(std::move(name), std::move(process));
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <typename Msg, std::size_t I = 0, typename... Args>
  void notify_all_(const Msg & msg, Args &&... args) {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    pump_type::notify_all(msg, std::forward<Args>(args)...);
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      notify_all_<Msg, I + 1>(msg, std::forward<Args>(args)...);
    }
  }
#else
  template <typename Msg, std::size_t I = 0, typename... Args>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, void>::type notify_all_(const Msg & msg, Args &&... args) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    pump_type::notify_all(msg, std::forward<Args>(args)...);
  }

  template <typename Msg, std::size_t I = 0, typename... Args>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, void>::type notify_all_(const Msg & msg, Args &&... args) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    pump_type::notify_all(msg);
    notify_all_<Msg, I + 1>(msg, std::forward<Args>(args)...);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  void print_pump_(std::ostream & out) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    const pump_type & pump = *this;
    out << "pump" << I << ':';
    operator<<(out, pump);
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      print_pump_<I + 1>(out << ',');
    }
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, void>::type print_pump_(std::ostream & out) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    const pump_type & pump = *this;
    out << "pump" << I << ':';
    operator<<(out, pump);
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, void>::type print_pump_(std::ostream & out) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    const pump_type & pump = *this;
    out << "pump" << I << ':';
    operator<<(out, pump);
    print_pump_<I + 1>(out << ',');
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD bool execute_() {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    bool result = pump_type::operator()();
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      result = execute_<I + 1>() ? true : result;
    }
    return result;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, bool>::type execute_() {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::operator()();
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, bool>::type execute_() {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::operator()() | execute_<I + 1>();
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <typename SenderType, std::size_t I = 0>
  NO_DISCARD SenderType get_sender_(string_type name) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    using pump_sender_type = typename pump_type::sender_type;
    if constexpr (std::is_convertible_v<pump_sender_type, SenderType>) {
      SenderType sender(pump_type::get_sender(name));
      if constexpr (I < std::tuple_size_v<process_types> - 1) {
        if (not sender) {
          sender = get_sender_<SenderType, I + 1>(name);
        }
      }
      return sender;
    } else {
      if constexpr (I < std::tuple_size_v<process_types> - 1) return get_sender_<SenderType, I + 1>(name);
      else
        return {};
    }
  }
#else
  template <typename SenderType, std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, SenderType>::type get_sender_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    using pump_sender_type = typename pump_type::sender_type;
    if (not std::is_convertible<pump_sender_type, SenderType>::value) {
      return {};
    } else {
      return pump_type::get_sender(name);
    }
  }

  template <typename SenderType, std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, SenderType>::type get_sender_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    using pump_sender_type = typename pump_type::sender_type;
    if (not std::is_convertible<pump_sender_type, SenderType>::value) {
      return get_sender_<SenderType, I + 1>(name);
    } else {
      SenderType sender(pump_type::get_sender(name));
      if (not sender) {
        sender = get_sender_<SenderType, I + 1>(name);
      }
      return sender;
    }
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD process get_process_(string_type name) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (pump_type::contains(name)) return pump_type::get_process(std::move(name));
    if constexpr (I < std::tuple_size_v<process_types> - 1) return get_process_<I + 1>(std::move(name));
    return {};
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, process>::type get_process_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::contains(name)) return pump_type::get_process(std::move(name));
    return {};
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, process>::type get_process_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::contains(name)) return pump_type::get_process(std::move(name));
    return get_process_<I + 1>(std::move(name));
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD std::size_t size_() const noexcept {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    std::size_t size = pump_type::size();
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      size += size_<I + 1>();
    }
    return size;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, std::size_t>::type size_() const noexcept {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::size();
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, std::size_t>::type size_() const noexcept {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::size() + size_<I + 1>();
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0, typename... Args>
  void done_(Args &&... args) {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    pump_type::done(std::forward<Args>(args)...);
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      done_<I + 1>(std::forward<Args>(args)...);
    }
  }
#else
  template <std::size_t I = 0, typename... Args>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, void>::type done_(Args &&... args) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    pump_type::done(std::forward<Args>(args)...);
  }

  template <std::size_t I = 0, typename... Args>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, void>::type done_(Args &&... args) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    pump_type::done(std::forward<Args>(args)...);
    done_<I + 1>(std::forward<Args>(args)...);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0, typename... Args>
  NO_DISCARD bool start_(string_type name, Args &&... args) {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (pump_type::start(name, std::forward<Args>(args)...)) return true;
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      return start_<I + 1>(name, std::forward<Args>(args)...);
    }
    return false;
  }
#else
  template <std::size_t I = 0, typename... Args>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, bool>::type start_(string_type name, Args &&... args) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::start(name, std::forward<Args>(args)...);
  }

  template <std::size_t I = 0, typename... Args>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, bool>::type start_(string_type name, Args &&... args) {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::start(name, std::forward<Args>(args)...)) return true;
    return start_<I + 1>(name, std::forward<Args>(args)...);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD bool is_started_(string_type name) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (pump_type::is_started(name)) return true;
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      return is_started_<I + 1>(name);
    }
    return false;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, bool>::type is_started_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::is_started(name);
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, bool>::type is_started_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::is_started(name)) return true;
    return is_started_<I + 1>(name);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD bool is_ready_for_dispatch_(string_type name) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (pump_type::is_ready_for_dispatch(name)) return true;
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      return is_ready_for_dispatch_<I + 1>(name);
    }
    return false;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, bool>::type is_ready_for_dispatch_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::is_ready_for_dispatch(name);
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, bool>::type is_ready_for_dispatch_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::is_ready_for_dispatch(name)) return true;
    return is_ready_for_dispatch_<I + 1>(name);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD bool is_waiting_(string_type name) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (pump_type::is_waiting(name)) return true;
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      return is_waiting_<I + 1>(name);
    }
    return false;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, bool>::type is_waiting_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::is_waiting(name);
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, bool>::type is_waiting_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::is_waiting(name)) return true;
    return is_waiting_<I + 1>(name);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD bool is_finished_(string_type name) const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    if (pump_type::is_finished(name)) return true;
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      return is_finished_<I + 1>(name);
    }
    return false;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, bool>::type is_finished_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::is_finished(name);
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, bool>::type is_finished_(string_type name) const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    if (pump_type::is_finished(name)) return true;
    return is_finished_<I + 1>(name);
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD std::vector<string_type> function_names_() const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    auto nms = pump_type::function_names();
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      auto other_nms = function_names_<I + 1>();
      nms.reserve(nms.size() + other_nms.size());
      nms.insert(std::end(nms), std::make_move_iterator(std::begin(other_nms)), std::make_move_iterator(std::end(other_nms)));
    }
    return nms;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, std::vector<string_type>>::type function_names_() const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::function_names();
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, std::vector<string_type>>::type function_names_() const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    auto nms = pump_type::function_names();
    auto other_nms = function_names_<I + 1>();
    nms.reserve(nms.size() + other_nms.size());
    nms.insert(std::end(nms), std::make_move_iterator(std::begin(other_nms)), std::make_move_iterator(std::end(other_nms)));
    return nms;
  }
#endif

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  NO_DISCARD std::vector<string_type> process_names_() const {
    using pump_type = detail::process_pump<std::tuple_element_t<I, process_types>>;
    auto nms = pump_type::process_names();
    if constexpr (I < std::tuple_size_v<process_types> - 1) {
      auto other_nms = process_names_<I + 1>();
      nms.reserve(nms.size() + other_nms.size());
      nms.insert(std::end(nms), std::make_move_iterator(std::begin(other_nms)), std::make_move_iterator(std::end(other_nms)));
    }
    return nms;
  }
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == std::tuple_size<process_types>::value - 1, std::vector<string_type>>::type process_names_() const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    return pump_type::process_names();
  }

  template <std::size_t I = 0>
    typename std::enable_if < I<std::tuple_size<process_types>::value - 1, std::vector<string_type>>::type process_names_() const {
    using pump_type = detail::process_pump<typename std::tuple_element<I, process_types>::type>;
    auto nms = pump_type::process_names();
    auto other_nms = process_names_<I + 1>();
    nms.reserve(nms.size() + other_nms.size());
    nms.insert(std::end(nms), std::make_move_iterator(std::begin(other_nms)), std::make_move_iterator(std::end(other_nms)));
    return nms;
  }
#endif
};

template <typename... ProcessTypes>
using process_manager = basic_process_manager<process_name_dictionary<std::string>, ProcessTypes...>;

} // namespace messaging

#endif /* INCLUDE__MESSAGING__PROCESS_MANAGER_HPP */
