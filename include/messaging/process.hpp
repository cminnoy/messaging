/**
 * @file process.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__MESSAGING__PROCESS_HPP
#define INCLUDE__MESSAGING__PROCESS_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <atomic>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <tuple>
#include <list>
#include <exception>
#include <functional>

#include <util/pmte.hpp>
#include <util/logger.hpp>
#include <messaging/close_queue.hpp>
#include <messaging/sender.hpp>
#include <messaging/naming.hpp>
#include <messaging/async.hpp>

#ifdef MESSAGING_CONSTEXPR
#error "MESSAGING_CONSTEXPR already defined! Aborting..."
#endif

#if __cplusplus >= CPP17_STANDARD
#define MESSAGING_CONSTEXPR constexpr
#else
#define MESSAGING_CONSTEXPR
#endif

#if __cplusplus >= CPP20_STANDARD
#include <concepts>
#endif

namespace messaging {

class process;

namespace detail {

struct function_callback {
  virtual ~function_callback() {}
  virtual void operator()() = 0;
};

struct exception_callback {
  virtual ~exception_callback() {}
  virtual void operator()(std::exception_ptr) = 0;
};

template <typename F>
struct function_model1 : function_callback {
  F func;
  function_model1(F && f) : func(std::forward<F>(f)) {}
  void operator()() override { func(); }
};

template <typename F, typename T>
struct function_model2 : function_callback {
  F func;
  T * object;
  function_model2(F && f, T * o) : func(std::forward<F>(f)), object(o) {}
  void operator()() override { func(*object); }
};

template <typename F>
struct exception_model1 : exception_callback {
  F func;
  exception_model1(F && f) : func(std::forward<F>(f)) {}
  void operator()(std::exception_ptr eptr) override { func(eptr); }
};

template <typename F, typename T>
struct exception_model2 : exception_callback {
  F func;
  T * object;
  exception_model2(F && f, T * o) : func(std::forward<F>(f)), object(o) {}
  void operator()(std::exception_ptr eptr) override { func(*object, eptr); }
};

} // namespace detail


/**
 * @brief Request process name.
 * 
 */
struct get_process_name : awaitable<std::string> {};

/**
 * @brief Generic interface for any kind of process.
 * 
 */
struct process_interface {
  friend class process;

  using self = process_interface;
  template <typename T>
  using future_type = std::future<T>;

  virtual ~process_interface() noexcept = default;

  NO_DISCARD virtual bool is_started() const noexcept = 0;
  NO_DISCARD virtual bool is_ready_for_dispatch() const noexcept = 0;
  NO_DISCARD virtual bool is_waiting() const noexcept = 0;
  NO_DISCARD virtual bool is_finished() const noexcept = 0;
  NO_DISCARD virtual bool exception_caught() const noexcept = 0;
  NO_RETURN virtual void rethrow_exception() = 0;

  NO_DISCARD virtual sender get_sender() noexcept = 0;
  NO_DISCARD virtual sender get_sender() const noexcept = 0;

  NO_DISCARD virtual std::size_t hash() const = 0;

  template <typename... Args>
  void done(Args &&... args) {
    get_sender().send(messaging::close_queue(), std::forward<Args>(args)...);
  }

  template <typename... Args>
  void done(Args &&... args) const {
    get_sender().send(messaging::close_queue(), std::forward<Args>(args)...);
  }

  template <typename RefType = void, typename Msg, typename... Args>
  self & send(Msg && msg_, Args &&... args_) {
    get_sender().template send<RefType>(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename RefType = void, typename Msg, typename... Args>
  const self & send(Msg && msg_, Args &&... args_) const {
    get_sender().template send<RefType>(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  self & on_start(std::function<void()>);
  self & on_start(std::function<void(self &)>);
  self & on_finish(std::function<void()>);
  self & on_finish(std::function<void(self &)>);
  self & on_exception(std::function<void(std::exception_ptr)>);
  self & on_exception(std::function<void(self &, std::exception_ptr)>);

  template <typename Msg, typename Func>
  self & handle(Func && f_) {
    static_assert(util::is_invocable<Func, Msg &>::value, "Func must accept type Msg as its single argument!");
    static_assert(!std::is_reference<Msg>::value, "Reference types are not allowed!");
    get_visitor().template add<Msg>(std::forward<Func>(f_));
    return *this;
  }

  template <typename Func>
  inline self & handle(Func && f_) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    using T = std::remove_reference_t<first_arg>;
    return handle<T>(std::move(f_));
  }

  template <typename Msg>
  self & remove() {
    get_visitor().template remove<Msg>();
    return *this;
  }

  template <typename Msg>
  self & remove_last() {
    get_visitor().template remove_last<Msg>();
    return *this;
  }

  friend std::ostream & operator<<(std::ostream & out, self const & o) { return o.print(out); }

protected:

  virtual void register_on_start_callback(detail::function_callback *) = 0;
  virtual void register_on_finish_callback(detail::function_callback *) = 0;
  virtual void register_on_exception_callback(detail::exception_callback *) = 0;
  virtual util::pmte::detail::visitor_base & get_visitor() = 0;
  virtual std::ostream & print(std::ostream &) const = 0;
};

template <typename StringType>
class process_interface_named : public virtual process_interface {
public:

  using self = process_interface_named<StringType>;
  using base = process_interface;
  using string_type = StringType;

  NO_DISCARD virtual string_type name() const noexcept = 0;

  //@{
  inline self & on_start(std::function<void()> f) {
    base::on_start(std::move(f));
    return *this;
  }

  self & on_start(std::function<void(self &)> f) {
    register_on_start_callback(new typename detail::template function_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  //@{
  inline self & on_finish(std::function<void()> f) {
    base::on_finish(std::move(f));
    return *this;
  }

  self & on_finish(std::function<void(self &)> f) {
    register_on_finish_callback(new typename detail::template function_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  //@{
  inline self & on_exception(std::function<void(std::exception_ptr)> f) {
    base::on_exception(std::move(f));
    return *this;
  }

  self & on_exception(std::function<void(self &, std::exception_ptr)> f) {
    register_on_exception_callback(new typename detail::template exception_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  template <typename Msg, typename Func>
  inline self & handle(Func && f_) {
    base::handle<Msg, Func>(std::forward<Func>(f_));
    return *this;
  }

  template <typename Func>
  inline self & handle(Func && f_) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    using T = std::remove_reference_t<first_arg>;
    return base::handle<T>(std::move(f_));
  }

  template <typename Msg>
  inline self & remove() {
    base::remove<Msg>();
    return *this;
  }

  template <typename Msg>
  inline self & remove_last() {
    base::remove_last<Msg>();
    return *this;
  }
};

template <typename ReceiverType, typename SenderType, typename DispatcherType, typename DictionaryType = process_name_dictionary<>, typename... StaticHandlers>
class process_base : public process_interface_named<typename DictionaryType::string_type> {
public:

  using self = process_base;
  using base = process_interface_named<DictionaryType>;
  using dictionary_type = DictionaryType;
  using string_type = typename DictionaryType::string_type;
  using name_ref_type = typename DictionaryType::reference_type;
  using receiver_type = ReceiverType;
  using sender_type = SenderType;
  using dispatcher_type = DispatcherType;
  template <typename T>
  using future_type = typename SenderType::template future_type<T>;

private:

  receiver_type receiver;
  typename dispatcher_type::visitor_type visitor;

  std::list<std::unique_ptr<detail::function_callback>> on_start_callbacks;
  std::list<std::unique_ptr<detail::function_callback>> on_finish_callbacks;
  std::list<std::unique_ptr<detail::exception_callback>> on_exception_callbacks;

  DictionaryType * dictionary {nullptr};
  bool dictionary_owned {true};
  name_ref_type process_name;

  std::exception_ptr eptr;

  std::atomic<bool> isstarted {false};
  std::atomic<bool> isreadyfordispatch {false};
  std::atomic<bool> isfinished {false};
  bool autostart;

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I>
  inline void FORCE_INLINE attach_static_handlers() {
    using static_handlers = std::tuple<StaticHandlers...>;
    using handler_type = std::tuple_element_t<I, static_handlers>;
    using message_type = typename handler_type::message_type;
    visitor.template add<message_type>(handler_type::handler);
    if constexpr (I < std::tuple_size_v<static_handlers> - 1) {
      attach_static_handlers<I + 1>();
    }
  }
#else
  template <std::size_t I = 0>
  inline typename std::enable_if<I == std::tuple_size<std::tuple<StaticHandlers...>>::value - 1, void>::type FORCE_INLINE attach_static_handlers() {
    using static_handlers = std::tuple<StaticHandlers...>;
    using handler_type = typename std::tuple_element<I, static_handlers>::type;
    using message_type = typename handler_type::message_type;
    visitor.template add<message_type>(handler_type::handler);
  }

  template <std::size_t I = 0>
    inline typename std::enable_if <
    I<std::tuple_size<std::tuple<StaticHandlers...>>::value - 1, void>::type FORCE_INLINE attach_static_handlers() {
    using static_handlers = std::tuple<StaticHandlers...>;
    using handler_type = typename std::tuple_element<I, static_handlers>::type;
    using message_type = typename handler_type::message_type;
    visitor.template add<message_type>(handler_type::handler);
    attach_static_handlers<I + 1>();
  }
#endif

protected:

  void register_on_start_callback(detail::function_callback * callback) override { on_start_callbacks.emplace_back(callback); }

  void register_on_finish_callback(detail::function_callback * callback) override { on_finish_callbacks.emplace_back(callback); }

  void register_on_exception_callback(detail::exception_callback * callback) override {
    on_exception_callbacks.emplace_back(callback);
  }

  util::pmte::detail::visitor_base & get_visitor() override { return visitor; }

  virtual void dispatch(dispatcher_type & dispatcher) { dispatcher.yield(); }

  // clang-format off
  std::ostream & print(std::ostream & out) const override {
    return out << '{'
               <<     "name:" << name()
               << "," "is_started:" << is_started()
               << "," "is_ready_for_dispatch:" << is_ready_for_dispatch()
               << "," "is_waiting:" << is_waiting()
               << "," "is_finished:" << is_finished()
               << "," "exception_caught:" << exception_caught()
               << "," "queued_messages:" << receiver.size()
               << '}';
  }
  // clang-format on

public:

#if __cplusplus >= CPP17_STANDARD
  process_base(bool auto_start = true) noexcept(false) : dictionary(new DictionaryType), process_name(dictionary->add("unset")) {
    autostart = auto_start;
    if constexpr (sizeof...(StaticHandlers) > 0) attach_static_handlers<0>();
  }

  process_base(DictionaryType & dict, name_ref_type ref, bool auto_start = true) noexcept(false)
  : dictionary(&dict), dictionary_owned(false), process_name(ref) {
    autostart = auto_start;
    if constexpr (sizeof...(StaticHandlers) > 0) attach_static_handlers<0>();
  }
#else
  template <std::size_t S = sizeof...(StaticHandlers)>
  process_base(bool auto_start = true, std::enable_if_t<0 != S> * = nullptr) noexcept(false)
  : dictionary(new DictionaryType), process_name(dictionary->add("unset")) {
    autostart = auto_start;
    attach_static_handlers<0>();
  }

  template <std::size_t S = sizeof...(StaticHandlers), typename = std::enable_if<0 == S>>
  process_base(bool auto_start = true, std::enable_if_t<0 == S> * = nullptr) noexcept(false)
  : dictionary(new DictionaryType), process_name(dictionary->add("unset")) {
    autostart = auto_start;
  }

  template <std::size_t S = sizeof...(StaticHandlers)>
  process_base(DictionaryType & dict, name_ref_type ref, bool auto_start = true, std::enable_if_t<0 != S> * = nullptr) noexcept(false)
  : dictionary(&dict), dictionary_owned(false), process_name(ref) {
    autostart = auto_start;
    attach_static_handlers<0>();
  }

  template <std::size_t S = sizeof...(StaticHandlers), typename = std::enable_if<0 == S>>
  process_base(DictionaryType & dict, name_ref_type ref, bool auto_start = true, std::enable_if_t<0 == S> * = nullptr) noexcept(false)
  : dictionary(&dict), dictionary_owned(false), process_name(ref) {
    autostart = auto_start;
  }
#endif

  process_base(process_base && other) noexcept(std::is_nothrow_move_constructible<receiver_type>::value) = delete;
  process_base(process_base const &) = delete;
  process_base & operator=(process_base &&) noexcept(std::is_nothrow_move_assignable<receiver_type>::value) = delete;
  process_base & operator=(process_base const &) = delete;

  virtual ~process_base() noexcept(std::is_nothrow_destructible<receiver_type>::value && std::is_nothrow_destructible<DictionaryType>::value) {
    if (dictionary_owned) delete dictionary;
  }

  NO_DISCARD sender get_sender() noexcept override { return sender_type(receiver); }
  NO_DISCARD sender get_sender() const noexcept override { return sender_type(receiver); }

  template <typename T = sender_type>
  NO_DISCARD inline T get_sender() noexcept {
    return T(receiver);
  }

  template <typename T = sender_type>
  NO_DISCARD inline T get_sender() const noexcept {
    return T(receiver);
  }

  NO_DISCARD inline string_type name() const noexcept override final { return process_name.get(); }
  NO_DISCARD inline bool do_auto_start() const noexcept { return autostart; }
  NO_DISCARD inline bool is_started() const noexcept override { return isstarted; }
  NO_DISCARD inline bool is_ready_for_dispatch() const noexcept override { return isreadyfordispatch; }
  NO_DISCARD inline bool is_waiting() const noexcept override { return receiver.waiting(); }
  NO_DISCARD inline bool is_finished() const noexcept override { return isfinished; }
  NO_DISCARD bool exception_caught() const noexcept override { return static_cast<bool>(eptr); }
  NO_RETURN void rethrow_exception() override { std::rethrow_exception(eptr); }
  NO_DISCARD std::size_t hash() const override { return get_sender().hash(); }

  template <typename... Args>
  void done(Args &&... args) {
    get_sender<sender_type>().send(messaging::close_queue(), std::forward<Args>(args)...);
  }

  template <typename... Args>
  void done(Args &&... args) const {
    get_sender<sender_type>().send(messaging::close_queue(), std::forward<Args>(args)...);
  }

  template <typename RefType = void, typename Msg, typename... Args>
  inline self & send(Msg && msg_, Args &&... args_) {
    get_sender<sender_type>().template send<RefType>(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename RefType = void, typename Msg, typename... Args>
  inline const self & send(Msg && msg_, Args &&... args_) const {
    get_sender<sender_type>().template send<RefType>(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename Msg, typename Func>
  inline self & handle(Func && f_) {
    static_assert(util::is_invocable<Func, Msg &>::value, "Func must accept type Msg as its single argument!");
    static_assert(!std::is_reference<Msg>::value, "Reference types are not allowed!");
    visitor.template add<Msg>(std::forward<Func>(f_));
    return *this;
  }

  template <typename Func>
  inline self & handle(Func && f_) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    using T = std::remove_reference_t<first_arg>;
    return handle<T>(std::move(f_));
  }

  template <typename Msg>
  inline self & remove() {
    visitor.template remove<Msg>();
    return *this;
  }

  template <typename Msg>
  inline self & remove_last() {
    visitor.template remove_last<Msg>();
    return *this;
  }

  //@{
  self & on_start(std::function<void()> f) {
    register_on_start_callback(new typename detail::template function_model1<decltype(f)>(std::move(f)));
    return *this;
  }

  self & on_start(std::function<void(self &)> f) {
    register_on_start_callback(new typename detail::template function_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  //@{
  self & on_finish(std::function<void()> f) {
    register_on_finish_callback(new typename detail::template function_model1<decltype(f)>(std::move(f)));
    return *this;
  }

  self & on_finish(std::function<void(self &)> f) {
    register_on_finish_callback(new typename detail::template function_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  //@{
  self & on_exception(std::function<void(std::exception_ptr)> f) {
    register_on_exception_callback(new typename detail::template exception_model1<decltype(f)>(std::move(f)));
    return *this;
  }

  self & on_exception(std::function<void(self &, std::exception_ptr)> f) {
    register_on_exception_callback(new typename detail::template exception_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  void name_overwrite(name_ref_type name, DictionaryType & dict, bool owned = false) {
    using namespace util::logger;
    unregister_module(process_name);
    if (dictionary_owned) delete dictionary;
    dictionary = &dict;
    dictionary_owned = owned;
    process_name = name;
    register_module(process_name);
  }

  template <typename... Args>
  void run(Args &&... args) try
  {
    // register extra handlers
    visitor.add([&](get_process_name & request) { request.result.set_value(process_name); });
    // exec callbacks
    isstarted.store(true);
    for (auto && callback : on_start_callbacks) (*callback)();
    on_start_callbacks.clear();
    // dispatch messages
    isreadyfordispatch.store(true);
    try {
      for (;;) {
        auto dispatcher = receiver.wait(std::forward<Args>(args)...).register_visitor(&visitor);
        dispatch(dispatcher);
      }
    } catch (messaging::close_queue &) {
    }
    isreadyfordispatch.store(false);
    // exec callbacks
    for (auto && callback : on_finish_callbacks) (*callback)();
    on_finish_callbacks.clear();
    isfinished.store(true);
  } catch (...) {
    eptr = std::current_exception();
    for (auto && callback : on_exception_callbacks) (*callback)(eptr);
    on_exception_callbacks.clear();
  }

#ifdef WITH_VISITOR_STATS
  std::size_t & lookups = visitor.lookups;
  std::size_t & hash_cache_hits = visitor.hash_cache_hits;
  std::size_t & binary_search_hits = visitor.binary_search_hits;
  std::size_t & binary_search_misses = visitor.binary_search_misses;
#endif
};

template <typename T>
#if _cpp_concepts >= CPP20_STANDARD
requires std::is_base_of<process, T>::value
#endif
inline auto get_sender(T & process) {
  return process.get_sender();
}

class process final : public process_interface {
public:

  using self = process;
  template <typename T>
  using future_type = std::future<T>;

  template <typename Process>
  process(std::shared_ptr<Process> && process__) : process_(std::forward<std::shared_ptr<Process>>(process__)) {}

  template <typename Process>
  process(std::shared_ptr<Process> const & process__) : process_(process__) {}

  process() noexcept = default;
  ~process() noexcept = default;
  process(self &&) noexcept = default;
  process(const self &) noexcept = default;
  self & operator=(self &&) noexcept = default;
  self & operator=(const self &) noexcept = default;

  NO_DISCARD explicit operator bool() const noexcept { return process_.operator bool(); }

  NO_DISCARD bool is_started() const noexcept override { return process_->is_started(); }
  NO_DISCARD bool is_ready_for_dispatch() const noexcept override { return process_->is_ready_for_dispatch(); }
  NO_DISCARD bool is_waiting() const noexcept override { return process_->is_waiting(); }
  NO_DISCARD bool is_finished() const noexcept override { return process_->is_finished(); }
  NO_DISCARD bool exception_caught() const noexcept override { return process_->exception_caught(); }
  void rethrow_exception() override { process_->rethrow_exception(); }

  NO_DISCARD virtual sender get_sender() noexcept override { return process_->get_sender(); }
  NO_DISCARD virtual sender get_sender() const noexcept override { return process_->get_sender(); }

  NO_DISCARD virtual std::size_t hash() const override { return process_->hash(); }

  template <typename... Args>
  void done(Args &&... args) {
    process_->done(std::forward<Args>(args)...);
  }

  template <typename... Args>
  void done(Args &&... args) const {
    process_->done(std::forward<Args>(args)...);
  }

  template <typename RefType = void, typename Msg, typename... Args>
  self & send(Msg && msg_, Args &&... args_) {
    process_->send<RefType>(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename RefType = void, typename Msg, typename... Args>
  const self & send(Msg && msg_, Args &&... args_) const {
    process_->send<RefType>(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename Msg, typename Func>
  self & handle(Func && f_) {
    process_->handle<Msg, Func>(std::forward<Func>(f_));
    return *this;
  }

  template <typename Func>
  self & handle(Func && f_) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    using T = std::remove_reference_t<first_arg>;
    process_->handle<T>(std::move(f_));
    return *this;
  }

  template <typename Msg>
  self & remove() {
    process_->remove<Msg>();
    return *this;
  }

  template <typename Msg>
  self & remove_last() {
    process_->remove_last<Msg>();
    return *this;
  }

  self & on_start(std::function<void()>);
  self & on_start(std::function<void(self &)>);
  self & on_finish(std::function<void()>);
  self & on_finish(std::function<void(self &)>);
  self & on_exception(std::function<void(std::exception_ptr)>);
  self & on_exception(std::function<void(self &, std::exception_ptr)>);

  /**
   * @brief Query the name of the process.
   * 
   * Retrieves the name of the process if the underlying process supports the requested string type; otherwise throws std::bad_cast.
   * 
   * @tparam StringType The string type to request.
   * @return If succesful returns the name of the process.
   */
  template <typename StringType>
  NO_DISCARD StringType name() const {
    auto ni = std::dynamic_pointer_cast<process_interface_named<StringType>>(process_);
    if (ni) return ni->name();
    else
      throw std::bad_cast();
    return {};
  }

  /**
   * @brief Attach an observer.
   * 
   * Attaches an observer if the underlying process is broadcast cabable; otherwise throws std::bad_cast.
   * 
   * @param observer The observer to attach
   * @return self& 
   */
  self & attach_observer(sender observer);

  /**
   * @brief Detach an observer if the underlying process is broadcast cabable; otherwise throws std::bad_cast.
   * 
   * @param observer The observer to detach
   * @param notify If true the observer being detached is notified by the message 'observer_detached'.
   * @return self& 
   */
  self & detach_observer(sender observer, bool notify = true);

  inline self & then() & noexcept(true) { return *this; }

  inline const self & then() const & noexcept(true) { return *this; }

  inline self && then() && noexcept(true) { return std::move(*this); }

  inline const self && then() const && noexcept(true) { return std::move(*this); }

  self & then(std::function<void()> f) & {
    if (operator bool()) f();
    return *this;
  }

  const self & then(std::function<void()> f) const & {
    if (operator bool()) f();
    return *this;
  }

  self && then(std::function<void()> f) && {
    if (operator bool()) f();
    return std::move(*this);
  }

  const self && then(std::function<void()> f) const && {
    if (operator bool()) f();
    return std::move(*this);
  }

  self & then(std::function<void(self &)> f) & {
    if (operator bool()) f(std::forward<self &>(*this));
    return *this;
  }

  const self & then(std::function<void(const self &)> f) const & {
    if (operator bool()) f(*this);
    return *this;
  }

  self && then(std::function<void(self &&)> f) && {
    if (operator bool()) f(std::forward<self &&>(*this));
    return std::move(*this);
  }

  const self && then(std::function<void(const self &&)> f) const && {
    if (operator bool()) f(std::forward<const self &&>(*this));
    return std::move(*this);
  }

  self & or_else(std::function<void()> f) & {
    if (not operator bool()) f();
    return *this;
  }

  const self & or_else(std::function<void()> f) const & {
    if (not operator bool()) f();
    return *this;
  }

  self && or_else(std::function<void()> f) && {
    if (not operator bool()) f();
    return std::move(*this);
  }

  const self && or_else(std::function<void()> f) const && {
    if (not operator bool()) f();
    return std::move(*this);
  }

  self & or_else(std::function<void(self &)> f) & {
    if (not operator bool()) f(*this);
    return *this;
  }

  const self & or_else(std::function<void(const self &)> f) const & {
    if (not operator bool()) f(*this);
    return *this;
  }

  self && or_else(std::function<void(self &&)> f) && {
    if (not operator bool()) f(std::forward<self &&>(*this));
    return std::move(*this);
  }

  const self && or_else(std::function<void(const self &&)> f) const && {
    if (not operator bool()) f(std::forward<const self &&>(*this));
    return std::move(*this);
  }

  template <typename Exception = std::runtime_error>
  self & or_throw(Exception exception = Exception("sender is null")) & noexcept(false) {
    if (not operator bool()) throw exception;
    return *this;
  }

  template <typename Exception = std::runtime_error>
  const self & or_throw(Exception exception = Exception("sender is null")) const & noexcept(false) {
    if (not operator bool()) throw exception;
    return *this;
  }

  template <typename Exception = std::runtime_error>
  self && or_throw(Exception exception = Exception("sender is null")) && noexcept(false) {
    if (not operator bool()) throw exception;
    return std::move(*this);
  }

  template <typename Exception = std::runtime_error>
  const self && or_throw(Exception exception = Exception("sender is null")) const && noexcept(false) {
    if (not operator bool()) throw exception;
    return std::move(*this);
  }

  self & or_throw(const char * const text) & noexcept(false) {
    if (not operator bool()) throw std::runtime_error(text);
    return *this;
  }

  const self & or_throw(const char * const text) const & noexcept(false) {
    if (not operator bool()) throw std::runtime_error(text);
    return *this;
  }

  self && or_throw(const char * const text) && noexcept(false) {
    if (not operator bool()) throw std::runtime_error(text);
    return std::move(*this);
  }

  const self && or_throw(const char * const text) const && noexcept(false) {
    if (not operator bool()) throw std::runtime_error(text);
    return std::move(*this);
  }

  bool operator==(process const & other) {
    const std::size_t hash1 = process_ ? process_->hash() : 0;
    const std::size_t hash2 = other.process_ ? other.process_->hash() : 0;
    return process_.get() == other.process_.get() or hash1 == hash2;
  }

private:

  void register_on_start_callback(detail::function_callback * p) override { process_->register_on_start_callback(p); }
  void register_on_finish_callback(detail::function_callback * p) override { process_->register_on_finish_callback(p); }
  void register_on_exception_callback(detail::exception_callback * p) override { process_->register_on_exception_callback(p); }
  util::pmte::detail::visitor_base & get_visitor() override { return process_->get_visitor(); }
  std::ostream & print(std::ostream & out) const override { return process_->print(out); }

  std::shared_ptr<process_interface> process_;
};

} // namespace messaging

#undef MESSAGING_CONSTEXPR

#endif /* INCLUDE__MESSAGING__PROCESS_HPP */
