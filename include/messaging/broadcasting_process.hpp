/**
 * @file enhanced_process.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__MESSAGING__BROADCASTING_PROCESS_HPP
#define INCLUDE__MESSAGING__BROADCASTING_PROCESS_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <messaging/process.hpp>

// C++
#include <memory>
#include <forward_list>

namespace messaging {

struct attach_observer {
  sender observer;
};

struct detach_observer {
  sender observer;
  bool notify;
};

struct observer_detached {
  sender subject;
};

struct broadcasting_process_interface {
  using self = broadcasting_process_interface;

  virtual ~broadcasting_process_interface() noexcept = default;
  virtual self & attach_observer(sender observer) = 0;
  virtual self & detach_observer(sender observer, bool notify) = 0;
};

template <typename ReceiverType, typename SenderType, typename DispatcherType, typename DictionaryType = process_name_dictionary<>, typename... StaticHandlers>
class broadcasting_process_base
: public broadcasting_process_interface,
  public process_base<ReceiverType, SenderType, DispatcherType, DictionaryType, StaticHandlers...> {
public:

  using self = broadcasting_process_base;
  using base = process_base<ReceiverType, SenderType, DispatcherType, DictionaryType, StaticHandlers...>;
  using name_ref_type = typename DictionaryType::reference_type;
  using receiver_type = ReceiverType;
  using sender_type = SenderType;
  using dispatcher_type = DispatcherType;

  broadcasting_process_base(bool auto_start = true)
  : process_base<ReceiverType, SenderType, DispatcherType, DictionaryType, StaticHandlers...>(auto_start) {
    using attach_type = messaging::attach_observer;
    using detach_type = messaging::detach_observer;
    this->template handle<attach_type>([&](attach_type const & command) { this->attach_observer(command.observer); });
    this->template handle<detach_type>([&](detach_type const & command) { this->detach_observer(command.observer, command.notify); });
  }

  broadcasting_process_base(DictionaryType & dict, name_ref_type ref, bool auto_start = true)
  : process_base<ReceiverType, SenderType, DispatcherType, DictionaryType, StaticHandlers...>(dict, ref, auto_start) {
    using attach_type = messaging::attach_observer;
    using detach_type = messaging::detach_observer;
    this->template handle<attach_type>([&](attach_type const & command) { this->attach_observer(command.observer); });
    this->template handle<detach_type>([&](detach_type const & command) { this->detach_observer(command.observer, command.notify); });
    this->on_finish([&]() {
      std::for_each(begin(observers), end(observers),
        [&](sender & observer) { observer.send(observer_detached {this->template get_sender<sender_type>()}); });
    });
  }

  template <typename Msg, typename... Args>
  inline self & send(Msg && msg_, Args &&... args_) {
    this->base::send(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename Msg, typename... Args>
  inline const self & send(Msg && msg_, Args &&... args_) const {
    this->base::send(std::forward<Msg>(msg_), std::forward<Args>(args_)...);
    return *this;
  }

  template <typename Msg, typename Func>
  inline self & handle(Func && f_) {
    this->base::template handle<Msg, Func>(std::forward<Func>(f_));
    return *this;
  }

  template <typename Func>
  inline self & handle(Func && f_) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    using T = std::remove_reference_t<first_arg>;
    return this->base::template handle<T>(std::move(f_));
  }

  template <typename Msg>
  inline self & remove() {
    this->base::template remove<Msg>();
    return *this;
  }

  template <typename Msg>
  inline self & remove_last() {
    this->base::template remove_last<Msg>();
    return *this;
  }

  //@{
  inline self & on_start(std::function<void()> f) {
    this->base::on_start(std::move(f));
    return *this;
  }

  inline self & on_start(std::function<void(self &)> f) {
    this->base::register_on_start_callback(new typename detail::template function_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  //@{
  inline self & on_finish(std::function<void()> f) {
    this->base::on_finish(std::move(f));
    return *this;
  }

  self & on_finish(std::function<void(self &)> f) {
    this->base::register_on_finish_callback(new typename detail::template function_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  //@{
  inline self & on_exception(std::function<void(std::exception_ptr)> f) {
    this->base::on_exception(std::move(f));
    return *this;
  }

  self & on_exception(std::function<void(self &, std::exception_ptr)> f) {
    this->base::register_on_exception_callback(new typename detail::template exception_model2<decltype(f), self>(std::move(f), this));
    return *this;
  }
  //@}

  /**
   * @brief Notifiy all the observers of this process.
   * @note Preferably only the process itself uses these functions.
   */
  //@{
  template <typename Msg, typename... Args>
  self & notify_observers(Msg && msg, Args &&... args) {
    for (auto && observer : observers) {
      observer.send(std::remove_reference_t<Msg>(msg), std::forward<Args>(args)...);
    }
    return *this;
  }

  template <typename Msg, typename... Args>
  self & notify_observers(Msg const & msg, Args &&... args) {
    for (auto && observer : observers) {
      observer.send(msg, std::forward<Args>(args)...);
    }
    return *this;
  }
  //@}

  /**
   * @brief Register an observer.
   * 
   * @note Prefer sending the message 'attach_observer' from outside the process.
   * @param observer The observer to register.
   * @return self&
   */
  self & attach_observer(sender observer) override final {
    observers.push_front(observer);
    return *this;
  }

  /**
   * @brief Unregister an observer.
   * 
   * @note Prefer sending the message 'detach_observer' from outside the process.
   * @param observer The observer to unregister.
   * @param notify If true send a message to the observer that it is being unregistered.
   * @return self& 
   */
  self & detach_observer(sender observer, bool notify = true) override final {
    if (notify) observer.send(observer_detached {this->template get_sender<sender_type>()});
    observers.remove(observer);
    return *this;
  }

private:

  std::forward_list<sender> observers;
};

} // namespace messaging

#endif /* INCLUDE__MESSAGING__BROADCASTING_PROCESS_HPP */
