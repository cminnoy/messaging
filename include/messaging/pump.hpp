/**
 * @file pump.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__MESSAGING__PUMP_HPP
#define INCLUDE__MESSAGING__PUMP_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <iostream>
#include <string>
#include <memory>
#include <functional>
#include <type_traits>
#include <vector>
#include <unordered_map>
#include <exception>
#include <mutex>

#include <util/attributes.hpp>
#include <messaging/naming.hpp>
#include <messaging/sender.hpp>
#include <messaging/process.hpp>

namespace messaging {

template <typename FunctionWrapper, typename ProcessWrapper, typename DictionaryType = process_name_dictionary<>>
class pump {
public:
  using string_type = typename DictionaryType::string_type;
  using name_ref_type = typename DictionaryType::reference_type;

  using function_type = typename FunctionWrapper::function_type;
  using process_type = typename ProcessWrapper::process_type;
  using sender_type = typename ProcessWrapper::sender_type;

private:

  struct hasher {
    std::size_t operator()(name_ref_type const & o) const noexcept {
      std::hash<string_type> h {};
      return h(o.get());
    }
  };

  struct key_equal {
    bool operator()(name_ref_type const & lhs, name_ref_type const & rhs) const noexcept { return lhs.get() == rhs.get(); }
  };

  std::unordered_map<name_ref_type, std::unique_ptr<FunctionWrapper>, hasher, key_equal> functions;
  std::unordered_map<name_ref_type, std::unique_ptr<ProcessWrapper>, hasher, key_equal> processes;

  mutable std::recursive_mutex functions_mutex;
  mutable std::recursive_mutex processes_mutex;
  mutable std::atomic<bool> functions_iterators_invalid;
  mutable std::atomic<bool> processes_iterators_invalid;
  using lock_guard_type = std::lock_guard<std::recursive_mutex>;

  template <typename UnorderedMap>
  static bool will_rehash_on_insert(UnorderedMap const & um) {
    return um.size() == um.max_load_factor() * um.bucket_count();
  }

#if __cplusplus >= CPP17_STANDARD
  inline static constexpr bool is_nothrow_default_constructible_v = std::is_nothrow_default_constructible_v<decltype(functions)> and
    std::is_nothrow_default_constructible_v<decltype(processes)> and std::is_nothrow_default_constructible_v<std::recursive_mutex> and
    std::is_nothrow_default_constructible_v<std::atomic<bool>>;
  inline static constexpr bool is_move_assignable_v = std::is_nothrow_move_assignable_v<decltype(functions)> and
    std::is_nothrow_move_assignable_v<decltype(processes)>;
  inline static constexpr bool is_nothrow_move_constructible_v = std::is_nothrow_move_constructible_v<decltype(functions)> and
    std::is_nothrow_move_constructible_v<decltype(processes)>;
  inline static constexpr bool is_nothrow_destructable_v = std::is_nothrow_destructible_v<decltype(functions)> and
    std::is_nothrow_destructible_v<decltype(processes)> and std::is_nothrow_destructible_v<std::recursive_mutex> and
    std::is_nothrow_destructible_v<std::atomic<bool>> and std::is_nothrow_destructible_v<DictionaryType>;
#else
  using is_nothrow_default_constructible = std::integral_constant<bool,
    std::is_nothrow_default_constructible<decltype(functions)>::value and std::is_nothrow_default_constructible<decltype(processes)>::value and
      std::is_nothrow_default_constructible<std::recursive_mutex>::value and std::is_nothrow_default_constructible<std::atomic<bool>>::value>;
  using is_move_assignable = std::integral_constant<bool,
    std::is_nothrow_move_assignable<decltype(functions)>::value and std::is_nothrow_move_assignable<decltype(processes)>::value>;
  using is_nothrow_move_constructible = std::integral_constant<bool,
    std::is_nothrow_move_constructible<decltype(functions)>::value and std::is_nothrow_move_constructible<decltype(processes)>::value>;
  using is_nothrow_destructable = std::integral_constant<bool,
    std::is_nothrow_destructible<decltype(functions)>::value and std::is_nothrow_destructible<decltype(processes)>::value and
      std::is_nothrow_destructible<std::recursive_mutex>::value and std::is_nothrow_destructible<std::atomic<bool>>::value and
      std::is_nothrow_destructible<DictionaryType>::value>;
  enum { is_nothrow_default_constructible_v = is_nothrow_default_constructible::value };
  enum { is_move_assignable_v = is_move_assignable::value };
  enum { is_nothrow_move_constructible_v = is_nothrow_move_constructible::value };
  enum { is_nothrow_destructable_v = is_nothrow_destructable::value };
#endif

public:

  pump() noexcept(false);
  pump(DictionaryType & dict) noexcept(is_nothrow_default_constructible_v);
  pump(const pump &) = delete;
  pump(pump &&) noexcept(is_nothrow_move_constructible_v);
  pump & operator=(const pump &) = delete;
  pump & operator=(pump &&) noexcept(is_move_assignable_v);
  ~pump() noexcept(is_nothrow_destructable_v);

  /** Call each process once. */
  bool operator()();
  /** Query if there are still processes not finished. */
  NO_DISCARD explicit operator bool() const noexcept;
  /** Query if there are no more processes running. */
  NO_DISCARD bool operator!() { return not operator bool(); }
  /** Add a function like process to the list. */
  auto add(string_type name, function_type && function);
  /** Add an object like process to the list. */
  template <typename T = process_type>
  std::shared_ptr<T> add(string_type name, std::shared_ptr<T> process);
  /** Add an object like process to the list.
      Ignores instances without matching pump; returns null if this is so otherwise a pointer to instance.
   */
  std::shared_ptr<process_type> add(string_type name, std::shared_ptr<process_interface> process);
  /** Efficiently create and add a process to the list. */
  template <typename T = process_type, typename... Args>
  std::shared_ptr<T> emplace_process(string_type name, Args &&... args);
  /** Query if an entity with that name exists. */
  NO_DISCARD bool contains(string_type name) const;
  /** Start process */
  template <typename... Args>
  bool start(string_type name, Args &&... args);
  /** Query if an entity has started execution. */
  NO_DISCARD bool is_started(string_type name) const;
  /** Query if an entity is ready to accept messages. */
  NO_DISCARD bool is_ready_for_dispatch(string_type name) const;
  /** Query if an entity is waiting for messages to arrive. */
  NO_DISCARD bool is_waiting(string_type name) const;
  /** Query if an entity has finished execution. */
  NO_DISCARD bool is_finished(string_type name) const;
  /** Query function names*/
  NO_DISCARD std::vector<string_type> function_names() const;
  /** Query process names */
  NO_DISCARD std::vector<string_type> process_names() const;
  /** Query for a function. */
  NO_DISCARD const auto & get_function(string_type name) const;
  /** Query for a process. */
  NO_DISCARD const auto get_process(string_type name) const;
  /** Query for a function. */
  NO_DISCARD auto & get_function(string_type name);
  /** Query for a process. */
  NO_DISCARD auto get_process(string_type name);
  /** Query amount of processes active. */
  NO_DISCARD std::size_t size() const noexcept;
  /** Query sender. */
  NO_DISCARD sender_type get_sender(string_type name) const;
  /** Broadcast 'close queue' message to all processes in this pump. */
  template <typename... Args>
  void done(Args &&... args);
  /** Notify all processes in this pump. */
  template <typename Msg, typename... Args>
  void notify_all(const Msg & msg, Args &&... args);

  friend std::ostream & operator<<(std::ostream & out, const pump & o) {
    out << "{proc:{";
    {
      bool comma = false;
      lock_guard_type l(o.processes_mutex);
      for (auto && entry : o.processes) {
        if (comma) out << ',';
        out << '"' << entry.first.get() << '"';
        comma = true;
      }
    }
    out << "},func:{";
    {
      bool comma = false;
      lock_guard_type l(o.functions_mutex);
      for (auto && entry : o.functions) {
        if (comma) out << ',';
        out << '"' << entry.first.get() << '"';
        comma = true;
      }
    }
    out << "}}";
    return out;
  }

private:

  DictionaryType * dictionary {nullptr};
  bool dictionary_owned {true};

  NO_DISCARD std::shared_ptr<process_type> add_(name_ref_type name_ref, std::shared_ptr<process_type> process);
};

template <typename F, typename P, typename D>
pump<F, P, D>::pump() noexcept(false) : dictionary(new D) {}

template <typename F, typename P, typename D>
pump<F, P, D>::pump(D & dictionary_) noexcept(is_nothrow_default_constructible_v) : dictionary(&dictionary_), dictionary_owned(false) {}

template <typename F, typename P, typename D>
pump<F, P, D>::pump(pump && other) noexcept(is_nothrow_move_constructible_v)
: dictionary(other.dictionary), dictionary_owned(other.dictionary_owned), functions(std::move(other.functions)),
  processes(std::move(other.processes)) {
  other.dictionary = nullptr;
  other.dictionary_owned = false;
}

template <typename F, typename P, typename D>
pump<F, P, D> & pump<F, P, D>::operator=(pump && other) noexcept(is_move_assignable_v) {
  if (this != &other) {
    if (dictionary_owned) delete dictionary;
    dictionary = other.dictionary;
    dictionary_owned = other.dictionary_owned;
    functions = std::move(other.functions);
    processes = std::move(other.processes);
    other.dictionary = nullptr;
    other.dictionary_owned = false;
  }
  return *this;
}

template <typename F, typename P, typename D>
pump<F, P, D>::~pump() noexcept(is_nothrow_destructable_v) {
  if (dictionary_owned) delete dictionary;
}

template <typename F, typename P, typename D>
bool pump<F, P, D>::operator()() {
  bool run = false;

  //* Execute processes
  {
    lock_guard_type l(processes_mutex);
    processes_iterators_invalid.store(false);
    typename decltype(processes)::iterator itt = processes.begin();
    typename decltype(processes)::iterator const end = processes.end();
    while (itt != end) {
      auto & wrapper = *itt->second;
      if (wrapper.is_finished()) UNLIKELY {
          itt = processes.erase(itt);
        }
      else
        LIKELY {
          run = true;
          wrapper.push();
          if (processes_iterators_invalid.load()) {
            break;
          }
          itt = std::next(itt);
        }
    }
  }

  //* Execute functions
  {
    lock_guard_type l(functions_mutex);
    functions_iterators_invalid.store(false);
    typename decltype(functions)::iterator itt = functions.begin();
    typename decltype(functions)::iterator const end = functions.end();
    while (itt != end) {
      auto & wrapper = *itt->second;
      if (wrapper.is_finished()) UNLIKELY {
          itt = functions.erase(itt);
        }
      else
        LIKELY {
          run = true;
          wrapper.push();
          if (functions_iterators_invalid.load()) {
            break;
          }
          itt = std::next(itt);
        }
    }
  }

  return run;
}

template <typename F, typename P, typename D>
inline pump<F, P, D>::operator bool() const noexcept {
  return size() != 0;
}

template <typename F, typename P, typename D>
auto pump<F, P, D>::add(string_type name, function_type && function) {
  auto name_ref = dictionary->add(name);
  std::pair<typename decltype(functions)::iterator, bool> result;
  if (will_rehash_on_insert(functions)) {
    lock_guard_type l(functions_mutex);
    result = functions.emplace(name_ref, std::make_unique<F>(std::move(function)));
    functions_iterators_invalid.store(true);
  } else {
    result = functions.emplace(name_ref, std::make_unique<F>(std::move(function)));
  }
  return result.first->second->get_stop_source();
}

template <typename F, typename P, typename D>
std::shared_ptr<typename pump<F, P, D>::process_type> pump<F, P, D>::add_(name_ref_type name_ref, std::shared_ptr<process_type> process) {
  std::pair<typename decltype(processes)::iterator, bool> result;
  if (will_rehash_on_insert(processes)) {
    lock_guard_type l(processes_mutex);
    result = processes.emplace(name_ref, std::make_unique<P>(string_type(name_ref.get()), std::move(process)));
    processes_iterators_invalid.store(true);
  } else {
    result = processes.emplace(name_ref, std::make_unique<P>(string_type(name_ref.get()), std::move(process)));
  }
  auto & wrapper = result.first->second;
  auto prcss = wrapper->get();
  if (prcss->do_auto_start()) wrapper->start();
  return prcss;
}

template <typename F, typename P, typename D>
std::shared_ptr<typename pump<F, P, D>::process_type> pump<F, P, D>::add(string_type name, std::shared_ptr<process_interface> process) {
  if (name.empty()) throw std::invalid_argument("Empty string (process name)");
  if (!process) throw std::invalid_argument("Null pointer exception");
  if (auto ptr = std::dynamic_pointer_cast<typename P::process_type>(process)) {
    auto name_ref = dictionary->add(std::move(name));
    ptr->name_overwrite(name_ref, *dictionary);
    return std::static_pointer_cast<typename P::process_type>(add_(name_ref, std::move(ptr)));
  }
  return {};
}

template <typename F, typename P, typename D>
template <typename T>
std::shared_ptr<T> pump<F, P, D>::add(string_type name, std::shared_ptr<T> process) {
  static_assert(std::is_base_of<typename P::process_type, T>::value, "Must be derived from process_type");
  if (name.empty()) throw std::invalid_argument("Empty string (process name)");
  if (!process) throw std::invalid_argument("Null pointer exception");
  auto name_ref = dictionary->add(std::move(name));
  process->name_overwrite(name_ref, *dictionary);
  return std::static_pointer_cast<T>(add_(name_ref, std::move(process)));
}

template <typename F, typename P, typename D>
template <typename T, typename... Args>
std::shared_ptr<T> pump<F, P, D>::emplace_process(string_type name, Args &&... args) {
  static_assert(std::is_base_of<typename P::process_type, T>::value, "Must be derived from process_type");
  auto name_ref = dictionary->add(std::move(name));
  try {
    auto ptr = std::make_unique<T>(*dictionary, name_ref, std::forward<Args>(args)...);
    ptr->name_overwrite(name_ref, *dictionary);
    return std::static_pointer_cast<T>(add_(name_ref, std::move(ptr)));
  } catch (...) {
    dictionary->remove(name_ref.get());
    throw;
  }
}

template <typename F, typename P, typename D>
bool pump<F, P, D>::contains(string_type name) const {
  return dictionary->contains(name);
}

template <typename F, typename P, typename D>
template <typename... Args>
bool pump<F, P, D>::start(string_type name, Args &&... args) {
  lock_guard_type l(processes_mutex);
  auto itt = processes.find(name);
  if (itt != processes.cend()) {
    if (!itt->second->is_started()) {
      itt->second->start();
      for_each_arg([](auto && arg) { arg(); }, args...);
      return true;
    }
  }
  return false;
}

template <typename F, typename P, typename D>
bool pump<F, P, D>::is_started(string_type name) const {
  {
    lock_guard_type l(processes_mutex);
    auto itt = processes.find(name);
    if (itt != processes.cend()) {
      return itt->second->is_started();
    }
  }
  {
    lock_guard_type l(functions_mutex);
    auto itt = functions.find(name);
    if (itt != functions.cend()) {
      return itt->second->is_started();
    }
  }
  return false;
}

template <typename F, typename P, typename D>
bool pump<F, P, D>::is_ready_for_dispatch(string_type name) const {
  {
    lock_guard_type l(processes_mutex);
    auto itt = processes.find(name);
    if (itt != processes.cend()) {
      return itt->second->is_ready_for_dispatch();
    }
  }
  return false;
}

template <typename F, typename P, typename D>
bool pump<F, P, D>::is_waiting(string_type name) const {
  {
    lock_guard_type l(processes_mutex);
    auto itt = processes.find(name);
    if (itt != processes.cend()) {
      return itt->second->is_waiting();
    }
  }
  return false;
}

template <typename F, typename P, typename D>
bool pump<F, P, D>::is_finished(string_type name) const {
  {
    lock_guard_type l(processes_mutex);
    auto itt = processes.find(name);
    if (itt != processes.cend()) {
      return itt->second->is_finished();
    }
  }
  {
    lock_guard_type l(functions_mutex);
    auto itt = functions.find(name);
    if (itt != functions.cend()) {
      return itt->second->is_finished();
    }
  }
  return false;
}

template <typename F, typename P, typename D>
std::vector<typename pump<F, P, D>::string_type> pump<F, P, D>::function_names() const {
  std::vector<string_type> nms;
  for (auto & e : this->functions) {
    nms.push_back(e.first);
  }
  return nms;
}

template <typename F, typename P, typename D>
std::vector<typename pump<F, P, D>::string_type> pump<F, P, D>::process_names() const {
  std::vector<typename pump<F, P, D>::string_type> nms;
  for (auto & e : this->processes) {
    nms.push_back(e.first);
  }
  return nms;
}

template <typename F, typename P, typename D>
auto & pump<F, P, D>::get_function(string_type name) {
  typename D::reference_type name_ref(name);
  if (dictionary->find(name, name_ref)) LIKELY {
      lock_guard_type l(functions_mutex);
      auto function_itt = functions.find(name_ref);
      if (function_itt != functions.cend()) return function_itt->second->get_stop_source();
    }
  throw std::runtime_error(std::string("Function with name '") + name + "' not found!");
}

template <typename F, typename P, typename D>
const auto & pump<F, P, D>::get_function(string_type name) const {
  typename D::reference_type name_ref(name);
  if (dictionary->find(name, name_ref)) LIKELY {
      lock_guard_type l(functions_mutex);
      auto function_itt = functions.find(name_ref);
      if (function_itt != functions.cend()) return function_itt->second->get_stop_source();
    }
  throw std::runtime_error(std::string("Function with name '") + name + "' not found!");
}

template <typename F, typename P, typename D>
const auto pump<F, P, D>::get_process(string_type name) const {
  typename D::reference_type name_ref(name);
  if (dictionary->find(name, name_ref)) LIKELY {
      lock_guard_type l(processes_mutex);
      auto process_itt = processes.find(name_ref);
      if (process_itt != processes.cend()) return process_itt->second->get();
    }
  throw std::runtime_error(std::string("Process with name '") + name + "' not found!");
}

template <typename F, typename P, typename D>
auto pump<F, P, D>::get_process(string_type name) {
  typename D::reference_type name_ref(name);
  if (dictionary->find(name, name_ref)) LIKELY {
      lock_guard_type l(processes_mutex);
      auto process_itt = processes.find(name_ref);
      if (process_itt != processes.cend()) return process_itt->second->get();
    }
  throw std::runtime_error(std::string("Process with name '") + name + "' not found!");
}

template <typename F, typename P, typename D>
typename pump<F, P, D>::sender_type pump<F, P, D>::get_sender(string_type name) const {
  typename D::reference_type name_ref(name);
  if (dictionary->find(name, name_ref)) LIKELY {
      lock_guard_type l(processes_mutex);
      auto itt = processes.find(name_ref_type(name_ref));
      if (itt != processes.cend()) return itt->second->get()->template get_sender<sender_type>();
    }
  return {};
}

template <typename F, typename P, typename D>
std::size_t pump<F, P, D>::size() const noexcept {
#if __cplusplus >= CPP17_STANDARD
  std::scoped_lock l(processes_mutex, functions_mutex);
#else
  lock_guard_type l1(processes_mutex);
  lock_guard_type l2(functions_mutex);
#endif
  return processes.size() + functions.size();
}

template <typename F, typename P, typename D>
template <typename... Args>
void pump<F, P, D>::done(Args &&... args) {
  {
    lock_guard_type l(functions_mutex);
    for (auto && itt : functions) {
      itt.second->done();
    }
  }
  {
    lock_guard_type l(processes_mutex);
    for (auto && itt : processes) {
      itt.second->done();
    }
  }
  for_each_arg([](auto && arg) { arg(); }, args...);
}

template <typename F, typename P, typename D>
template <typename Msg, typename... Args>
void pump<F, P, D>::notify_all(const Msg & msg, Args &&... args) {
  lock_guard_type l(processes_mutex);
  for (auto && itt : processes) {
    itt.second->get()->template get_sender<sender_type>().send(msg, std::forward<Args>(args)...);
  }
}

} // namespace messaging

#endif /* INCLUDE__MESSAGING__PUMP_HPP */
