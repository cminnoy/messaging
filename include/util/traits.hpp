/**
 * @file traits.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__UTIL__TRAITS_HPP
#define INCLUDE__UTIL__TRAITS_HPP

#if __cplusplus < CPP11_STANDARD
#error This library needs at least a C++11 compliant compiler
#else

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP11_STANDARD, "Minimum required standard is C++11.");

#include <string>
#include <cstring>
#include <tuple>
#include <type_traits>
#include <array>
#include <vector>
#include <iostream>
#include <cstddef>
#include <stdexcept>
#include <functional>
#include <iostream>

#if __cplusplus >= CPP17_STANDARD
#include <string_view>
#define CONSTEXPR_TR constexpr
#else
#define CONSTEXPR_TR
#endif

#if __cplusplus < CPP17_STANDARD
#include <boost/version.hpp>

#if BOOST_VERSION < 107000
#error "Minimum required boost version is 1.70"
#endif

#include <boost/callable_traits/is_invocable.hpp>

#endif


#if __cplusplus < CPP17_STANDARD
namespace detail {

// clang-format off
#ifndef _MSC_VER
#  if __cplusplus < CPP11_STANDARD
#    define CONSTEXPR11_TN
#    define CONSTEXPR14_TN
#    define NOEXCEPT_TN
#  elif __cplusplus < CPP14_STANDARD
#    define CONSTEXPR11_TN constexpr
#    define CONSTEXPR14_TN
#    define NOEXCEPT_TN noexcept
#  else
#    define CONSTEXPR11_TN constexpr
#    define CONSTEXPR14_TN constexpr
#    define NOEXCEPT_TN noexcept
#  endif
#else  // _MSC_VER
#  if _MSC_VER < 1900
#    define CONSTEXPR11_TN
#    define CONSTEXPR14_TN
#    define NOEXCEPT_TN
#  elif _MSC_VER < 2000
#    define CONSTEXPR11_TN constexpr
#    define CONSTEXPR14_TN
#    define NOEXCEPT_TN noexcept
#  else
#    define CONSTEXPR11_TN constexpr
#    define CONSTEXPR14_TN constexpr
#    define NOEXCEPT_TN noexcept
#  endif
#endif  // _MSC_VER
// clang-format on

class static_string {
  const char * const p_;
  const std::size_t sz_;

public:
  typedef const char * const_iterator;

  template <std::size_t N>
  CONSTEXPR11_TN static_string(const char (&a)[N]) NOEXCEPT_TN : p_(a), sz_(N - 1) {}

  CONSTEXPR11_TN static_string(const char * p, std::size_t N) NOEXCEPT_TN : p_(p), sz_(N) {}

  CONSTEXPR11_TN const char * data() const NOEXCEPT_TN { return p_; }
  CONSTEXPR11_TN std::size_t size() const NOEXCEPT_TN { return sz_; }

  CONSTEXPR11_TN const_iterator begin() const NOEXCEPT_TN { return p_; }
  CONSTEXPR11_TN const_iterator end() const NOEXCEPT_TN { return p_ + sz_; }

  CONSTEXPR11_TN char operator[](std::size_t n) const { return n < sz_ ? p_[n] : throw std::out_of_range("static_string"); }

  operator std::string() const NOEXCEPT_TN { return std::string(p_, sz_); }
};

inline std::ostream & operator<<(std::ostream & os, static_string const & s) {
  return os.write(s.data(), s.size());
}

} // namespace detail
#endif


#if __cplusplus >= CPP17_STANDARD

/**
 * @brief Return printable name of type
 * 
 * @tparam T type
 * @return auto
 * @note Type representations will be different between g++/clang and msvc
 * @todo Implement a parser to convert textual differences between the compilers into one consistent representation.
 *       Maybe use https://github.com/peter-winter/ctpg
 */
template <typename T>
NO_DISCARD constexpr auto type_name() {
  std::string_view name, prefix, suffix;
#ifdef __clang__
  name = __PRETTY_FUNCTION__;
  prefix = "auto type_name() [T = ";
  suffix = "]";
#elif defined(__GNUC__)
  name = __PRETTY_FUNCTION__;
  prefix = "constexpr auto type_name() [with T = ";
  suffix = "]";
#elif defined(_MSC_VER)
  name = __FUNCSIG__;
  prefix = "auto __cdecl type_name<";
  suffix = ">(void)";
#endif
  name.remove_prefix(prefix.size());
  name.remove_suffix(suffix.size());
  return name;
}

#else

template <class T>
NO_DISCARD CONSTEXPR14_TN detail::static_string type_name() NOEXCEPT_TN {
  using namespace detail;
  constexpr std::size_t namespace_offset = 8;
#ifdef __clang__
  static_string p = __PRETTY_FUNCTION__;
  return static_string(p.data() + 31 + namespace_offset, p.size() - 31 - namespace_offset - 1);
#elif defined(__GNUC__)
  static_string p = __PRETTY_FUNCTION__;
#if __cplusplus < CPP14_STANDARD
  return static_string(p.data() + 36 + namespace_offset, p.size() - 36 - namespace_offset - 1);
#else
  return static_string(p.data() + 46 + namespace_offset, p.size() - 46 - namespace_offset - 1);
#endif
#elif defined(_MSC_VER)
  static_string p = __FUNCSIG__;
  return static_string(p.data() + 38 + namespace_offset, p.size() - 38 - namespace_offset - 7);
#endif
}

#undef CONSTEXPR11_TN
#undef CONSTEXPR14_TN
#undef NOEXCEPT_TN

#endif

/**
 * @brief Return true if used inside a lambda, otherwise returns false.
 * @return boolean true/false
 * @example constexpr bool inside_lambda = INSIDE_LAMBDA;
 */
#if __cplusplus >= CPP17_STANDARD
#define INSIDE_LAMBDA ((std::string_view(__PRETTY_FUNCTION__).find("<lambda(") != std::string_view(__PRETTY_FUNCTION__).npos))
#else
#define INSIDE_LAMBDA ((std::string(__PRETTY_FUNCTION__).find("<lambda(") != std::string(__PRETTY_FUNCTION__).npos))
#endif

/**
 * @brief Return name of the function containing the active lambda.
 * @note From C++17 onwards this can be done at compile time.
 * @warning Result is indetermined if used outside a lambda.
 * @return std::string_view (>= C++17) or std::string (< C++17)
 * @example void f() { []() { std::cout << LAMBDA_OUTER_FUNC_NAME() << std::endl; }(); }
 */
#if __cplusplus >= CPP17_STANDARD
#define LAMBDA_OUTER_FUNC_NAME                                                        \
  []() constexpr {                                                                    \
    std::string_view v(__PRETTY_FUNCTION__);                                          \
    std::size_t first_colon = v.find_first_of("::");                                  \
    if (first_colon == v.npos) return std::string_view("<error>");                    \
    if (v.size() >= 8 && v.substr(0, 8) == "<lambda(") return std::string_view("::"); \
    std::size_t first_brace = v.find_first_of("(");                                   \
    if (first_brace > first_colon) v.remove_prefix(first_colon + 2);                  \
    v.remove_suffix(v.size() - v.find_first_of("("));                                 \
    return v;                                                                         \
  }
#else
#define LAMBDA_OUTER_FUNC_NAME                                                   \
  []() {                                                                         \
    std::string v(__PRETTY_FUNCTION__);                                          \
    std::size_t first_colon = v.find_first_of("::");                             \
    if (first_colon == v.npos) return std::string("<error>");                    \
    if (v.size() >= 8 && v.substr(0, 8) == "<lambda(") return std::string("::"); \
    std::size_t first_brace = v.find_first_of("(");                              \
    if (first_brace > first_colon) v = v.substr(first_colon + 2);                \
    v.resize(v.find_first_of("("));                                              \
    return v;                                                                    \
  }
#endif


#if __cplusplus >= CPP17_STANDARD
namespace detail {

template <std::size_t I = 0, typename Container, typename... Types>
constexpr typename std::enable_if<I == sizeof...(Types) - 1 && 0 != sizeof...(Types), void>::type type_names_(Container & container) noexcept {
  using T = std::tuple_element_t<I, std::tuple<Types...>>;
  container[I] = type_name<T>();
}

template <std::size_t I, typename Container, typename... Types>
  constexpr typename std::enable_if < I<sizeof...(Types) - 1 && 0 != sizeof...(Types), void>::type type_names_(Container & container) noexcept {
  using T = std::tuple_element_t<I, std::tuple<Types...>>;
  container[I] = type_name<T>();
  type_names_<I + 1, decltype(container), Types...>(container);
}

template <std::size_t I, typename Container, typename... Types>
constexpr typename std::enable_if<0 == sizeof...(Types), void>::type type_names_(Container &) noexcept {}

} // namespace detail

template <typename... Types>
NO_DISCARD constexpr auto type_names() noexcept {
  std::array<decltype(type_name<void>()), sizeof...(Types)> names;
  detail::type_names_<0, decltype(names), Types...>(names);
  return names;
}

template <typename... Types>
NO_DISCARD constexpr auto type_names(std::tuple<Types...>) noexcept {
  std::array<decltype(type_name<void>()), sizeof...(Types)> names;
  detail::type_names_<0, decltype(names), Types...>(names);
  return names;
}

namespace std {

template <std::size_t I>
inline std::ostream & operator<<(std::ostream & out, const std::array<decltype(type_name<void>()), I> & o) {
  bool comma = false;
  out << '{';
  for (auto && elem : o) {
    if (comma) out << ',';
    comma = true;
    out << elem;
  }
  out << '}';
  return out;
}

} // namespace std

#else

namespace detail {

template <std::size_t I = 0, typename Container, typename... Types>
CPP14_CONSTEXPR typename std::enable_if<I == sizeof...(Types) - 1 && 0 != sizeof...(Types), void>::type type_names_(Container & container) {
  using T = std::tuple_element_t<I, std::tuple<Types...>>;
  constexpr auto name = type_name<T>();
  container[I] = std::string(name.data(), name.size());
}

template <std::size_t I, typename Container, typename... Types>
  CPP14_CONSTEXPR typename std::enable_if < I<sizeof...(Types) - 1 && 0 != sizeof...(Types), void>::type type_names_(Container & container) {
  using T = std::tuple_element_t<I, std::tuple<Types...>>;
  constexpr auto name = type_name<T>();
  container[I] = std::string(name.data(), name.size());
  type_names_<I + 1, decltype(container), Types...>(container);
}

template <std::size_t I, typename Container, typename... Types>
CPP14_CONSTEXPR typename std::enable_if<0 == sizeof...(Types), void>::type type_names_(Container &) noexcept {}

} // namespace detail

template <typename... Types>
NO_DISCARD auto type_names() {
  std::vector<std::string> names(sizeof...(Types));
  detail::type_names_<0, decltype(names), Types...>(names);
  return names;
}

template <typename... Types>
NO_DISCARD auto type_names(std::tuple<Types...>) {
  std::vector<std::string> names(sizeof...(Types));
  detail::type_names_<0, decltype(names), Types...>(names);
  return names;
}

namespace std {

inline std::ostream & operator<<(std::ostream & out, const std::vector<std::string> & o) {
  bool comma = false;
  out << '{';
  for (auto && elem : o) {
    if (comma) out << ',';
    comma = true;
    out << elem;
  }
  out << '}';
  return out;
}

} // namespace std

#endif

/**
 * @brief Return printable primary category of type
 * 
 * @tparam T type
 * @return auto
 */
template <typename T>
#if __cplusplus >= CPP14_STANDARD
NO_DISCARD constexpr auto type_primary_category() noexcept {
#else
NO_DISCARD static_string type_primary_category() noexcept {
#endif
  // clang-format off
  if CONSTEXPR_TR (std::is_void<T>::value)                         return "void";
#if __cplusplus >= CPP14_STANDARD
  else if CONSTEXPR_TR (std::is_null_pointer<T>::value)            return "null_pointer";
#endif
  else if CONSTEXPR_TR (std::is_integral<T>::value)                return "integral";
  else if CONSTEXPR_TR (std::is_floating_point<T>::value)          return "floating_point";
  else if CONSTEXPR_TR (std::is_array<T>::value)                   return "array";
  else if CONSTEXPR_TR (std::is_enum<T>::value)                    return "enum";
  else if CONSTEXPR_TR (std::is_union<T>::value)                   return "union";
  else if CONSTEXPR_TR (std::is_class<T>::value)                   return "class";
  else if CONSTEXPR_TR (std::is_function<T>::value)                return "function";
  else if CONSTEXPR_TR (std::is_pointer<T>::value)                 return "pointer";
  else if CONSTEXPR_TR (std::is_lvalue_reference<T>::value)        return "lvalue_reference";
  else if CONSTEXPR_TR (std::is_rvalue_reference<T>::value)        return "rvalue_reference";
  else if CONSTEXPR_TR (std::is_member_object_pointer<T>::value)   return "member_object_pointer";
  else if CONSTEXPR_TR (std::is_member_function_pointer<T>::value) return "member_function_pointer";
  return "<unknown>";
  // clang-format on
}

/**
 * @brief Return printable composite category of type
 *
 * @tparam T type
 * @return auto
 */
template <typename T>
#if __cplusplus >= CPP14_STANDARD
NO_DISCARD constexpr auto type_composite_category() noexcept {
#else
NO_DISCARD static_string type_composite_category() noexcept {
#endif
  // clang-format off
  if CONSTEXPR_TR (std::is_fundamental<T>::value)         return "fundamental";
  else if CONSTEXPR_TR (std::is_arithmetic<T>::value)     return "arithmetic";
  else if CONSTEXPR_TR (std::is_scalar<T>::value)         return "scalar";
  else if CONSTEXPR_TR (std::is_object<T>::value)         return "object";
  else if CONSTEXPR_TR (std::is_compound<T>::value)       return "compound";
  else if CONSTEXPR_TR (std::is_reference<T>::value)      return "reference";
  else if CONSTEXPR_TR (std::is_member_pointer<T>::value) return "member_pointer";
  return "<unknown>";
  // clang-format on
}

/**
 * @brief Return printable properties of type
 * 
 * @tparam T type
 * @return std::string 
 */
template <typename T>
NO_DISCARD std::string type_properties() {
  std::string prop = "{";
  if CONSTEXPR_TR (std::is_const<T>::value) prop += "const,";
  if CONSTEXPR_TR (std::is_volatile<T>::value) prop += "volatile,";
  if CONSTEXPR_TR (std::is_trivial<T>::value) prop += "trivial,";
  if CONSTEXPR_TR (std::is_trivially_copyable<T>::value) prop += "trivially_copyable,";
  if CONSTEXPR_TR (std::is_standard_layout<T>::value) prop += "standard_layout,";
#if __cplusplus < CPP20_STANDARD // Deprecated from C++20
  if CONSTEXPR_TR (std::is_pod<T>::value) prop += "pod,";
#endif
#if __cplusplus < CPP17_STANDARD // Deprecated from C++17
  if CONSTEXPR_TR (std::is_literal_type<T>::value) prop += "literal_type,";
#endif
#if __cplusplus >= CPP17_STANDARD
  if constexpr (std::has_unique_object_representations<T>::value) prop += "has_unique_object_representations,";
#endif
  if CONSTEXPR_TR (std::is_empty<T>::value) prop += "empty,";
  if CONSTEXPR_TR (std::is_polymorphic<T>::value) prop += "polymorphic,";
  if CONSTEXPR_TR (std::is_abstract<T>::value) prop += "abstract,";
#if __cplusplus >= CPP14_STANDARD
  if CONSTEXPR_TR (std::is_final<T>::value) prop += "final,";
#endif
#if __cplusplus >= CPP17_STANDARD
  if constexpr (std::is_aggregate<T>::value) prop += "aggregate,";
#endif
  if CONSTEXPR_TR (std::is_signed<T>::value) prop += "signed,";
  if CONSTEXPR_TR (std::is_unsigned<T>::value) prop += "unsigned,";
#if __cplusplus >= CPP20_STANDARD
  if constexpr (std::is_bounded_array<T>::value) prop += "bounded_array,";
  if constexpr (std::is_unbounded_array<T>::value) prop += "unbounded_array,";
#endif
#if __cplusplus >= CPP23_STANDARD
  if constexpr (std::is_scoped_enum<T>::value) prop += "scoped_enum,";
#endif
  if (prop.size() == 1) prop += "}";
  else
    prop[prop.size() - 1] = '}';
  return prop;
}

/**
 * @brief Return printable operations of type
 * 
 * @tparam T type
 * @return std::string 
 */
template <typename T>
NO_DISCARD std::string type_operations() {
  std::string ops = "{";
  if CONSTEXPR_TR (std::is_default_constructible<T>::value) ops += "default_constructable,";
  if CONSTEXPR_TR (std::is_trivially_default_constructible<T>::value) ops += "trivially_default_constructable,";
  if CONSTEXPR_TR (std::is_nothrow_default_constructible<T>::value) ops += "nothrow_default_constructable,";
  if CONSTEXPR_TR (std::is_copy_constructible<T>::value) ops += "copy_constructable,";
  if CONSTEXPR_TR (std::is_trivially_copy_constructible<T>::value) ops += "trivially_copy_constructable,";
  if CONSTEXPR_TR (std::is_nothrow_copy_constructible<T>::value) ops += "nothrow_copy_constructable,";
  if CONSTEXPR_TR (std::is_move_constructible<T>::value) ops += "move_constructable,";
  if CONSTEXPR_TR (std::is_trivially_move_constructible<T>::value) ops += "trivially_move_constructable,";
  if CONSTEXPR_TR (std::is_nothrow_move_constructible<T>::value) ops += "nothrow_move_constructable,";
  if CONSTEXPR_TR (std::is_copy_assignable<T>::value) ops += "copy_assignable,";
  if CONSTEXPR_TR (std::is_trivially_copy_assignable<T>::value) ops += "trivially_copy_assignable,";
  if CONSTEXPR_TR (std::is_nothrow_copy_assignable<T>::value) ops += "nothrow_copy_assignable,";
  if CONSTEXPR_TR (std::is_move_assignable<T>::value) ops += "move_assignable,";
  if CONSTEXPR_TR (std::is_trivially_move_assignable<T>::value) ops += "trivially_move_assignable,";
  if CONSTEXPR_TR (std::is_nothrow_move_assignable<T>::value) ops += "nothrow_move_assignable,";
  if CONSTEXPR_TR (std::is_destructible<T>::value) ops += "destructable,";
  if CONSTEXPR_TR (std::is_trivially_destructible<T>::value) ops += "trivially_destructable,";
  if CONSTEXPR_TR (std::is_nothrow_destructible<T>::value) ops += "nothrow_destructable,";
  if CONSTEXPR_TR (std::has_virtual_destructor<T>::value) ops += "has_virtual_destructor,";
#if __cplusplus >= CPP17_STANDARD
  if constexpr (std::is_swappable<T>::value) ops += "swappable,";
  if constexpr (std::is_nothrow_swappable<T>::value) ops += "nothrow_swappable,";
#endif
  if (ops.size() == 1) ops += "}";
  else
    ops[ops.size() - 1] = '}';
  return ops;
}

/**
 * @brief Return printable assignable operations of first type to second type
 * 
 * @tparam T first type
 * @tparam U second type
 * @return std::string 
 */
template <typename T, typename U>
NO_DISCARD std::string type_assignable_operations() {
  std::string ops = "{";
  if CONSTEXPR_TR (std::is_assignable<T, U>::value) ops += "assignable,";
  if CONSTEXPR_TR (std::is_trivially_assignable<T, U>::value) ops += "trivially_assignable,";
  if CONSTEXPR_TR (std::is_nothrow_assignable<T, U>::value) ops += "nothrow_assignable,";
#if __cplusplus >= CPP17_STANDARD
  if constexpr (std::is_swappable_with<T, U>::value) ops += "swappable_with,";
  if constexpr (std::is_nothrow_swappable_with<T, U>::value) ops += "nothrow_swappable_with,";
#endif
  if (ops.size() == 1) ops += "}";
  else
    ops[ops.size() - 1] = '}';
  return ops;
}

/**
 * Function, functor and member functions signature detection
 * @{
 */
template <typename Sig>
struct signature;

template <typename Ret, typename... Args>
struct signature<Ret(Args...)> {
  using return_type = Ret;
  using argument_types = std::tuple<Args...>;
};

template <typename Ret, typename Obj, typename... Args>
struct signature<Ret (Obj::*)(Args...)> {
  using return_type = Ret;
  using argument_types = std::tuple<Args...>;
};

template <typename Ret, typename Obj, typename... Args>
struct signature<Ret (Obj::*)(Args...) const> {
  using return_type = Ret;
  using argument_types = std::tuple<Args...>;
};

#if __cplusplus >= CPP20_STANDARD
template <typename Fun>
concept is_func = std::is_function_v<Fun>;

template <typename Fun>
concept is_member_func = std::is_member_function_pointer_v<std::decay_t<Fun>>;

template <typename Fun>
concept is_functor = std::is_class_v<std::decay_t<Fun>> && requires(Fun && t) { &std::decay_t<Fun>::operator(); };

template <is_functor T>
auto arguments(T &&) -> typename signature<decltype(&std::decay_t<T>::operator())>::argument_types;

template <is_functor T>
auto arguments(const T &) -> typename signature<decltype(&std::decay_t<T>::operator())>::argument_types;

template <is_func T>
auto arguments(const T & t) -> typename signature<T>::argument_types;

template <is_member_func T>
auto arguments(T && t) -> typename signature<std::decay_t<T>>::argument_types;
/**@}*/
#endif // CPP20_STANDARD


/**
 * @brief Functor and lambda signature detection
 * @{
 */
template <typename T>
struct first_arg {
  using type = std::tuple_element_t<0, T>;
};

template <>
struct first_arg<std::tuple<>> {
  using type = void;
};

template <typename T>
struct memfun_type {
  using type = void;
};

template <typename Ret, typename Class, typename... Args>
struct memfun_type<Ret (Class::*)(Args...) const> {
  using fn_type = std::function<Ret(Args...)>;
  using return_type = Ret;
  using arg_types = std::tuple<Args...>;
  using first_arg = typename first_arg<arg_types>::type;
  static constexpr std::size_t arg_count = std::tuple_size<arg_types> {};
};

template <typename F>
using function_info = memfun_type<decltype(&F::operator())>;
/**
 * @}
 */


#undef CONSTEXPR_TR

namespace util {

template <bool...>
struct bool_pack;

template <bool... v>
using all_true = std::is_same<bool_pack<true, v...>, bool_pack<v..., true>>;

/**
 * @brief No type in the template pack are a reference type.
 */
template <typename... Ts>
using non_are_reference = all_true<!std::is_reference<Ts>::value...>;

/**
 * @brief No type in the template pack has the volatile qualifier.
 */
template <typename... Ts>
using non_are_volatile = all_true<!std::is_volatile<Ts>::value...>;

/*
 * @brief All types in the template pack have the const qualifier.
 */
template <typename... Ts>
using all_are_const = all_true<std::is_const<Ts>::value...>;

/**
 * @brief Type is derived from all of the OtherTypes.
 */
template <typename Type>
struct is_derived {
  template <typename... OtherTypes>
  struct from : std::integral_constant<bool, all_true<std::is_base_of<OtherTypes, Type> {}...>::value> {};
};

/**
 * @brief Type is convertible to all of the OtherTypes.
 */
template <typename Type>
struct is_convertible {
  template <typename... OtherTypes>
  struct to : std::integral_constant<bool, all_true<std::is_convertible<Type, OtherTypes> {}...>::value> {};
};

/**
 * @brief Type is of the same type as all the OtherTypes.
 */
template <typename Type>
struct is_same {
  template <typename... OtherTypes>
  struct as : std::integral_constant<bool, all_true<std::is_same<OtherTypes, Type> {}...>::value> {};
};

/**
 * @brief Type is different type as all the OtherTypes.
 */
template <typename Type>
struct not_same {
  template <typename... OtherTypes>
  struct as : std::integral_constant<bool, all_true<!std::is_same<OtherTypes, Type> {}...>::value> {};
};

/**
 * @brief Determine common type taking into account constness.
 * @note std::common_type doesn't take into account constness.
 */
/**@{*/
template <typename...>
struct common_type;

template <typename... Ts>
using common_type_t = typename common_type<Ts...>::type;

template <>
struct common_type<> {};

template <class T>
struct common_type<T> {
  using type = std::remove_reference_t<T>;
};

template <class T, class U>
struct common_type<T, U> {
  using type = std::remove_reference_t<decltype(true ? std::declval<T>() : std::declval<U>())>;
};

template <class T, class U, class... V>
struct common_type<T, U, V...> {
  using type = typename common_type<typename common_type<T, U>::type, V...>::type;
};
/**@}*/

/**
 * @brief Add const on basic type but not on pointer.
 * @note std::add_const makes the pointer const and not the type.
 */
template <typename T>
using add_const_on_pointer_t = typename std::add_pointer_t<std::add_const_t<std::remove_cv_t<std::remove_reference_t<std::remove_pointer_t<T>>>>>;

/**
 * @brief Alternative to C++17 std::is_invocable is using boost.
 */
//@{
#if __cplusplus < CPP17_STANDARD

template <typename F, typename... Args>
using is_invocable = boost::callable_traits::is_invocable<F, Args...>;

template <typename R, typename F, typename... Args>
using is_invocable_r = boost::callable_traits::is_invocable_r<R, F, Args...>;

#else
template <typename F, typename... Args>
using is_invocable = std::is_invocable<F, Args...>;

template <typename R, typename F, typename... Args>
using is_invocable_r = std::is_invocable_r<R, F, Args...>;
#endif
//@}

/**
 * @brief Alternative for C++20 std::remove_cvref
 */
//@{
template <class T>
struct remove_cvref {
  typedef std::remove_cv_t<std::remove_reference_t<T>> type;
};

template <class T>
using remove_cvref_t = typename remove_cvref<T>::type;
//@}

/**
 * @brief Alternative to C++17 void_t
 */
//@{
template <typename...>
using void_t = void;
//@}

/**
 * @brief Detect at compile time if operator<< to std::ostream is implemented for a type.
 */
//@{
template <typename T, typename = void>
struct is_ostream_operator_available : std::false_type {};

template <typename T>
struct is_ostream_operator_available<T, void_t<decltype(std::declval<std::ostream &>() << std::declval<T &>())>> : std::true_type {};
//@}

//@{
template <typename T>
struct type_identity {
  using type = T;
};

/**
 * @brief alternative for std::type_identity_t available from C++20 onwards
 * 
 */
template <typename T>
using type_identity_t = typename type_identity<T>::type;
//@}

} // namespace util

#endif // CPP11_STANDARD

#endif /* INCLUDE__UTIL__TRAITS_HPP */
