/**
 * @file pointer_cast.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__UTIL__POINTER_CAST_HPP
#define INCLUDE__UTIL__POINTER_CAST_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP11_STANDARD, "Minimum required standard is C++11.");

#include <memory>
#include <util/pmte.hpp>

/**
 * @file
 * 
 * Uniform pointer casting.
 */

namespace util {

//=====================================================================================================================
// Pointer cast raw
//=====================================================================================================================

template <typename T>
inline T * static_pointer_cast(std::nullptr_t) {
  return nullptr;
}

template <typename T, typename U>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, T *> static_pointer_cast(U * ptr) {
  return static_cast<T *>(ptr);
}

template <typename T>
inline T * dynamic_pointer_cast(std::nullptr_t) {
  return nullptr;
}

template <typename T, typename U>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, T *> dynamic_pointer_cast(U * ptr) {
  static_assert(!std::is_same<U, T>::value ? std::has_virtual_destructor<U>::value : true,
    "The source of dynamic_pointer_cast must have a virtual destructor.");
  return dynamic_cast<T *>(ptr);
}

template <typename T>
inline T * const_pointer_cast(std::nullptr_t) {
  return nullptr;
}

template <typename T, typename U>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, T *> const_pointer_cast(U * ptr) {
  static_assert(std::is_same<std::remove_cv_t<U>, std::remove_cv_t<T>>::value, "T and U must be same type");
  return const_cast<T *>(ptr);
}

template <typename T>
inline T * reinterpret_pointer_cast(std::nullptr_t) {
  return nullptr;
}

template <typename T, typename U>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, T *> reinterpret_pointer_cast(U * ptr) {
  return reinterpret_cast<T *>(ptr);
}


//=====================================================================================================================
// Pointer cast unique_ptr non-PMTE
//=====================================================================================================================

template <typename T, typename U>
typename std::enable_if<!std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> static_pointer_cast(
  std::unique_ptr<U> const & ptr) {
  static_assert(std::is_const<decltype(ptr)>::value, "std::unique_ptr can't be copied, please use rvalue");
  return {};
}

template <typename T, typename U>
typename std::enable_if_t<!std::is_same<T, U>::value && !std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> static_pointer_cast(
  std::unique_ptr<U> && ptr) noexcept {
  static_assert(!std::is_const<decltype(ptr)>::value, "std::unique_ptr can't be const");
  (void)static_cast<T *>(static_cast<U *>(0));
  typedef typename std::unique_ptr<T>::element_type E;
  return std::unique_ptr<T>(static_cast<E *>(ptr.release()));
}

template <typename T>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, T>::value, std::unique_ptr<T>> static_pointer_cast(
  std::unique_ptr<T> && ptr) noexcept {
  return std::move(ptr);
}

template <typename T, typename U>
typename std::enable_if<!std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> dynamic_pointer_cast(
  std::unique_ptr<U> const & ptr) {
  static_assert(std::is_const<decltype(ptr)>::value, "std::unique_ptr can't be copied, please use rvalue");
  return {};
}

template <typename T, typename U>
typename std::enable_if_t<!std::is_same<T, U>::value && !std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> dynamic_pointer_cast(
  std::unique_ptr<U> && ptr) noexcept {
  static_assert(std::has_virtual_destructor<T>::value, "The target of dynamic_pointer_cast must have a virtual destructor.");
  (void)dynamic_cast<T *>(static_cast<U *>(0));
  T * p = dynamic_cast<T *>(ptr.get());
  if (p) ptr.release();
  return std::unique_ptr<T>(p);
}

template <typename T>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, T>::value, std::unique_ptr<T>> dynamic_pointer_cast(
  std::unique_ptr<T> && ptr) noexcept {
  return std::move(ptr);
}

template <typename T, typename U>
typename std::enable_if<!std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> const_pointer_cast(
  std::unique_ptr<U> const & ptr) {
  static_assert(std::is_const<decltype(ptr)>::value, "std::unique_ptr can't be copied, please use rvalue");
  return {};
}

template <typename T, typename U>
typename std::enable_if_t<!std::is_same<T, U>::value && !std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> const_pointer_cast(
  std::unique_ptr<U> && ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  (void)const_cast<T *>(static_cast<U *>(0));
  typedef typename std::unique_ptr<T>::element_type E;
  return std::unique_ptr<T>(const_cast<E *>(ptr.release()));
}

template <typename T>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, T>::value, std::unique_ptr<T>> const_pointer_cast(
  std::unique_ptr<T> && ptr) noexcept {
  return std::move(ptr);
}

template <typename T, typename U>
typename std::enable_if<!std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> reinterpret_pointer_cast(
  std::unique_ptr<U> const & ptr) {
  static_assert(std::is_const<decltype(ptr)>::value, "std::unique_ptr can't be copied, please use rvalue");
  return {};
}

template <typename T, typename U>
typename std::enable_if_t<!std::is_same<T, U>::value && !std::is_base_of<util::pmte::pmte_value, U>::value, std::unique_ptr<T>> reinterpret_pointer_cast(
  std::unique_ptr<U> && ptr) noexcept {
  (void)reinterpret_cast<T *>(static_cast<U *>(0));
  typedef typename std::unique_ptr<T>::element_type E;
  return std::unique_ptr<T>(reinterpret_cast<E *>(ptr.release()));
}

template <typename T>
inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, T>::value, std::unique_ptr<T>> reinterpret_pointer_cast(
  std::unique_ptr<T> && ptr) noexcept {
  return std::move(ptr);
}

//=====================================================================================================================
// Pointer cast shared_ptr non-PMTE
//=====================================================================================================================

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> static_pointer_cast(
  std::shared_ptr<U> const & ptr) noexcept {
  return std::static_pointer_cast<T>(ptr);
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> static_pointer_cast(
  std::shared_ptr<U> && ptr) noexcept {
#if __cplusplus >= CPP20_STANDARD
  return std::static_pointer_cast<T>(ptr);
#else
  auto p = static_cast<typename std::shared_ptr<T>::element_type *>(ptr.get());
  return std::shared_ptr<T> {ptr, p};
#endif
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<U> const & ptr) noexcept {
  return std::dynamic_pointer_cast<T>(ptr);
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<U> && ptr) noexcept {
#if __cplusplus >= CPP20_STANDARD
  return std::dynamic_pointer_cast<T>(ptr);
#else
  if (auto p = dynamic_cast<typename std::shared_ptr<T>::element_type *>(ptr.get())) return std::shared_ptr<T> {ptr, p};
  else
    return std::shared_ptr<T> {};
#endif
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> const_pointer_cast(
  std::shared_ptr<U> const & ptr) noexcept {
  return std::const_pointer_cast<T>(ptr);
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> const_pointer_cast(
  std::shared_ptr<U> && ptr) noexcept {
#if __cplusplus >= CPP20_STANDARD
  return std::const_pointer_cast<T>(ptr);
#else
  auto p = const_cast<typename std::shared_ptr<T>::element_type *>(ptr.get());
  return std::shared_ptr<T> {ptr, p};
#endif
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> reinterpret_pointer_cast(
  std::shared_ptr<U> const & ptr) noexcept {
#if __cplusplus >= CPP17_STANDARD
  return std::reinterpret_pointer_cast<T>(ptr);
#else
  auto p = reinterpret_cast<typename std::shared_ptr<T>::element_type *>(ptr.get());
  return std::shared_ptr<T> {ptr, p};
#endif
}

template <typename T, typename U>
NO_DISCARD inline typename std::enable_if_t<!std::is_base_of<util::pmte::pmte_value, U>::value, std::shared_ptr<T>> reinterpret_pointer_cast(
  std::shared_ptr<U> && ptr) noexcept {
#if __cplusplus >= CPP20_STANDARD
  return std::reinterpret_pointer_cast<T>(ptr);
#else
  auto p = reinterpret_cast<typename std::shared_ptr<T>::element_type *>(ptr.get());
  return std::shared_ptr<T> {ptr, p};
#endif
}

#if __cplusplus >= CPP14_STANDARD


//=====================================================================================================================
// Pointer cast shared_ptr PMTE
//=====================================================================================================================

// static_pointer_cast

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<std::is_pointer<U>::value, std::shared_ptr<T>> static_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, static_cast<T *>(static_cast<void *>(&u)));
  }
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_pointer<U>::value, std::shared_ptr<T>> static_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  if (ptr) {
    return std::shared_ptr<T>(ptr, static_cast<T *>(&ptr->get()));
  }
  return {};
}

template <typename T, typename Func, typename U>
NO_DISCARD std::shared_ptr<T> static_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::deleter<util::pmte::detail::value_store<U>, Func, U>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, static_cast<T *>(static_cast<void *>(&u)));
  }
  return {};
}

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<std::is_pointer<U>::value, std::shared_ptr<T>> static_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, static_cast<T *>(static_cast<void *>(&u)));
  }
  return {};
}

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<!std::is_pointer<U>::value, std::shared_ptr<T>> static_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const & ptr) noexcept {
  if (ptr) {
    return std::shared_ptr<T>(ptr, static_cast<T *>(&ptr->get()));
  }
  return {};
}

template <typename T, typename Func, typename U, typename... Types>
NO_DISCARD std::shared_ptr<T> static_pointer_cast(std::shared_ptr<util::pmte::detail::anchor<
    util::pmte::detail::deleter<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>, Func, U>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, static_cast<T *>(static_cast<void *>(&u)));
  }
  return {};
}

template <typename T>
NO_DISCARD std::shared_ptr<T> static_pointer_cast(util::pmte::shared_pmte_value const & ptr) noexcept {
  if (ptr) {
    return std::shared_ptr<T>(ptr, &ptr->get_unsafe<T>());
  }
  return {};
}

// dynamic_pointer_cast (interface)

template <typename T1, typename... Ts>
NO_DISCARD std::shared_ptr<util::common_type_t<T1, Ts...>> dynamic_pointer_cast(std::shared_ptr<util::pmte::pmte_value> && ptr) noexcept {
  if (ptr) {
    using common_type = util::common_type_t<T1, Ts...>;
    common_type * p = ptr->template get_if<T1, Ts...>();
    if (p) {
      return std::shared_ptr<common_type>(ptr, p);
    }
  }
  return {};
}

template <typename T1, typename... Ts>
NO_DISCARD std::shared_ptr<util::common_type_t<T1, Ts...>> dynamic_pointer_cast(std::shared_ptr<util::pmte::pmte_value> const & ptr) noexcept {
  if (ptr) {
    using common_type = util::common_type_t<T1, Ts...>;
    common_type * p = ptr->template get_if<T1, Ts...>();
    if (p) {
      return std::shared_ptr<common_type>(ptr, p);
    }
  }
  return {};
}

// dynamic_pointer_cast (interface; rtti)

template <typename T, typename... Ts>
NO_DISCARD std::shared_ptr<T> dynamic_pointer_cast(std::shared_ptr<util::pmte::pmte_value> && ptr, util::type_list<Ts...>) noexcept {
  if (ptr) {
    auto * p0 = ptr->template get_if<Ts...>();
    T * p1;
    if (std::is_same<T, decltype(p0)>::value) p1 = static_cast<T *>(p0);
    else
      p1 = dynamic_cast<T *>(p0);
    if (p1) {
      return std::shared_ptr<T>(ptr, p1);
    }
  }
  return {};
}

template <typename T, typename... Ts>
NO_DISCARD std::shared_ptr<T> dynamic_pointer_cast(std::shared_ptr<util::pmte::pmte_value> const & ptr, util::type_list<Ts...>) noexcept {
  if (ptr) {
    auto * p0 = ptr->template get_if<Ts...>();
    T * p1;
    if (std::is_same<T, decltype(p0)>::value) p1 = static_cast<T *>(p0);
    else
      p1 = dynamic_cast<T *>(p0);
    if (p1) {
      return std::shared_ptr<T>(ptr, p1);
    }
  }
  return {};
}

// dynamic_pointer_cast (plain)

template <typename T>
NO_DISCARD std::shared_ptr<T> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<T>>> && ptr) noexcept {
  if (ptr) {
    T & t = ptr->get();
    return std::shared_ptr<T>(ptr, &t);
  }
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_same<T, U>::value && std::is_base_of<T, U>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> && ptr) noexcept {
  if (ptr) {
    T & t = ptr->get();
    return std::shared_ptr<T>(ptr, &t);
  }
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_same<T, U>::value && !std::is_base_of<T, U>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> &&) noexcept {
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<std::is_const<U>::value && !std::is_const<T>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const &) noexcept {
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_same<T, U>::value && std::is_base_of<T, U>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  if (ptr) {
    T & t = ptr->get();
    return std::shared_ptr<T>(ptr, &t);
  }
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_same<T, U>::value && !std::is_base_of<T, U>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const &) noexcept {
  return {};
}

// dynamic_pointer_cast (plain; deleter)

template <typename T, typename Func, typename U>
NO_DISCARD typename std::enable_if_t<std::is_const<U>::value && !std::is_const<T>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::deleter<util::pmte::detail::value_store<U>, Func, U>>> const &) noexcept {
  return {};
}

// dynamic_pointer_cast (plain; rtti)

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<std::is_const<U>::value && !std::is_const<T>::value, std::shared_ptr<T>> dynamic_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const &) noexcept {
  return {};
}

// dynamic_pointer_cast (plain; deleter; rtti)

template <typename T, typename Func, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<std::is_const<U>::value && !std::is_const<T>::value, std::shared_ptr<T>> dynamic_pointer_cast(std::shared_ptr<
  util::pmte::detail::anchor<util::pmte::detail::deleter<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>, Func, U>>> const &) noexcept {
  return {};
}

// const_pointer_cast

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<std::is_pointer<U>::value, std::shared_ptr<T>> const_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, const_cast<T *>(&u));
  }
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_pointer<U>::value, std::shared_ptr<T>> const_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  if (ptr) {
    return std::shared_ptr<T>(ptr, const_cast<T *>(&ptr->get()));
  }
  return {};
}

template <typename T, typename Func, typename U>
NO_DISCARD std::shared_ptr<T> const_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::deleter<util::pmte::detail::value_store<U>, Func, U>>> const & ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, const_cast<T *>(&u));
  }
  return {};
}

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<std::is_pointer<U>::value, std::shared_ptr<T>> const_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const & ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, const_cast<T *>(&u));
  }
  return {};
}

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<!std::is_pointer<U>::value, std::shared_ptr<T>> const_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const & ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  if (ptr) {
    return std::shared_ptr<T>(ptr, const_cast<T *>(&ptr->get()));
  }
  return {};
}

template <typename T, typename Func, typename U, typename... Types>
NO_DISCARD std::shared_ptr<T> const_pointer_cast(std::shared_ptr<util::pmte::detail::anchor<
    util::pmte::detail::deleter<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>, Func, U>>> const & ptr) noexcept {
  static_assert(std::is_same<std::remove_cv_t<T>, std::remove_cv_t<U>>::value, "Both types must only differ in constness!");
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, const_cast<T *>(&u));
  }
  return {};
}

template <typename T>
NO_DISCARD std::shared_ptr<T> const_pointer_cast(util::pmte::shared_pmte_value const & ptr) noexcept {
  if (ptr) {
    assert(is_type_of<std::remove_cv_t<T>>(ptr) or is_type_of<std::add_const_t<std::remove_cv_t<T>>>(ptr));
    return std::shared_ptr<T>(ptr, const_cast<T *>(&ptr->get_unsafe<T>()));
  }
  return {};
}

// reinterpret_pointer_cast

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<std::is_pointer<U>::value, std::shared_ptr<T>> reinterpret_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&u));
  }
  return {};
}

template <typename T, typename U>
NO_DISCARD typename std::enable_if_t<!std::is_pointer<U>::value, std::shared_ptr<T>> reinterpret_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::value_store<U>>> const & ptr) noexcept {
  if (ptr) {
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&ptr->get()));
  }
  return {};
}

template <typename T, typename Func, typename U>
NO_DISCARD std::shared_ptr<T> reinterpret_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::deleter<util::pmte::detail::value_store<U>, Func, U>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&u));
  }
  return {};
}

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<std::is_pointer<U>::value, std::shared_ptr<T>> reinterpret_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&u));
  }
  return {};
}

template <typename T, typename U, typename... Types>
NO_DISCARD typename std::enable_if_t<!std::is_pointer<U>::value, std::shared_ptr<T>> reinterpret_pointer_cast(
  std::shared_ptr<util::pmte::detail::anchor<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>>> const & ptr) noexcept {
  if (ptr) {
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&ptr->get()));
  }
  return {};
}

template <typename T, typename Func, typename U, typename... Types>
NO_DISCARD std::shared_ptr<T> reinterpret_pointer_cast(std::shared_ptr<util::pmte::detail::anchor<
    util::pmte::detail::deleter<util::pmte::detail::rtti<util::pmte::detail::value_store<U>, Types...>, Func, U>>> const & ptr) noexcept {
  if (ptr) {
    U & u = ptr->get();
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&u));
  }
  return {};
}

template <typename T>
NO_DISCARD std::shared_ptr<T> reinterpret_pointer_cast(util::pmte::shared_pmte_value const & ptr) noexcept {
  if (ptr) {
    return std::shared_ptr<T>(ptr, reinterpret_cast<T *>(&ptr->get_unsafe<T>()));
  }
  return {};
}

#endif /* CPP14_STANDARD */

} // namespace util

#endif /* INCLUDE__UTIL_POINTER_CAST_HPP */
