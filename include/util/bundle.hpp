/**
 * @file bundle.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

static_assert(__cplusplus >= 201402, "Minimum required standard is C++14.");

#ifndef UTIL__BUNDLE_HPP
#define UTIL__BUNDLE_HPP

#ifdef _MSC_BUILD
#include <iso646.h>
#endif

#include <cassert>
#include <functional>
#include <iostream>
#include <memory>
#include <tuple>
#include <type_traits>

#include <util/attributes.hpp>
#include <util/shared_library.hpp>

namespace util {
template <typename... Types>
class bundle;

/**
 * Internal helpers for bundle.
 */
namespace detail {
template <bool...>
struct bool_pack;

template <bool... v>
using all_true = std::is_same<bool_pack<true, v...>, bool_pack<v..., true>>;

template <typename Type, typename OtherType>
struct is_really_same : std::is_same<typename std::decay<Type>::type, typename std::decay<OtherType>::type> {};

template <typename... Types>
struct not_all_same {
  template <typename... OtherTypes>
  struct with : std::integral_constant<bool, not all_true<is_really_same<Types, OtherTypes> {}...>::value> {};
};

/** @brief Compile time check if one class type is statically convertible to the
 * other type */
template <typename Derived, typename Base>
struct is_static_convertible
: std::integral_constant<bool, std::is_base_of<Base, Derived>::value and std::is_convertible<Derived *, Base *>::value> {};

/** @brief Compile time check if one class type could be dynamically convertible
 * to the other type */
template <typename Base, typename Derived>
struct is_dynamic_convertible
: std::integral_constant<bool, std::is_base_of<Base, Derived>::value and std::is_convertible<Derived *, Base *>::value> {};

/** @brief Compile time check if a list of class types are statically
 * convertible to another list of class types */
template <typename... Bases>
struct are_static_convertible {
  template <typename... Deriveds>
  struct from
  : std::integral_constant<bool,
      not_all_same<Bases...>::template with<Deriveds...>::value and all_true<is_static_convertible<Deriveds, Bases> {}...>::value> {};
};

/** @brief Compile time check if a list of class types could be dynamically
 * convertible to another list of class types */
template <typename... Deriveds>
struct are_dynamic_convertible {
  template <typename... Bases>
  struct from
  : std::integral_constant<bool,
      not_all_same<Bases...>::template with<Deriveds...>::value and all_true<is_dynamic_convertible<Bases, Deriveds> {}...>::value> {};
};

template <template <typename...> class BaseTemplate, typename Derived, typename TCheck = void>
struct test_base_template;

template <template <typename...> class BaseTemplate, typename Derived>
using is_base_template_of = typename test_base_template<BaseTemplate, Derived>::is_base;

template <template <typename...> class BaseTemplate, typename Derived>
struct test_base_template<BaseTemplate, Derived, std::enable_if_t<std::is_class<Derived>::value>> : Derived {
  template <typename... T>
  static constexpr std::true_type test(BaseTemplate<T...> *);
  static constexpr std::false_type test(...);
  using is_base = decltype(test((Derived *)nullptr));
  static constexpr bool value = is_base();
};

template <template <typename...> class BaseTemplate, typename Derived>
struct test_base_template<BaseTemplate, Derived, std::enable_if_t<!std::is_class<Derived>::value>> {
  using is_base = std::false_type;
  static constexpr bool value = is_base();
};

template <std::size_t I = 0, typename... Ts, typename OtherBundle>
inline typename std::enable_if<I == sizeof...(Ts), bundle<Ts...>>::type dynamic_pointer_cast(OtherBundle &&) noexcept {
  return {};
}

template <std::size_t I = 0, typename... Ts, typename OtherBundle>
  typename std::enable_if < I<sizeof...(Ts), bundle<Ts...>>::type dynamic_pointer_cast(OtherBundle && other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Ts...>>::type;
  auto && result = dynamic_pointer_cast<I + 1>(other);
  auto && other_element = other.template get<I>();
  if (other_element) {
    result.template get<I>() = std::dynamic_pointer_cast<element_type>(other_element->shared_from_this());
  }
  return result;
}

template <std::size_t I = 0, typename... Ts, typename OtherBundle>
inline typename std::enable_if<I == sizeof...(Ts), bundle<Ts...>>::type dynamic_pointer_cast(const OtherBundle &) noexcept {
  return {};
}

template <std::size_t I = 0, typename... Ts, typename OtherBundle>
  typename std::enable_if < I<sizeof...(Ts), bundle<Ts...>>::type dynamic_pointer_cast(const OtherBundle & other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Ts...>>::type;
  auto && result = dynamic_pointer_cast<I + 1>(other);
  auto && other_element = other.template get<I>();
  if (other_element) {
    result.template get<I>() = std::dynamic_pointer_cast<element_type>(other_element->shared_from_this());
  }
  return result;
}

} // namespace detail

/**
 * Helper class in case you want to implement multiple interfaces on the same
 * hierarchy.
 */
class enable_shared_from_this_virtual_base : public std::enable_shared_from_this<enable_shared_from_this_virtual_base> {
public:
  virtual ~enable_shared_from_this_virtual_base() noexcept = default;

private:
  using base_type = std::enable_shared_from_this<enable_shared_from_this_virtual_base>;
  template <typename T>
  friend struct enable_shared_from_this_virtual;
  template <typename... Types>
  friend class bundle;

  std::shared_ptr<enable_shared_from_this_virtual_base> shared_from_this() { return base_type::shared_from_this(); }

  std::shared_ptr<enable_shared_from_this_virtual_base const> shared_from_this() const { return base_type::shared_from_this(); }
};

/**
 * Class to use as base class if you want multiple interfaces on the same
 * hierarchy. Otherwise you need to use std::enable_shared_from_this<T>
 * directly.
 */
template <typename T>
struct enable_shared_from_this_virtual : virtual enable_shared_from_this_virtual_base {
  using base_type = enable_shared_from_this_virtual_base;

  enable_shared_from_this_virtual & operator=(enable_shared_from_this_virtual && rhs) noexcept {
    enable_shared_from_this_virtual_base::operator=(rhs);
    return *this;
  }

  std::shared_ptr<T> shared_from_this() { return std::shared_ptr<T>(base_type::shared_from_this(), dynamic_cast<T *>(this)); }

  std::shared_ptr<T const> shared_from_this() const {
    return std::shared_ptr<T const>(base_type::shared_from_this(), dynamic_cast<T const *>(this));
  }
};

/**
 * Pretty printing of bundles.
 */
struct bundle_printer {
  static void start_of_print(std::ostream &);

  template <std::size_t I = 0, typename... Types>
    static typename std::enable_if < I<sizeof...(Types) - 1, void>::type print_element(std::ostream &, bundle<Types...> const &);

  template <std::size_t I = 0, typename... Types>
  static typename std::enable_if<I == sizeof...(Types) - 1, void>::type print_element(std::ostream &, bundle<Types...> const &);

  static void end_of_print(std::ostream &);

  template <typename... Types>
  static void print(std::ostream &, bundle<Types...> const &);
};

/**
 * The purpose of this class is to bind multiple objects out of different class
 * hierarchies together in a polymorphic way. The bundle keeps the relationship
 * between the objects alive while moving or casting (up/down). A bundle points
 * internally to instances using shared_ptr using a tuple for storage.
 *
 * You can do static up-casting as well as dynamic down-casting; casting happens
 * on all pointers at the same time. If a downcast can't be performed the bundle
 * becomes null, which you should test before using any elements from the bundle
 * using bundle::operator bool() const.
 *
 * We advice to always use full bundles, with each element assigned and pointing
 * to a live instance; or have all elements null.
 *
 * @note When one element is NULL all elements will become NULL during a dynamic
 * cast.
 *
 * @tparam Types a variadic template list of types to bundle
 *
 * @internal It has been investigated to use a different, more compact and
 * generic implementation by publicly inheriting the bundle class from
 * std::tuple. However due to the specific GNU implementation (using private
 * inheritance and friend relationships) this is not possible.
 */
template <typename... Types>
class bundle {
public:
  static constexpr std::size_t size = sizeof...(Types);

  static_assert(std::enable_if_t<true, detail::all_true<std::is_class<Types> {}...>>::value, "All template arguments must be of a class type.");
  static_assert(std::enable_if_t<true, detail::all_true<std::has_virtual_destructor<Types> {}...>>::value,
    "Each element must have a virtual destructor.");
  static_assert(std::enable_if_t<true, detail::all_true<detail::is_base_template_of<std::enable_shared_from_this, Types> {}...>>::value,
    "Each element must have as its base class std::enable_shared_from_this "
    "(see "
    "https://en.cppreference.com/w/cpp/memory/enable_shared_from_this).");

  /**
   * Default constructor.
   */
  constexpr bundle() noexcept(std::enable_if_t<true, detail::all_true<std::is_nothrow_constructible<std::shared_ptr<Types>> {}...>>::value) {}
  /**
   * Initializing constructor (static cast)
   * @tparam OtherTypes types to convert from
   * @param args template parameter pack of shared_ptr
   */
  template <typename... OtherTypes, typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(OtherTypes) == sizeof...(Types)> * Condition = nullptr>
  bundle(std::shared_ptr<OtherTypes>... args);
  /**
   * Initializing constructor (static cast).
   * @param tuple a tuple containing similar types
   */
  bundle(const std::tuple<std::shared_ptr<Types>...> &);
  /**
   * Initializing constructor (static cast).
   * @param tuple a tuple containing similar types
   */
  bundle(std::tuple<std::shared_ptr<Types>...> &&);
  /**
   * Move constructor.
   */
  bundle(bundle<Types...> &&) noexcept(
    std::enable_if_t<true, detail::all_true<std::is_nothrow_move_constructible<std::shared_ptr<Types>> {}...>>::value) = default;
  /**
   * Copy constructor.
   */
  bundle(const bundle<Types...> &) = default;
  /**
   * Move initializing constructor (dynamic cast).
   *
   * An attempt will be made to cast the other bundle to our own type; if this
   * can't done, the state will be nullptr.
   * @tparam OtherTypes types to convert from
   * @tparam Condition Dynamic cast condition
   * @param other any other compatible bundle
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle(bundle<OtherTypes...> &&) noexcept;
  /**
   * Initializing constructor (dynamic cast).
   *
   * An attempt will be made to cast the other bundle to our own type; if this
   * can't done, the state will be nullptr.
   * @tparam OtherTypes types to convert from
   * @tparam Condition Dynamic cast condition
   * @param other any other compatible bundle
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle(const bundle<OtherTypes...> &);
  /**
   * Move initializing constructor (static cast).
   * @tparam OtherTypes types to convert from
   * @tparam Condition Static cast condition
   * @param other any other compatible bundle
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle(bundle<OtherTypes...> &&) noexcept;
  /**
   * Initializing constructor (static cast).
   * @tparam OtherTypes types to convert from
   * @tparam Condition Static cast condition
   * @param other any other compatible bundle
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle(const bundle<OtherTypes...> &);
  /**
   * Move assignment.
   */
  bundle<Types...> & operator=(bundle<Types...> &&) && noexcept = default;
  /**
   * Assignment.
   */
  bundle<Types...> & operator=(const bundle<Types...> &) & = default;
  /**
   * Move dynamic cast assignment.
   *
   * An attempt will be made to cast the other bundle to our own type; if this
   * can't done, the state will be nullptr.
   * @tparam OtherTypes types to convert from
   * @tparam Condition dynamic cast condition
   * @param other any other compatible bundle
   * @return self
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle<Types...> & operator=(bundle<OtherTypes...> &&) noexcept;
  /**
   * Dynamic cast assignment.
   *
   * An attempt will be made to cast the other bundle to our own type; if this
   * can't done, the state will be nullptr.
   * @tparam OtherTypes types to convert from
   * @tparam Condition dynamic cast condition
   * @param other any other compatible bundle
   * @return self
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle<Types...> & operator=(const bundle<OtherTypes...> &);
  /**
   * Move static cast assignment.
   * @tparam OtherTypes types to convert from
   * @tparam Condition Static cast condition
   * @param other any other compatible bundle
   * @return self
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle<Types...> & operator=(bundle<OtherTypes...> &&) noexcept;
  /**
   * Static cast assignment.
   * @tparam OtherTypes types to convert from
   * @tparam Condition static cast condition
   * @param other any other compatible bundle
   * @return self
   */
  template <typename... OtherTypes,
    typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
      detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition = nullptr>
  bundle<Types...> & operator=(const bundle<OtherTypes...> &);
  /**
   * Destructor.
   */
  virtual ~bundle() noexcept = default;
  /**
   * Returns true if all the stored elements are not null.
   */
  explicit operator bool() const noexcept;
  /**
   * Return reference to self.
   * @return reference to self
   */
  bundle & operator()() noexcept;
  /**
   * Return reference to self.
   * @return reference to self
   */
  const bundle & operator()() const noexcept;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & then(std::function<void()>) &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & then(std::function<void()>) const &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & then(std::function<void()>) &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & then(std::function<void()>) const &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & then(std::function<void(bundle &)>) &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & then(std::function<void(const bundle &)>) const &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & then(std::function<void(bundle &)>) &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & then(std::function<void(const bundle &)>) const &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & or_else(std::function<void()>) &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & or_else(std::function<void()>) const &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & or_else(std::function<void()>) &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & or_else(std::function<void()>) const &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & or_else(std::function<void(bundle &)>) &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & or_else(std::function<void(const bundle &)>) const &;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  bundle & or_else(std::function<void(bundle &)>) &&;
  /**
   * Nomad notation.
   * @param f function to call
   * @return reference to self
   */
  const bundle & or_else(std::function<void(const bundle &)>) const &&;
  /**
   * Cast to a tuple.
   */
  operator std::tuple<std::shared_ptr<Types>...>() const;
  /**
   * Provide access to an element.
   * @return pointer to object
   */
  template <std::size_t I>
  NO_DISCARD constexpr std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> & get() & noexcept;
  /**
   * Provide access to an element.
   * @return pointer to object
   */
  template <std::size_t I>
  NO_DISCARD constexpr std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> && get() && noexcept;
  /**
   * Provide access to an element.
   * @return pointer to object
   */
  template <std::size_t I>
  NO_DISCARD constexpr std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> const & get() const & noexcept;
  /**
   * Provide access to an element.
   * @return pointer to object
   */
  template <std::size_t I>
  NO_DISCARD constexpr std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> const && get() const && noexcept;
  /**
   * Releases owned objects and resets the pointers to null.
   */
  void reset() noexcept;
  /**
   * Compare equality.
   */
  template <typename... T>
  friend bool operator==(const bundle<T...> &, const bundle<T...> &);
  /**
   * Compare equality.
   */
  template <typename... T>
  friend bool operator!=(const bundle<T...> &, const bundle<T...> &);
  /**
   * Compare less than; useful for associative containers.
   */
  template <typename... T>
  friend bool operator<(const bundle<T...> &, const bundle<T...> &);
  /**
   * Stream operator
   */
  template <typename... T>
  friend std::ostream & operator<<(std::ostream &, bundle<T...> const &);

private:
  std::tuple<std::shared_ptr<Types>...> m_elements;

#if __cplusplus >= 201703L
  template <std::size_t I = 0>
  void reset_elements();
#else
  template <std::size_t I = 0>
  typename std::enable_if<I == sizeof...(Types) - 1, void>::type reset_elements();

  template <std::size_t I = 0>
    typename std::enable_if < I<sizeof...(Types) - 1, void>::type reset_elements();
#endif

  template <std::size_t I = 0, typename OtherBundle>
  typename std::enable_if<(I == sizeof...(Types) - 1) and
      not std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
    void>::type
    static_pointer_cast(const OtherBundle &) noexcept;

  template <std::size_t I = 0, typename OtherBundle>
  typename std::enable_if<(I == sizeof...(Types) - 1) and
      std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
    void>::type
    static_pointer_cast(const OtherBundle &) noexcept;

  template <std::size_t I = 0, typename OtherBundle>
  typename std::enable_if<(I < sizeof...(Types) - 1) and
      std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
    void>::type
    static_pointer_cast(const OtherBundle &) noexcept;

  template <std::size_t I = 0, typename OtherBundle>
  typename std::enable_if<(I < sizeof...(Types) - 1) and
      not std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
    void>::type
    static_pointer_cast(const OtherBundle &) noexcept;

  template <std::size_t I, typename OtherBundle>
  typename std::enable_if<I == sizeof...(Types), void>::type dynamic_pointer_cast(const OtherBundle &) noexcept;

  template <std::size_t I = 0, typename OtherBundle>
    typename std::enable_if < I<sizeof...(Types), void>::type dynamic_pointer_cast(const OtherBundle &) noexcept;

  template <std::size_t I>
  typename std::enable_if<I == sizeof...(Types), bool>::type check_bool() const noexcept;

  template <std::size_t I = 0>
    typename std::enable_if < I<sizeof...(Types), bool>::type check_bool() const noexcept;

  template <std::size_t I, typename OtherBundle>
  typename std::enable_if<I == sizeof...(Types), bool>::type compare_equality(const OtherBundle & other) const noexcept;

  template <std::size_t I = 0, typename OtherBundle>
    typename std::enable_if < I<sizeof...(Types), bool>::type compare_equality(const OtherBundle & other) const noexcept;

  template <std::size_t I, typename OtherBundle>
  typename std::enable_if<I == sizeof...(Types) - 1, bool>::type compare_less_than(const OtherBundle & other) const noexcept;

  template <std::size_t I = 0, typename OtherBundle>
    typename std::enable_if < I<sizeof...(Types) - 1, bool>::type compare_less_than(const OtherBundle & other) const noexcept;
};

template <typename... Ts, typename... OtherTypes>
bundle<Ts...> dynamic_pointer_cast(const bundle<OtherTypes...> & other) {
  auto && result = detail::dynamic_pointer_cast(other);
  if (not result) result.reset();
  return result;
}

template <typename... Ts, typename... OtherTypes>
bundle<Ts...> dynamic_pointer_cast(bundle<OtherTypes...> && other) {
  auto && result = detail::dynamic_pointer_cast(other);
  if (not result) result.reset();
  return result;
}

template <typename... Types>
template <typename... OtherTypes, typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(OtherTypes) == sizeof...(Types)> * Condition>
bundle<Types...>::bundle(std::shared_ptr<OtherTypes>... args) : m_elements(args...) {}

template <typename... Types>
bundle<Types...>::bundle(const std::tuple<std::shared_ptr<Types>...> & args) : m_elements(args) {}

template <typename... Types>
bundle<Types...>::bundle(std::tuple<std::shared_ptr<Types>...> && args) : m_elements(args) {}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...>::bundle(bundle<OtherTypes...> && other) noexcept {
  dynamic_pointer_cast(other);
  if (operator bool() == false) reset();
  other.reset();
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...>::bundle(const bundle<OtherTypes...> & other) {
  dynamic_pointer_cast(other);
  if (operator bool() == false) reset();
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...>::bundle(bundle<OtherTypes...> && other) noexcept {
  static_pointer_cast(other);
  other.reset();
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...>::bundle(const bundle<OtherTypes...> & other) {
  static_pointer_cast(other);
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...> & bundle<Types...>::operator=(bundle<OtherTypes...> && other) noexcept {
  dynamic_pointer_cast(other);
  if (operator bool() == false) reset();
  other.reset();
  return *this;
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_dynamic_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...> & bundle<Types...>::operator=(const bundle<OtherTypes...> & other) {
  dynamic_pointer_cast(other);
  if (operator bool() == false) reset();
  return *this;
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...> & bundle<Types...>::operator=(bundle<OtherTypes...> && other) noexcept {
  static_pointer_cast(other);
  other.reset();
  return *this;
}

template <typename... Types>
template <typename... OtherTypes,
  typename std::enable_if_t<sizeof...(Types) != 0 and sizeof...(Types) == sizeof...(OtherTypes) and
    detail::are_static_convertible<Types...>::template from<OtherTypes...>::value> * Condition>
bundle<Types...> & bundle<Types...>::operator=(const bundle<OtherTypes...> & other) {
  static_pointer_cast(other);
  return *this;
}

template <typename... Types>
bundle<Types...>::operator bool() const noexcept {
  return check_bool();
}

template <typename... Types>
inline bundle<Types...> & bundle<Types...>::operator()() noexcept {
  return *this;
}

template <typename... Types>
inline const bundle<Types...> & bundle<Types...>::operator()() const noexcept {
  return *this;
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::then(std::function<void()> f) & {
  if (check_bool()) f();
  return *this;
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::then(std::function<void()> f) const & {
  if (check_bool()) f();
  return *this;
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::then(std::function<void()> f) && {
  if (check_bool()) f();
  return std::move(*this);
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::then(std::function<void()> f) const && {
  if (check_bool()) f();
  return std::move(*this);
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::then(std::function<void(bundle &)> f) & {
  if (check_bool()) f(*this);
  return *this;
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::then(std::function<void(const bundle &)> f) const & {
  if (check_bool()) f(*this);
  return *this;
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::then(std::function<void(bundle &)> f) && {
  if (check_bool()) f(std::forward<bundle &&>(*this));
  return std::move(*this);
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::then(std::function<void(const bundle &)> f) const && {
  if (check_bool()) f(std::forward<const bundle &&>(*this));
  return std::move(*this);
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::or_else(std::function<void()> f) & {
  if (not check_bool()) f();
  return *this;
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::or_else(std::function<void()> f) const & {
  if (not check_bool()) f();
  return *this;
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::or_else(std::function<void()> f) && {
  if (not check_bool()) f();
  return std::move(*this);
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::or_else(std::function<void()> f) const && {
  if (not check_bool()) f();
  return std::move(*this);
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::or_else(std::function<void(bundle &)> f) & {
  if (not check_bool()) f(*this);
  return *this;
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::or_else(std::function<void(const bundle &)> f) const & {
  if (not check_bool()) f(*this);
  return *this;
}

template <typename... Types>
bundle<Types...> & bundle<Types...>::or_else(std::function<void(bundle &)> f) && {
  if (not check_bool()) f(std::forward<bundle &&>(*this));
  return std::move(*this);
}

template <typename... Types>
const bundle<Types...> & bundle<Types...>::or_else(std::function<void(const bundle &)> f) const && {
  if (not check_bool()) f(std::forward<const bundle &&>(*this));
  return std::move(*this);
}

template <typename... Types>
inline bundle<Types...>::operator std::tuple<std::shared_ptr<Types>...>() const {
  return m_elements;
}

template <typename... Types>
template <std::size_t I>
constexpr typename std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> & bundle<Types...>::get() & noexcept {
  return std::get<I>(m_elements);
}

template <typename... Types>
template <std::size_t I>
constexpr typename std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> && bundle<Types...>::get() && noexcept {
  return std::get<I>(m_elements);
}

template <typename... Types>
template <std::size_t I>
constexpr typename std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> const & bundle<Types...>::get() const & noexcept {
  return std::get<I>(m_elements);
}

template <typename... Types>
template <std::size_t I>
constexpr typename std::shared_ptr<typename std::tuple_element<I, std::tuple<Types...>>::type> const && bundle<Types...>::get() const && noexcept {
  return std::get<I>(m_elements);
}

template <typename... Types>
void bundle<Types...>::reset() noexcept {
  reset_elements();
}

#if __cplusplus >= 201703L
template <typename... Types>
template <std::size_t I>
void bundle<Types...>::reset_elements() {
  static_assert(I <= sizeof...(Types) - 1);
  std::get<I>(m_elements).reset();
  if constexpr (I < sizeof...(Types) - 1) {
    reset_elements<I + 1>();
  }
}
#else
template <typename... Types>
template <std::size_t I>
typename std::enable_if<I == sizeof...(Types) - 1, void>::type bundle<Types...>::reset_elements() {
  std::get<I>(m_elements).reset();
}

template <typename... Types>
  template <std::size_t I>
  typename std::enable_if < I<sizeof...(Types) - 1, void>::type bundle<Types...>::reset_elements() {
  std::get<I>(m_elements).reset();
  reset_elements<I + 1>();
}
#endif

template <typename... Types>
template <std::size_t I, typename OtherBundle>
typename std::enable_if<(I == sizeof...(Types) - 1) and
    not std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
  void>::type
  bundle<Types...>::static_pointer_cast(const OtherBundle & other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Types...>>::type;
  std::get<I>(m_elements) = other.template get<I>() ? std::static_pointer_cast<element_type>(other.template get<I>()->shared_from_this()) : nullptr;
}

template <typename... Types>
template <std::size_t I, typename OtherBundle>
typename std::enable_if<(I == sizeof...(Types) - 1) and
    std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
  void>::type
  bundle<Types...>::static_pointer_cast(const OtherBundle & other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Types...>>::type;
  std::get<I>(m_elements) = other.template get<I>() ?
    std::dynamic_pointer_cast<element_type>(other.template get<I>()->enable_shared_from_this_virtual_base::shared_from_this()) :
    nullptr;
}

template <typename... Types>
template <std::size_t I, typename OtherBundle>
typename std::enable_if<(I < sizeof...(Types) - 1) and
    not std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
  void>::type
  bundle<Types...>::static_pointer_cast(const OtherBundle & other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Types...>>::type;
  std::get<I>(m_elements) = other.template get<I>() ? std::static_pointer_cast<element_type>(other.template get<I>()->shared_from_this()) : nullptr;
  static_pointer_cast<I + 1>(other);
}

template <typename... Types>
template <std::size_t I, typename OtherBundle>
typename std::enable_if<(I < sizeof...(Types) - 1) and
    std::is_base_of<enable_shared_from_this_virtual_base, typename std::tuple_element<I, std::tuple<Types...>>::type>::value,
  void>::type
  bundle<Types...>::static_pointer_cast(const OtherBundle & other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Types...>>::type;
  std::get<I>(m_elements) = other.template get<I>() ?
    std::dynamic_pointer_cast<element_type>(other.template get<I>()->enable_shared_from_this_virtual_base::shared_from_this()) :
    nullptr;
  static_pointer_cast<I + 1>(other);
}

template <typename... Types>
template <std::size_t I, typename OtherBundle>
inline typename std::enable_if<I == sizeof...(Types), void>::type bundle<Types...>::dynamic_pointer_cast(const OtherBundle &) noexcept {
  return;
}

template <typename... Types>
  template <std::size_t I, typename OtherBundle>
  typename std::enable_if < I<sizeof...(Types), void>::type bundle<Types...>::dynamic_pointer_cast(const OtherBundle & other) noexcept {
  using element_type = typename std::tuple_element<I, std::tuple<Types...>>::type;
  std::get<I>(
    m_elements) = other.template get<I>() ? std::dynamic_pointer_cast<element_type>(other.template get<I>()->shared_from_this()) : nullptr;
  dynamic_pointer_cast<I + 1>(other);
}

template <typename... Types>
template <std::size_t I>
inline typename std::enable_if<I == sizeof...(Types), bool>::type bundle<Types...>::check_bool() const noexcept {
  return true;
}

template <typename... Types>
  template <std::size_t I>
  typename std::enable_if < I<sizeof...(Types), bool>::type bundle<Types...>::check_bool() const noexcept {
  return static_cast<bool>(std::get<I>(m_elements)) and check_bool<I + 1>();
}

template <typename... Types>
template <std::size_t I, typename OtherBundle>
inline typename std::enable_if<I == sizeof...(Types), bool>::type bundle<Types...>::compare_equality(const OtherBundle &) const noexcept {
  return true;
}

template <typename... Types>
  template <std::size_t I, typename OtherBundle>
  typename std::enable_if < I<sizeof...(Types), bool>::type bundle<Types...>::compare_equality(const OtherBundle & other) const noexcept {
  return std::get<I>(m_elements) == other.template get<I>() && compare_equality<I + 1>(other);
}

template <typename... Types>
template <std::size_t I, typename OtherBundle>
typename std::enable_if<I == sizeof...(Types) - 1, bool>::type bundle<Types...>::compare_less_than(const OtherBundle & other) const noexcept {
  return std::get<I>(m_elements) < other.template get<I>();
}

template <typename... Types>
  template <std::size_t I, typename OtherBundle>
  typename std::enable_if < I<sizeof...(Types) - 1, bool>::type bundle<Types...>::compare_less_than(const OtherBundle & other) const noexcept {
  if (std::get<I>(m_elements) < other.template get<I>()) return true;
  if (other.template get<I>() < std::get<I>(m_elements)) return false;
  return compare_equality<I + 1>(other);
}

inline void bundle_printer::start_of_print(std::ostream & out) {
  out << '(';
}

template <std::size_t I, typename... Types>
  typename std::enable_if < I<sizeof...(Types) - 1, void>::type bundle_printer::print_element(std::ostream & out, bundle<Types...> const & o) {
  if (o.template get<I>()) out << o.template get<I>();
  else
    out << "nullptr";
  out << ',';
  print_element<I + 1>(out, o);
}

template <std::size_t I, typename... Types>
typename std::enable_if<I == sizeof...(Types) - 1, void>::type bundle_printer::print_element(std::ostream & out, bundle<Types...> const & o) {
  if (o.template get<I>()) out << o.template get<I>();
  else
    out << "nullptr";
}

inline void bundle_printer::end_of_print(std::ostream & out) {
  out << ')';
}

template <typename... Types>
void bundle_printer::print(std::ostream & out, bundle<Types...> const & o) {
  start_of_print(out);
  print_element(out, o);
  end_of_print(out);
}

template <typename... Types>
NO_DISCARD bool operator==(bundle<Types...> const & lhs, bundle<Types...> const & rhs) {
  return &lhs == &rhs ? true : lhs.compare_equality(rhs);
}

template <typename... Types>
NO_DISCARD bool operator!=(bundle<Types...> const & lhs, bundle<Types...> const & rhs) {
  return &lhs == &rhs ? false : not lhs.compare_equality(rhs);
}

template <typename... Types>
NO_DISCARD bool operator<(bundle<Types...> const & lhs, bundle<Types...> const & rhs) {
  return &lhs == &rhs ? false : lhs.compare_less_than(rhs);
}

template <typename... Types>
std::ostream & operator<<(std::ostream & out, bundle<Types...> const & o) {
  bundle_printer::print(out, o);
  return out;
}

} // namespace util

#endif /* UTIL__BUNDLE_HPP */
