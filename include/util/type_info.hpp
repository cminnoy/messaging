/**
 * @file type_info.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__UTIL__TYPE_INFO_HPP
#define INCLUDE__UTIL__TYPE_INFO_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <typeinfo>
#include <type_traits>

#include <util/traits.hpp>
#include <util/algorithm.hpp>

/**
 * @file
 * 
 * Runtime type information system
 */

namespace util {

struct type_base;

/**
 * Trait information of the payload type.
 */
struct trait_info final {
  const std::size_t hash_code;
  const trait_info & const_traits;
  const std::size_t size;
  const decltype(type_name<void>()) name;
  const std::type_info & type_info;
  const bool is_void                    : 1;
  const bool is_null_pointer            : 1;
  const bool is_integral                : 1;
  const bool is_floating_point          : 1;
  const bool is_array                   : 1;
  const bool is_enum                    : 1;
  const bool is_union                   : 1;
  const bool is_class                   : 1;
  const bool is_function                : 1;
  const bool is_pointer                 : 1;
  const bool is_lvalue_reference        : 1;
  const bool is_rvalue_reference        : 1;
  const bool is_member_object_pointer   : 1;
  const bool is_member_function_pointer : 1;
  const bool is_fundamental             : 1;
  const bool is_arithmetic              : 1;
  const bool is_scalar                  : 1;
  const bool is_object                  : 1;
  const bool is_compound                : 1;
  const bool is_reference               : 1;
  const bool is_member_pointer          : 1;
  const bool is_const                   : 1;
  const bool is_volatile                : 1;
  const bool is_trivial                 : 1;
  const bool is_trivially_copyable      : 1;
  const bool is_standard_layout         : 1;
#if __cplusplus < CPP20_STANDARD
  const bool is_pod : 1;
#endif
#if __cplusplus < CPP17_STANDARD
  const bool is_literal_type : 1;
#endif
#if __cplusplus >= CPP17_STANDARD
  const bool has_unique_object_representations : 1;
#endif
  const bool is_empty       : 1;
  const bool is_polymorphic : 1;
  const bool is_abstract    : 1;

#if __cplusplus >= CPP14_STANDARD
  const bool is_final : 1;
#endif
#if __cplusplus >= CPP17_STANDARD
  const bool is_aggregate : 1;
#endif
  const bool is_signed   : 1;
  const bool is_unsigned : 1;
#if __cplusplus >= CPP20_STANDARD
  const bool is_bounded_array   : 1;
  const bool is_unbounded_array : 1;
#endif
#if __cplusplus >= CPP23_STANDARD
  const bool is_scoped_enum : 1;
#endif
  const bool is_default_constructible           : 1;
  const bool is_trivially_default_constructible : 1;
  const bool is_nothrow_default_constructible   : 1;
  const bool is_copy_constructible              : 1;
  const bool is_trivially_copy_constructible    : 1;
  const bool is_nothrow_copy_constructible      : 1;
  const bool is_move_constructible              : 1;
  const bool is_trivially_move_constructible    : 1;
  const bool is_nothrow_move_constructible      : 1;
  const bool is_copy_assignable                 : 1;
  const bool is_triviallly_copy_assignable      : 1;
  const bool is_move_assignable                 : 1;
  const bool is_trivially_move_assignable       : 1;
  const bool is_nothrow_move_assignable         : 1;
  const bool is_destructible                    : 1;
  const bool is_trivially_destructible          : 1;
  const bool is_nothrow_destructible            : 1;
  const bool has_virtual_destructor             : 1;
#if __cplusplus >= CPP17_STANDARD
  const bool is_swappable         : 1;
  const bool is_nothrow_swappable : 1;
#endif
};

NO_DISCARD FORCE_INLINE constexpr bool operator==(trait_info const & lhs, trait_info const & rhs) noexcept {
  return lhs.hash_code == rhs.hash_code;
}

/**
 * General base class for type_info refering to the trait information of the designated type.
 */
struct type_base {
  template <typename T>
  friend struct type_info; //!< Give access to private init constructor

  const trait_info & traits; //!< Read-only trait information of the designated type.

  constexpr type_base(type_base &&) noexcept = default; //!< Default move constructor
  constexpr type_base(type_base const &) noexcept = default; //!< Default copy constructor
  constexpr type_base & operator=(type_base &&) noexcept = delete; //!< Default move assignment operator
  constexpr type_base & operator=(type_base const &) = delete; //!< Default copy assignment operator

  /**
   * @brief Compare if both designated types are the same.
   * @return true if this type is the same as the other type using their hash
   */
  NO_DISCARD FORCE_INLINE constexpr bool has_same_type(type_base const & type) const noexcept {
    return traits.hash_code == type.traits.hash_code;
  }

private:

  constexpr explicit type_base(const trait_info & traits_) noexcept : traits(traits_) {} //!< Init constructor, to be called by type_info<T>
};

/**
 * Compare equal operator.
 * @return lhs == rhs
 */
NO_DISCARD FORCE_INLINE constexpr bool operator==(type_base const & lhs, type_base const & rhs) noexcept {
  return lhs.has_same_type(rhs);
}

/**
 * Compare not equal operator.
 * @return lhs != rhs
 */
NO_DISCARD constexpr bool operator!=(type_base const & lhs, type_base const & rhs) noexcept {
  return !lhs.has_same_type(rhs);
}

/**
 * Compare less operator helper for associative containers.
 * @return lhs < rhs
 */
NO_DISCARD constexpr bool operator<(type_base const & lhs, type_base const & rhs) noexcept {
  return lhs.traits.hash_code < rhs.traits.hash_code;
}

//---------------------------------------------------------------------------------------------------------------------

template <typename T>
struct type_info final : type_base {
  using type = T;

  // clang-format off
  using const_type = typename std::conditional<std::is_lvalue_reference<T>::value,
                                              std::add_lvalue_reference_t<std::add_const_t<std::remove_reference_t<T>>>,
                                              typename std::conditional<std::is_rvalue_reference<T>::value,
                                                       std::add_rvalue_reference_t<std::add_const_t<std::remove_reference_t<T>>>,
                                                       std::add_const_t<T>
                                              >::type
                                              >::type;
  // clang-format on

  constexpr type_info() noexcept : type_base(trait_data) {}

  template <typename U>
  friend constexpr bool is_type_of(type_base const & o) noexcept;

  template <typename U>
  friend struct type_info;

private:

#if __cplusplus >= CPP20_STANDARD
  template <typename U = T>
  constexpr static std::enable_if_t<std::is_void_v<U> || std::is_unbounded_array_v<U> || std::is_function_v<U>, std::size_t> size() noexcept {
    return 0;
  }

  template <typename U = T>
  constexpr static std::enable_if_t<!std::is_void_v<U> && !std::is_unbounded_array_v<U> && !std::is_function_v<U>, std::size_t> size() noexcept {
    return sizeof(T);
  }
#else
  template <typename U = T>
  constexpr static std::enable_if_t<std::is_void<U>::value || std::is_array<U>::value || std::is_function<U>::value, std::size_t> size() noexcept {
    return 0;
  }

  template <typename U = T>
  constexpr static std::enable_if_t<!std::is_void<U>::value && !std::is_array<U>::value && !std::is_function<U>::value, std::size_t> size() noexcept {
    return sizeof(T);
  }
#endif

  // clang-format off
  static constexpr trait_info trait_data {
#ifdef PLATFORM_IS64BIT
    .hash_code = util::hash_fnv1a_64(type_name<T>()),
#else
    .hash_code = util::hash_fnv1a_32(type_name<T>()),
#endif
    .const_traits = type_info<const_type>::trait_data,
    .size = size<T>(),
    .name = type_name<T>(),
    .type_info = typeid(T),
    .is_void = std::is_void<T>::value,
    .is_null_pointer = std::is_null_pointer<T>::value,
    .is_integral = std::is_integral<T>::value,
    .is_floating_point = std::is_floating_point<T>::value,
    .is_array = std::is_array<T>::value,
    .is_enum = std::is_enum<T>::value,
    .is_union = std::is_union<T>::value,
    .is_class = std::is_class<T>::value,
    .is_function = std::is_function<T>::value,
    .is_pointer = std::is_pointer<T>::value,
    .is_lvalue_reference = std::is_lvalue_reference<T>::value,
    .is_rvalue_reference = std::is_rvalue_reference<T>::value,
    .is_member_object_pointer = std::is_member_object_pointer<T>::value,
    .is_member_function_pointer = std::is_member_function_pointer<T>::value,
    .is_fundamental = std::is_fundamental<T>::value,
    .is_arithmetic = std::is_arithmetic<T>::value,
    .is_scalar = std::is_scalar<T>::value,
    .is_object = std::is_object<T>::value,
    .is_compound = std::is_compound<T>::value,
    .is_reference = std::is_reference<T>::value,
    .is_member_pointer = std::is_member_pointer<T>::value,
    .is_const = std::is_const<T>::value,
    .is_volatile = std::is_volatile<T>::value,
    .is_trivial = std::is_trivial<T>::value,
    .is_trivially_copyable = std::is_trivially_copyable<T>::value,
    .is_standard_layout = std::is_standard_layout<T>::value,
#if __cplusplus < CPP20_STANDARD
    .is_pod = std::is_standard_layout<T>::value && std::is_trivial<T>::value,
#endif
#if __cplusplus < CPP17_STANDARD
    .is_literal_type = std::is_literal_type<T>::value,
#endif
#if __cplusplus >= CPP17_STANDARD
    .has_unique_object_representations = std::has_unique_object_representations<T>::value,
#endif
    .is_empty = std::is_empty<T>::value,
    .is_polymorphic = std::is_polymorphic<T>::value,
    .is_abstract = std::is_abstract<T>::value,
#if __cplusplus >= CPP14_STANDARD
    .is_final = std::is_final<T>::value,
#endif
#if __cplusplus >= CPP17_STANDARD
    .is_aggregate = std::is_aggregate<T>::value,
#endif
    .is_signed = std::is_signed<T>::value, .is_unsigned = std::is_unsigned<T>::value,
#if __cplusplus >= CPP20_STANDARD
    .is_bounded_array = std::is_bounded_array<T>::value, .is_unbounded_array = std::is_unbounded_array<T>::value,
#endif
#if __cplusplus >= CPP23_STANDARD
    .is_scoped_enum = std::is_scoped_enum<T>::value,
#endif
    .is_default_constructible = std::is_default_constructible<T>::value,
    .is_trivially_default_constructible = std::is_trivially_default_constructible<T>::value,
    .is_nothrow_default_constructible = std::is_nothrow_default_constructible<T>::value,
    .is_copy_constructible = std::is_copy_constructible<T>::value,
    .is_trivially_copy_constructible = std::conditional_t<std::is_same<T, void>::value || std::is_same<T, std::add_const_t<void>>::value, std::false_type, typename std::is_trivially_copy_constructible<T>>::value,
    .is_nothrow_copy_constructible = std::is_nothrow_copy_constructible<T>::value,
    .is_move_constructible = std::is_move_constructible<T>::value,
    .is_trivially_move_constructible = std::conditional_t<std::is_same<T, void>::value || std::is_same<T, std::add_const_t<void>>::value, std::false_type, typename std::is_trivially_move_constructible<T>>::value,
    .is_nothrow_move_constructible = std::is_nothrow_move_constructible<T>::value,
    .is_copy_assignable = std::is_copy_assignable<T>::value,
    .is_triviallly_copy_assignable = std::conditional_t<std::is_same<T, void>::value || std::is_same<T, std::add_const_t<void>>::value, std::false_type, typename std::is_trivially_copy_assignable<T>>::value,
    .is_move_assignable = std::is_move_assignable<T>::value,
    .is_trivially_move_assignable = std::conditional_t<std::is_same<T, void>::value || std::is_same<T, std::add_const_t<void>>::value, std::false_type, typename std::is_trivially_move_assignable<T>>::value,
    .is_nothrow_move_assignable = std::is_nothrow_move_assignable<T>::value,
    .is_destructible = std::is_destructible<T>::value,
    .is_trivially_destructible = std::is_trivially_destructible<T>::value,
    .is_nothrow_destructible = std::is_nothrow_destructible<T>::value,
    .has_virtual_destructor = std::has_virtual_destructor<T>::value,
#if __cplusplus >= CPP17_STANDARD
    .is_swappable = std::is_swappable<T>::value,
    .is_nothrow_swappable = std::is_nothrow_swappable<T>::value
#endif
  };
  // clang-format on
};

template <typename T>
constexpr trait_info type_info<T>::trait_data;

// clang-format off
NO_DISCARD constexpr std::size_t get_hash_code(type_base const& type) noexcept { return type.traits.hash_code; }
NO_DISCARD constexpr std::size_t get_const_hash_code(type_base const& type) noexcept { return type.traits.const_traits.hash_code; }
NO_DISCARD constexpr const trait_info& get_const_traits(type_base const& type) noexcept { return type.traits.const_traits; }
NO_DISCARD constexpr const trait_info& get_const_traits(trait_info const& type) noexcept { return type.const_traits; }
NO_DISCARD constexpr std::size_t get_size(type_base const& type) noexcept { return type.traits.size; }
NO_DISCARD constexpr const std::type_info & get_type_info(type_base const& type) noexcept { return type.traits.type_info; }

#if __cplusplus >= CPP17_STANDARD
NO_DISCARD constexpr std::string_view get_name(type_base const& type) noexcept { return type.traits.name; }
#else
NO_DISCARD constexpr decltype(type_name<void>()) get_name(type_base const &type) noexcept { return type.traits.name; }
#endif

NO_DISCARD constexpr bool is_void(type_base const &type) noexcept { return type.traits.is_void; }
NO_DISCARD constexpr bool is_null_pointer(type_base const &type) noexcept { return type.traits.is_null_pointer; }
NO_DISCARD constexpr bool is_integral(type_base const &type) noexcept { return type.traits.is_integral; }
NO_DISCARD constexpr bool is_floating_point(type_base const &type) noexcept { return type.traits.is_floating_point; }
NO_DISCARD constexpr bool is_array(type_base const &type) noexcept { return type.traits.is_array; }
NO_DISCARD constexpr bool is_enum(type_base const &type) noexcept { return type.traits.is_enum; }
NO_DISCARD constexpr bool is_union(type_base const &type) noexcept { return type.traits.is_union; }
NO_DISCARD constexpr bool is_class(type_base const &type) noexcept { return type.traits.is_class; }
NO_DISCARD constexpr bool is_function(type_base const &type) noexcept { return type.traits.is_function; }
NO_DISCARD constexpr bool is_pointer(type_base const &type) noexcept { return type.traits.is_pointer; }
NO_DISCARD constexpr bool is_lvalue_reference(type_base const &type) noexcept { return type.traits.is_lvalue_reference; }
NO_DISCARD constexpr bool is_rvalue_reference(type_base const &type) noexcept { return type.traits.is_rvalue_reference; }
NO_DISCARD constexpr bool is_member_object_pointer(type_base const &type) noexcept { return type.traits.is_member_object_pointer; }
NO_DISCARD constexpr bool is_member_function_pointer(type_base const &type) noexcept { return type.traits.is_member_function_pointer; }
NO_DISCARD constexpr bool is_fundamental(type_base const &type) noexcept { return type.traits.is_fundamental; }
NO_DISCARD constexpr bool is_arithmetic(type_base const &type) noexcept { return type.traits.is_arithmetic; }
NO_DISCARD constexpr bool is_scalar(type_base const &type) noexcept { return type.traits.is_scalar; }
NO_DISCARD constexpr bool is_object(type_base const &type) noexcept { return type.traits.is_object; }
NO_DISCARD constexpr bool is_compound(type_base const &type) noexcept { return type.traits.is_compound; }
NO_DISCARD constexpr bool is_reference(type_base const &type) noexcept { return type.traits.is_reference; }
NO_DISCARD constexpr bool is_member_pointer(type_base const &type) noexcept { return type.traits.is_member_pointer; }
NO_DISCARD constexpr bool is_const(type_base const &type) noexcept { return type.traits.is_const; }
NO_DISCARD constexpr bool is_volatile(type_base const &type) noexcept { return type.traits.is_volatile; }
NO_DISCARD constexpr bool is_trivial(type_base const &type) noexcept { return type.traits.is_trivial; }
NO_DISCARD constexpr bool is_trivially_copyable(type_base const &type) noexcept { return type.traits.is_trivially_copyable; }
NO_DISCARD constexpr bool is_standard_layout(type_base const &type) noexcept { return type.traits.is_standard_layout; }
#if __cplusplus < CPP20_STANDARD
NO_DISCARD constexpr bool is_pod(type_base const &type) noexcept { return type.traits.is_pod; }
#endif
#if __cplusplus < CPP17_STANDARD
NO_DISCARD constexpr bool is_literal_type(type_base const &type) noexcept { return type.traits.is_literal_type; }
#endif
#if __cplusplus >= CPP17_STANDARD
NO_DISCARD constexpr bool has_unique_object_representations(type_base const &type) noexcept { return type.traits.has_unique_object_representations; }
#endif
NO_DISCARD constexpr bool is_empty(type_base const &type) noexcept { return type.traits.is_empty; }
NO_DISCARD constexpr bool is_polymorphic(type_base const &type) noexcept { return type.traits.is_polymorphic; }
NO_DISCARD constexpr bool is_abstract(type_base const &type) noexcept { return type.traits.is_abstract; }
#if __cplusplus >= CPP14_STANDARD
NO_DISCARD constexpr bool is_final(type_base const &type) noexcept { return type.traits.is_final; }
#endif
#if __cplusplus >= CPP17_STANDARD
NO_DISCARD constexpr bool is_aggregate(type_base const &type) noexcept { return type.traits.is_aggregate; }
#endif
NO_DISCARD constexpr bool is_signed(type_base const &type) noexcept { return type.traits.is_signed; }
NO_DISCARD constexpr bool is_unsigned(type_base const &type) noexcept { return type.traits.is_unsigned; }
#if __cplusplus >= CPP20_STANDARD
NO_DISCARD constexpr bool is_bounded_array(type_base const &type) noexcept { return type.traits.is_bounded_array; }
NO_DISCARD constexpr bool is_unbounded_array(type_base const &type) noexcept { return type.traits.is_unbounded_array; }
#endif
#if __cplusplus >= CPP23_STANDARD
NO_DISCARD constexpr bool is_scoped_enum(type_info_base const &type) noexcept { return type.traits.is_scoped_enum; }
#endif
NO_DISCARD constexpr bool is_default_constructible(type_base const &type) noexcept { return type.traits.is_default_constructible; }
NO_DISCARD constexpr bool is_trivially_default_constructible(type_base const &type) noexcept { return type.traits.is_trivially_default_constructible; }
NO_DISCARD constexpr bool is_nothrow_default_constructible(type_base const &type) noexcept { return type.traits.is_nothrow_default_constructible; }
NO_DISCARD constexpr bool is_copy_constructible(type_base const &type) noexcept { return type.traits.is_copy_constructible; }
NO_DISCARD constexpr bool is_trivially_copy_constructible(type_base const &type) noexcept { return type.traits.is_trivially_copy_constructible; }
NO_DISCARD constexpr bool is_nothrow_copy_constructible(type_base const &type) noexcept { return type.traits.is_nothrow_copy_constructible; }
NO_DISCARD constexpr bool is_move_constructible(type_base const &type) noexcept { return type.traits.is_move_constructible; }
NO_DISCARD constexpr bool is_trivially_move_constructible(type_base const &type) noexcept { return type.traits.is_trivially_move_constructible; }
NO_DISCARD constexpr bool is_nothrow_move_constructible(type_base const &type) noexcept { return type.traits.is_nothrow_move_constructible; }
NO_DISCARD constexpr bool is_copy_assignable(type_base const &type) noexcept { return type.traits.is_copy_assignable; }
NO_DISCARD constexpr bool is_trivially_copy_assignable(type_base const &type) noexcept { return type.traits.is_triviallly_copy_assignable; }
NO_DISCARD constexpr bool is_move_assignable(type_base const &type) noexcept { return type.traits.is_move_assignable; }
NO_DISCARD constexpr bool is_trivially_move_assignable(type_base const &type) noexcept { return type.traits.is_trivially_move_assignable; }
NO_DISCARD constexpr bool is_nothrow_move_assignable(type_base const &type) noexcept { return type.traits.is_nothrow_move_assignable; }
NO_DISCARD constexpr bool is_destructible(type_base const &type) noexcept { return type.traits.is_destructible; }
NO_DISCARD constexpr bool is_trivially_destructible(type_base const &type) noexcept { return type.traits.is_trivially_destructible; }
NO_DISCARD constexpr bool is_nothrow_destructible(type_base const &type) noexcept { return type.traits.is_nothrow_destructible; }
NO_DISCARD constexpr bool has_virtual_destructor(type_base const &type) noexcept { return type.traits.has_virtual_destructor; }
#if __cplusplus >= CPP17_STANDARD
NO_DISCARD constexpr bool is_swappable(type_base const &type) noexcept { return type.traits.is_swappable; }
NO_DISCARD constexpr bool is_nothrow_swappable(type_base const &type) noexcept { return type.traits.is_nothrow_swappable; }
#endif
// clang-format on

std::ostream & operator<<(std::ostream & out, type_base const & type);

//---------------------------------------------------------------------------------------------------------------------
// is_type_of
//---------------------------------------------------------------------------------------------------------------------

template <typename U>
NO_DISCARD FORCE_INLINE constexpr bool is_type_of(type_base const & o) noexcept {
  return type_info<U>::trait_data.hash_code == o.traits.hash_code;
}

template <typename T>
NO_DISCARD constexpr bool is_type_of(type_base const * const p) noexcept {
  return p && is_type_of<T>(*p);
}

//---------------------------------------------------------------------------------------------------------------------
// predefined types
//---------------------------------------------------------------------------------------------------------------------

extern template struct type_info<bool>;
extern template struct type_info<char>;
extern template struct type_info<signed char>;
extern template struct type_info<unsigned char>;
extern template struct type_info<signed short int>;
extern template struct type_info<unsigned short int>;
extern template struct type_info<signed int>;
extern template struct type_info<unsigned int>;
extern template struct type_info<signed long int>;
extern template struct type_info<unsigned long int>;
extern template struct type_info<signed long long int>;
extern template struct type_info<unsigned long long int>;
extern template struct type_info<float>;
extern template struct type_info<double>;
extern template struct type_info<long double>;
extern template struct type_info<void *>;
extern template struct type_info<char *>;
extern template struct type_info<signed char *>;
extern template struct type_info<unsigned char *>;
extern template struct type_info<signed short int *>;
extern template struct type_info<unsigned short int *>;
extern template struct type_info<signed int *>;
extern template struct type_info<unsigned int *>;
extern template struct type_info<signed long int *>;
extern template struct type_info<unsigned long int *>;
extern template struct type_info<signed long long int *>;
extern template struct type_info<unsigned long long int *>;
extern template struct type_info<float *>;
extern template struct type_info<double *>;
extern template struct type_info<long double *>;

} // namespace util

#endif /* INCLUDE__UTIL__TYPE_INFO_HPP */
