/**
 * @file pmte.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__UTIL__PMTE_HPP
#define INCLUDE__UTIL__PMTE_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <memory>
#include <utility>
#include <functional>
#include <iomanip>
#include <string>
#include <algorithm>
#include <typeinfo>
#include <forward_list>
#include <vector>
#include <type_traits>

#if __cplusplus >= CPP17_STANDARD
#include <string_view>

#if __has_include(<memory_resource>)
#include <memory_resource>
#endif

#endif

#include <util/algorithm.hpp>
#include <util/type_list.hpp>


/**
 * @file
 * 
 * Polymorphic Type Erasure (PmTE)
 * 
 * PmTE allows you to wrap concrete types in a polymorphic way by using the known idiom of type erasure.
 * It allows to write type open systems.
 *
 * If you don't need a completly open and dynamic type system you may consider std::variant/std::visit.
 * std::variant however only works with a known closed set of types.
 *
 * PmTE may be a bit slower than std::variant/std::visit, but is more flexible.
 */

namespace util {

namespace pmte {

//---------------------------------------------------------------------------------------------------------------------
// base class of all PMTE types
//---------------------------------------------------------------------------------------------------------------------

namespace detail {

struct base {
  CPP20_CONSTEXPR virtual ~base() noexcept(true) {}
  NO_DISCARD CPP20_CONSTEXPR virtual type_base type() const noexcept = 0;
  NO_DISCARD CPP20_CONSTEXPR virtual std::size_t size() const noexcept = 0;
  virtual std::ostream & print(std::ostream & out) const;
};

inline std::ostream & operator<<(std::ostream & out, base const & o) {
  return o.print(out);
}

} // namespace detail

//---------------------------------------------------------------------------------------------------------------------
// value interface
//---------------------------------------------------------------------------------------------------------------------

struct pmte_value : detail::base {
  NO_DISCARD CPP20_CONSTEXPR virtual bool is_castable_to(const type_base &) const noexcept = 0;
  NO_DISCARD CPP20_CONSTEXPR virtual int index(type_base const &) const noexcept = 0;
  NO_DISCARD virtual pmte_value * clone(void * address = nullptr) const = 0;

  template <typename T1, typename... Ts>
  decltype(auto) get_if() noexcept {
    return get_if_<0, util::common_type_t<T1, Ts...>, std::tuple<T1, Ts...>>();
  }

  template <typename T1, typename... Ts>
  decltype(auto) get_if() const noexcept {
    return get_if_<0, util::common_type_t<const T1, const Ts...>, std::tuple<const T1, const Ts...>>();
  }

  template <typename T>
  NO_DISCARD FORCE_INLINE constexpr T & get_unsafe() noexcept;

  template <typename T>
  NO_DISCARD FORCE_INLINE constexpr const T & get_unsafe() const noexcept;

protected:

  NO_DISCARD virtual void * raw_access() noexcept = 0;
  NO_DISCARD virtual const void * raw_access() const noexcept = 0;

private:

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R get_if_() noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<!std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R * get_if_() noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R get_if_() const noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<!std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R * get_if_() const noexcept;
#else
  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr> R
      get_if_() noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R get_if_() noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
      R * get_if_() noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R * get_if_() noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr> R
      get_if_() const noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R get_if_() const noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
      R * get_if_() const noexcept;

  template <std::size_t I = 0, typename R, typename Types,
    typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> * = nullptr>
  R * get_if_() const noexcept;
#endif
};

using shared_pmte_value = std::shared_ptr<pmte_value>;
using unique_pmte_value = std::unique_ptr<pmte_value>;

//---------------------------------------------------------------------------------------------------------------------
// value store
//---------------------------------------------------------------------------------------------------------------------

namespace detail {

template <typename T, typename = void>
struct value_store {
  using element_type = T;
  value_store() = delete;
  value_store(const value_store &) = delete;
  value_store & operator=(const value_store &) noexcept = delete;
  ~value_store() noexcept = delete;
};

template <typename T>
struct value_store<T,
  typename std::enable_if_t<std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value>>
: pmte_value {
  static_assert(!std::is_volatile<T>::value, "'volatile' is not supported");
  using element_type = T;

  constexpr explicit value_store() noexcept : value {} {}
  template <typename U>
  constexpr explicit value_store(U && v_) noexcept : value(std::forward<U>(v_)) {}
  constexpr explicit value_store(T && v_) noexcept : value(std::forward<T>(v_)) {}
  constexpr value_store(value_store && other) noexcept : value(other.value) {}
  constexpr value_store(value_store const & other) noexcept : value(other.value) {}
  constexpr value_store & operator=(value_store && other) noexcept {
    value = other.value;
    return *this;
  }
  constexpr value_store & operator=(value_store const & other) noexcept {
    value = other.value;
    return *this;
  }

  operator T &() noexcept { return value; }
  operator const T &() const noexcept { return value; }

  NO_DISCARD FORCE_INLINE constexpr T & get() noexcept { return value; }
  NO_DISCARD FORCE_INLINE constexpr const T & get() const noexcept { return value; }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC type_base type() const noexcept override final { return info; }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN int index(type_base const & other_type) const noexcept override {
    if (is_type_of<T>(other_type)) return 0;
    if CPP17_CONSTEXPR (!std::is_const<T>::value) {
      if (is_type_of<const T>(other_type)) return 1;
    }
    return -1;
  }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN bool is_castable_to(type_base const & other_type) const noexcept override {
    return index(other_type) >= 0;
  }

  std::ostream & print(std::ostream & out) const override { return print_impl<T>(out); }

  enum : bool {
    has_deleter = false,
    is_copy_constructible = true,
    is_move_constructible = true,
    is_copy_assignable = true,
    is_move_assignable = true
  };

protected:

  NO_DISCARD void * raw_access() noexcept override final { return (void *)&value; }
  NO_DISCARD const void * raw_access() const noexcept override final { return &value; }

private:

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<is_ostream_operator_available<U>::value, std::ostream &> print_impl(std::ostream & out) const {
    return out << value;
  }

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<!is_ostream_operator_available<U>::value, std::ostream &> print_impl(std::ostream & out) const {
    return pmte_value::print(out);
  }

  T value;
  static constexpr type_info<T> info {};
};

template <typename T>
CPP14_CONSTEXPR const type_info<T> value_store<T,
  typename std::enable_if_t<std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value>>::info;

template <typename T>
struct value_store<T, typename std::enable_if<std::is_pointer<T>::value>::type> : pmte_value {
  static_assert(!std::is_volatile<T>::value, "'volatile' is not supported");
  using element_type = T;

  constexpr explicit value_store() noexcept : value {} {}
  template <typename U>
  constexpr explicit value_store(U && v_) noexcept : value(std::forward<U>(v_)) {}
  constexpr explicit value_store(T && v_) noexcept : value(std::forward<T>(v_)) {}
  constexpr value_store(value_store && other) noexcept : value(other.value) {}
  constexpr value_store(value_store const & other) noexcept : value(other.value) {}
  constexpr value_store & operator=(value_store && other) noexcept {
    value = other.value;
    return *this;
  }
  constexpr value_store & operator=(value_store const & other) noexcept {
    value = other.value;
    return *this;
  }

  operator T &() noexcept { return value; }
  operator const T &() const noexcept { return value; }

  NO_DISCARD FORCE_INLINE constexpr T & get() noexcept { return value; }
  NO_DISCARD FORCE_INLINE constexpr const T & get() const noexcept { return value; }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC type_base type() const noexcept override { return info; }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN int index(type_base const & other_type) const noexcept override {
    using const_type_pointer = typename util::add_const_on_pointer_t<T>;
    if CPP17_CONSTEXPR (!std::is_const<T>::value) {
      if (is_type_of<T>(other_type)) return 0;
      if (is_type_of<const_type_pointer>(other_type)) return 1;
      if (is_type_of<void *>(other_type)) return 2;
      if (is_type_of<const void *>(other_type)) return 3;
    } else {
      if (is_type_of<T>(other_type)) return 0;
      if (is_type_of<const void *>(other_type)) return 1;
    }
    return -1;
  }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN bool is_castable_to(const type_base & other_type) const noexcept override {
    return index(other_type) >= 0;
  }

  std::ostream & print(std::ostream & out) const override { return print_impl<T>(out); }

  enum : bool {
    has_deleter = false,
    is_copy_constructible = true,
    is_move_constructible = true,
    is_copy_assignable = true,
    is_move_assignable = true
  };

protected:

  NO_DISCARD void * raw_access() noexcept override final { return (void *)&value; }
  NO_DISCARD const void * raw_access() const noexcept override final { return &value; }

private:

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<is_ostream_operator_available<U>::value, std::ostream &> print_impl(std::ostream & out) const {
    return out << value;
  }

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<!is_ostream_operator_available<U>::value, std::ostream &> print_impl(std::ostream & out) const {
    return pmte_value::print(out);
  }

  T value;
  static constexpr type_info<T> info {};
};

template <typename T>
CPP14_CONSTEXPR const type_info<T> value_store<T, typename std::enable_if<std::is_pointer<T>::value>::type>::info;

template <typename T>
struct value_store<T, typename std::enable_if_t<!std::is_abstract<T>::value && (std::is_class<T>::value || std::is_union<T>::value)>>
: pmte_value {
  static_assert(!std::is_volatile<T>::value, "'volatile' is not supported");
  static_assert(std::is_nothrow_destructible<T>::value, "T can't have a throwing destructor!");
  static_assert(!std::is_default_constructible<T>::value ?
      std::is_move_constructible<T>::value || std::is_copy_constructible<T>::value || std::is_move_assignable<T>::value ||
        std::is_copy_assignable<T>::value :
      true,
    "T must support at least one move/copy constructor or assignment!");
  using element_type = T;

  constexpr value_store() noexcept(std::is_nothrow_default_constructible<T>::value) = default;
  constexpr value_store(value_store &&) = default;
  constexpr value_store(value_store const &) = default;
  constexpr value_store & operator=(value_store &&) = default;
  constexpr value_store & operator=(value_store const &) = default;

  template <typename U, typename std::enable_if_t<std::is_move_constructible<std::remove_reference_t<U>>::value && !std::is_lvalue_reference<U>::value> * = nullptr>
  FORCE_INLINE constexpr explicit value_store(U && content) noexcept(std::is_nothrow_move_constructible<std::remove_reference_t<U>>::value)
  : value(std::forward<U>(content)) {}

  template <typename U, typename std::enable_if_t<std::is_move_constructible<std::remove_reference_t<U>>::value && std::is_lvalue_reference<U>::value && std::is_copy_constructible<std::remove_reference_t<U>>::value> * = nullptr>
  FORCE_INLINE constexpr explicit value_store(U && content) noexcept(std::is_nothrow_move_constructible<std::remove_reference_t<U>>::value)
  : value(content) {}

  template <typename U,
    typename std::enable_if_t<std::is_default_constructible<std::remove_reference_t<U>>::value &&
      std::is_move_assignable<std::remove_reference_t<U>>::value && !std::is_move_constructible<std::remove_reference_t<U>>::value> * = nullptr>
  FORCE_INLINE constexpr explicit value_store(U && content) noexcept(std::is_nothrow_move_assignable<std::remove_reference_t<U>>::value)
  : value() {
    value = std::move(content);
  }

  template <typename U, typename std::enable_if_t<std::is_copy_constructible<std::remove_reference_t<U>>::value> * = nullptr>
  FORCE_INLINE constexpr explicit value_store(U const & content) noexcept(std::is_nothrow_copy_constructible<U>::value) : value(content) {}

  template <typename U,
    typename std::enable_if_t<std::is_default_constructible<U>::value && std::is_copy_assignable<U>::value && !std::is_copy_constructible<U>::value> * = nullptr>
  FORCE_INLINE constexpr explicit value_store(U const & content) noexcept(
    std::is_nothrow_default_constructible<U>::value && std::is_nothrow_copy_assignable<U>::value)
  : value() {
    value = content;
  }

  operator T &() noexcept { return value; }
  operator const T &() const noexcept { return value; }

  NO_DISCARD FORCE_INLINE constexpr T & get() noexcept { return value; }
  NO_DISCARD FORCE_INLINE constexpr const T & get() const noexcept { return value; }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC type_base type() const noexcept override { return info; }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN int index(type_base const & other_type) const noexcept override {
    if CPP17_CONSTEXPR (!std::is_const<T>::value) {
      if (is_type_of<T>(other_type)) return 0;
      if (is_type_of<const T>(other_type)) return 1;
    } else {
      if (is_type_of<T>(other_type)) return 0;
    }
    return -1;
  }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN bool is_castable_to(type_base const & other_type) const noexcept override {
    return index(other_type) >= 0;
  }

  std::ostream & print(std::ostream & out) const override { return print_impl<T>(out); }

  enum : bool {
    has_deleter = false,
    is_copy_constructible = std::is_copy_constructible<T>::value,
    is_move_constructible = std::is_move_constructible<T>::value,
    is_copy_assignable = std::is_default_constructible<T>::value && std::is_copy_assignable<T>::value,
    is_move_assignable = std::is_default_constructible<T>::value && std::is_move_assignable<T>::value
  };

protected:

  NO_DISCARD void * raw_access() noexcept override final { return (void *)&value; }
  NO_DISCARD const void * raw_access() const noexcept override final { return &value; }

private:

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<is_ostream_operator_available<U>::value, std::ostream &> print_impl(std::ostream & out) const {
    return out << value;
  }

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<!is_ostream_operator_available<U>::value, std::ostream &> print_impl(std::ostream & out) const {
    return pmte_value::print(out);
  }

  T value;
  static constexpr type_info<T> info {};
};

template <typename T>
CPP14_CONSTEXPR const type_info<T>
  value_store<T, typename std::enable_if<!std::is_abstract<T>::value && (std::is_class<T>::value || std::is_union<T>::value)>::type>::info;

} // namespace detail

//---------------------------------------------------------------------------------------------------------------------
// Runtime type information
//---------------------------------------------------------------------------------------------------------------------

namespace detail {

template <typename Base, typename... Ts>
struct rtti : Base {
  using castable_types = remove_type_info_t<type_list_sort_t<type_list_make_unique_t<type_list<Ts...>>>>;
  static_assert(non_are_volatile<Ts...>::value, "volatile types are not allowed!");

  using Base::Base;

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC type_base type() const noexcept override final {
    return type_info<std::tuple_element_t<0, std::tuple<Ts...>>> {};
  }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN int index(type_base const & other_type) const noexcept override {
    return index_of_type(other_type);
  }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC HOT_FUNC FLATTEN bool is_castable_to(const type_base & other_type) const noexcept override final {
    return index(other_type) >= 0;
  }

private:

#if __cplusplus >= CPP17_STANDARD
  template <std::size_t I = 0>
  constexpr FORCE_INLINE PURE_FUNC FLATTEN int index_of_type(const type_base & other_type) const noexcept {
    if constexpr (std::tuple_size_v<castable_types> != 0) {
      if (is_type_of<typename std::tuple_element_t<I, castable_types>>(other_type)) return I;
      if constexpr (I < std::tuple_size_v<castable_types> - 1) {
        return index_of_type<I + 1>(other_type);
      }
    }
    return -1;
  }
#else
  template <std::size_t I = 0>
  constexpr FORCE_INLINE CONST_FUNC FLATTEN typename std::enable_if<I == std::tuple_size<castable_types>::value - 1 && sizeof...(Ts) != 0, int>::type index_of_type(
    const type_base & other_type) const noexcept {
    using T = typename std::tuple_element_t<I, castable_types>;
    if (is_type_of<T>(other_type)) return I;
    return -1;
  }

  template <std::size_t I = 0>
    constexpr FORCE_INLINE CONST_FUNC FLATTEN typename std::enable_if <
    I<std::tuple_size<castable_types>::value - 1 && sizeof...(Ts) != 0, int>::type index_of_type(const type_base & other_type) const noexcept {
    using T = typename std::tuple_element_t<I, castable_types>;
    if (is_type_of<T>(other_type)) return I;
    return index_of_type<I + 1>(other_type);
  }
#endif
};

} // namespace detail

//---------------------------------------------------------------------------------------------------------------------
// deleter
//---------------------------------------------------------------------------------------------------------------------

namespace detail {

template <typename Base, typename Func, typename T>
struct deleter : Base {
private:
  Func f;

protected:
  mutable bool owner;

public:
  static CPP20_CONSTINIT const bool has_deleter;

  using Base::Base;
  using Base::operator=;

  deleter() noexcept : f(), owner(false) {}

  FORCE_INLINE deleter(T && p_, Func && f_) noexcept(noexcept(std::forward<Func>(f_)))
  : Base(std::forward<T>(p_)), f(std::forward<Func>(f_)), owner(true) {}

  FORCE_INLINE ~deleter() noexcept(noexcept(f)) {
    if (owner) f(Base::get());
  }

  template <typename U, std::enable_if_t<Base::is_move_constructible> * = nullptr>
  deleter(deleter && other) noexcept(noexcept(std::is_nothrow_move_constructible<Func>::value))
  : Base(std::forward<deleter>(other)), f(std::move(other.f)), owner(other.owner) {
    other.owner = false;
  }

  template <typename U, std::enable_if_t<Base::is_copy_constructible> * = nullptr>
  deleter(deleter const & other) noexcept(noexcept(std::is_nothrow_copy_constructible<Func>::value))
  : Base(other), f(other.f), owner(false) {}

  template <typename U, std::enable_if_t<Base::is_move_assignable> * = nullptr>
  deleter & operator=(deleter && other) noexcept(noexcept(std::is_nothrow_move_assignable<Func>::value)) {
    if (this == &other) return *this;
    if (owner) f(Base::get());
    Base::operator=(other);
    f = std::move(other.f);
    f.owner = other.owner;
    other.owner = false;
    return *this;
  }

  template <typename U, std::enable_if_t<Base::is_copy_assignable> * = nullptr>
  deleter & operator=(deleter const & other) noexcept(noexcept(std::is_nothrow_copy_assignable<Func>::value)) {
    if (this == &other) return *this;
    if (owner) f(Base::get());
    Base::operator=(other);
    f = other.f;
    owner = false;
    return *this;
  }
};

template <typename Base, typename Func, typename T>
CPP20_CONSTINIT_OR_CONSTEXPR const bool deleter<Base, Func, T>::has_deleter = true;

} // namespace detail

//---------------------------------------------------------------------------------------------------------------------
// anchor
//---------------------------------------------------------------------------------------------------------------------

namespace detail {

template <typename Base>
struct anchor final : Base {

  using Base::Base;

#if __cplusplus >= CPP20_STANDARD && defined(__GNUC__) && !defined(__clang__) // bug in gcc
  anchor() = default;
  anchor(anchor &&) = default;
  anchor(anchor const &) = default;
  anchor & operator=(anchor &&) = default;
  anchor & operator=(anchor const &) = default;
  virtual CPP20_CONSTEXPR ~anchor() noexcept {}
#endif

  NO_DISCARD CPP20_CONSTEXPR CONST_FUNC std::size_t size() const noexcept override;
  NO_DISCARD pmte_value * clone(void * address = nullptr) const override;

private:

  template <typename T = Base>
  NO_DISCARD typename std::enable_if_t<T::has_deleter && T::is_copy_constructible, pmte_value *> clone_impl(void * address) const;

  template <typename T = Base>
  NO_DISCARD typename std::enable_if_t<T::has_deleter && T::is_copy_assignable && !T::is_copy_constructible, pmte_value *> clone_impl(
    void * address) const;

  template <typename T = Base>
  NO_DISCARD typename std::enable_if_t<!T::has_deleter && T::is_copy_constructible, pmte_value *> clone_impl(void * address) const;

  template <typename T = Base>
  NO_DISCARD typename std::enable_if_t<!T::has_deleter && T::is_copy_assignable && !T::is_copy_constructible, pmte_value *> clone_impl(
    void * address) const;

  template <typename T = Base>
  NO_DISCARD typename std::enable_if_t<!T::is_copy_constructible && !T::is_copy_assignable, pmte_value *> clone_impl(void *) const;
};

template <typename Base>
NO_DISCARD CPP20_CONSTEXPR CONST_FUNC std::size_t anchor<Base>::size() const noexcept {
  return sizeof(anchor);
}

template <typename Base>
NO_DISCARD pmte_value * anchor<Base>::clone(void * address) const {
  return clone_impl<Base>(address);
}

template <typename Base>
template <typename T>
NO_DISCARD typename std::enable_if_t<T::has_deleter && T::is_copy_constructible, pmte_value *> anchor<Base>::clone_impl(void * address) const {
  if (address == nullptr) address = operator new(sizeof(anchor));
  auto result = new (address) anchor(*this);
  Base::owner = false;
  return result;
}

template <typename Base>
template <typename T>
NO_DISCARD typename std::enable_if_t<T::has_deleter && T::is_copy_assignable && !T::is_copy_constructible, pmte_value *> anchor<Base>::clone_impl(
  void * address) const {
  if (address == nullptr) address = operator new(sizeof(anchor));
  auto result = new (address) anchor();
  *result = *this;
  Base::owner = false;
  return result;
}

template <typename Base>
template <typename T>
NO_DISCARD typename std::enable_if_t<!T::has_deleter && T::is_copy_constructible, pmte_value *> anchor<Base>::clone_impl(void * address) const {
  if (address == nullptr) address = operator new(sizeof(anchor));
  return new (address) anchor(*this);
}

template <typename Base>
template <typename T>
NO_DISCARD typename std::enable_if_t<!T::has_deleter && T::is_copy_assignable && !T::is_copy_constructible, pmte_value *> anchor<Base>::clone_impl(
  void * address) const {
  if (address == nullptr) address = operator new(sizeof(anchor));
  auto result = new (address) anchor();
  *result = *this;
  return result;
}

template <typename Base>
template <typename T>
NO_DISCARD typename std::enable_if_t<!T::is_copy_constructible && !T::is_copy_assignable, pmte_value *> anchor<Base>::clone_impl(void *) const {
  return nullptr;
}

} // namespace detail

//---------------------------------------------------------------------------------------------------------------------
// handler interface
//---------------------------------------------------------------------------------------------------------------------

namespace detail {
class visitor_base;
} // namespace detail

struct pmte_handler : detail::base {
public:

  virtual bool operator()(pmte_value &) const = 0;
  virtual bool operator()(pmte_value const &) const = 0;

protected:

  friend class detail::visitor_base;

  typedef void (pmte_handler::*invoke_type)(pmte_value &) const;
  typedef void (pmte_handler::*invoke_const_type)(pmte_value const &) const;
  invoke_type invoke = nullptr;
  invoke_const_type invoke_const = nullptr;
};

using shared_pmte_handler = std::shared_ptr<pmte_handler>;
using unique_pmte_handler = std::unique_ptr<pmte_handler>;

//---------------------------------------------------------------------------------------------------------------------
// specific_handler
//---------------------------------------------------------------------------------------------------------------------

namespace detail {

template <typename T>
struct handler_typed : pmte_handler {};

template <typename T, typename Func>
struct handler_specific final : handler_typed<T> {

  using invoke_type = typename handler_typed<T>::invoke_type;
  using invoke_const_type = typename handler_typed<T>::invoke_const_type;

  constexpr handler_specific(Func && f_) : f(std::forward<Func>(f_)) {
    handler_typed<T>::invoke = static_cast<invoke_type>(&handler_specific::invoke_unsafe);
    handler_typed<T>::invoke_const = static_cast<invoke_const_type>(&handler_specific::invoke_unsafe_const);
  }

  NO_DISCARD CPP20_CONSTEXPR PURE_FUNC type_base type() const noexcept override { return info; }
  NO_DISCARD CPP20_CONSTEXPR CONST_FUNC std::size_t size() const noexcept override { return sizeof(handler_specific); }

  HOT_FUNC bool operator()(pmte_value & o) const override {
    if (T * const p = o.get_if<T>()) return invoke_<decltype(*p)>(*p);
    return false;
  }

  HOT_FUNC bool operator()(pmte_value const & o) const override {
    if (const T * const p = o.get_if<const T>()) return invoke_<decltype(*p)>(*p);
    return false;
  }

  std::ostream & print(std::ostream & out) const override {
    return out << "{hash:" << get_hash_code(type_info<T> {}) << ",type:\"" << type_name<T>() << "\",func:" << type_name<Func>() << '}';
  }

private:

  HOT_FUNC void invoke_unsafe(pmte_value & o) const { invoke_(o.get_unsafe<T>()); }

  HOT_FUNC void invoke_unsafe_const(pmte_value const & o) const { invoke_(o.get_unsafe<T>()); }

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<util::is_invocable<Func, U>::value, bool> invoke_(U && u) const {
    f(std::forward<U>(u));
    return true;
  }

  template <typename U>
  FORCE_INLINE typename std::enable_if_t<!util::is_invocable<Func, U>::value, bool> invoke_(U &&) const {
    return false;
  }

  typename std::conditional_t<std::is_function<Func>::value, std::add_pointer_t<Func>, Func> f;
  static constexpr type_info<T> info {};
};

template <typename T, typename Func>
CPP14_CONSTEXPR const type_info<T> handler_specific<T, Func>::info;

} // namespace detail

//---------------------------------------------------------------------------------------------------------------------
// is_type_of
//---------------------------------------------------------------------------------------------------------------------

template <typename T>
NO_DISCARD constexpr bool is_type_of(detail::base const & o) {
  return is_type_of<T>(o.type());
}

template <typename T>
NO_DISCARD constexpr bool is_type_of(detail::base const * const p) {
  return p && is_type_of<T>(p->type());
}

template <typename T, typename U, typename D, std::enable_if_t<std::is_base_of<detail::base, U>::value> * = nullptr>
NO_DISCARD constexpr bool is_type_of(const std::unique_ptr<U, D> & o) {
  return o && is_type_of<T>(o.get()->type());
}

template <typename T, typename U, std::enable_if_t<std::is_base_of<detail::base, U>::value> * = nullptr>
NO_DISCARD constexpr bool is_type_of(const std::shared_ptr<U> & o) {
  return o && is_type_of<T>(o.get()->type());
}

//---------------------------------------------------------------------------------------------------------------------
// have_same_type
//---------------------------------------------------------------------------------------------------------------------

NO_DISCARD CPP20_CONSTEXPR inline bool have_same_type(type_base const& lhs, type_base const& rhs) noexcept {
    return lhs.has_same_type(rhs);
}

NO_DISCARD CPP20_CONSTEXPR inline bool have_same_type(type_base const * const lp, type_base const * const rp) noexcept {
    return (lp && rp && lp->has_same_type(*rp));
}

NO_DISCARD CPP20_CONSTEXPR inline bool have_same_type(detail::base const& lhs, detail::base const& rhs) noexcept {
    return have_same_type(lhs.type(), rhs.type());
}

NO_DISCARD CPP20_CONSTEXPR inline bool have_same_type(detail::base const * const lp, detail::base const * const rp) noexcept {
    return (lp && rp && lp->type().has_same_type(rp->type()));
}

template <typename U1, typename D1, typename U2, typename D2, typename std::enable_if_t<std::is_base_of<detail::base, U1>::value && std::is_base_of<detail::base, U2>::value> * = nullptr>
NO_DISCARD CPP20_CONSTEXPR inline bool have_same_type(std::unique_ptr<U1,D1> const& lhs, std::unique_ptr<U2,D2> const& rhs) noexcept {
    return lhs && rhs && have_same_type(lhs->type(), rhs->type());
}

template <typename U1, typename U2, typename std::enable_if_t<std::is_base_of<detail::base, U1>::value && std::is_base_of<detail::base, U2>::value> * = nullptr>
NO_DISCARD CPP20_CONSTEXPR inline bool have_same_type(std::shared_ptr<U1> const& lhs, std::shared_ptr<U2> const& rhs) noexcept {
    return lhs && rhs && have_same_type(lhs->type(), rhs->type());
}

//---------------------------------------------------------------------------------------------------------------------
// get_if
//---------------------------------------------------------------------------------------------------------------------

template <typename T1, typename... Ts>
NO_DISCARD inline auto get_if(pmte_value & o) noexcept {
  return o.get_if<T1, Ts...>();
}

template <typename T1, typename... Ts>
NO_DISCARD inline auto get_if(pmte_value const & o) noexcept {
  return o.get_if<T1, Ts...>();
}

template <typename T1, typename... Ts>
NO_DISCARD auto get_if(pmte_value * const p) noexcept {
  return p ? p->get_if<T1, Ts...>() : nullptr;
}

template <typename T1, typename... Ts>
NO_DISCARD auto get_if(pmte_value const * const p) noexcept {
  return p ? p->get_if<T1, Ts...>() : nullptr;
}

template <typename T1, typename... Ts, typename U, typename D>
NO_DISCARD auto get_if(std::unique_ptr<U, D> const & o, typename std::enable_if_t<std::is_base_of<pmte_value, U>::value> * = nullptr) noexcept {
  return o ? o.get()->template get_if<T1, Ts...>() : nullptr;
}

template <typename T1, typename... Ts, typename U>
NO_DISCARD auto get_if(std::shared_ptr<U> const & o, typename std::enable_if_t<std::is_base_of<pmte_value, U>::value> * = nullptr) noexcept {
  return o ? o.get()->template get_if<T1, Ts...>() : nullptr;
}

template <typename T>
NO_DISCARD FORCE_INLINE constexpr T & pmte_value::get_unsafe() noexcept {
  return *static_cast<T *>(raw_access());
}

template <typename T>
NO_DISCARD FORCE_INLINE constexpr const T & pmte_value::get_unsafe() const noexcept {
  return *static_cast<const T *>(raw_access());
}

#if __cplusplus >= CPP17_STANDARD
template <std::size_t I, typename R, typename Types, typename std::enable_if_t<std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R pmte_value::get_if_() noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<T> {})) {
    return static_cast<detail::value_store<std::remove_const_t<T>> *>(this)->get();
  }
  if constexpr (I < std::tuple_size_v<Types> - 1) {
    return get_if_<I + 1, Types>();
  }
  return nullptr;
}
#else
template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *> R
    pmte_value::get_if_() noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<T> {})) {
    return static_cast<detail::value_store<std::remove_const_t<T>> *>(this)->get();
  }
  return get_if_<I + 1, Types>();
}

template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R pmte_value::get_if_() noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<T> {})) {
    return static_cast<detail::value_store<std::remove_const_t<T>> *>(this)->get();
  }
  return nullptr;
}
#endif

#if __cplusplus >= CPP17_STANDARD
template <std::size_t I, typename R, typename Types, typename std::enable_if_t<!std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R * pmte_value::get_if_() noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<T> {})) {
    return static_cast<R *>(raw_access());
  }
  if constexpr (I < std::tuple_size_v<Types> - 1) {
    return get_if_<I + 1, R, Types>();
  }
  return nullptr;
}
#else
template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *> R *
    pmte_value::get_if_() noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<T> {})) {
    return static_cast<R *>(raw_access());
  }
  return get_if_<I + 1, R, Types>();
}

template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R * pmte_value::get_if_() noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<T> {})) {
    return static_cast<R *>(raw_access());
  }
  return nullptr;
}
#endif

#if __cplusplus >= CPP17_STANDARD
template <std::size_t I, typename R, typename Types, typename std::enable_if_t<std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R pmte_value::get_if_() const noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<const T> {})) {
    return static_cast<const detail::value_store<T> *>(this)->get();
  }
  if constexpr (I < std::tuple_size_v<Types> - 1) {
    return get_if_<I + 1, R, Types>();
  }
  return nullptr;
}
#else
template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *> R
    pmte_value::get_if_() const noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<const T> {})) {
    return static_cast<const detail::value_store<T> *>(this)->get();
  }
  return get_if_<I + 1, R, Types>();
}

template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R pmte_value::get_if_() const noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<const T> {})) {
    return static_cast<const detail::value_store<T> *>(this)->get();
  }
  return nullptr;
}
#endif

#if __cplusplus >= CPP17_STANDARD
template <std::size_t I, typename R, typename Types, typename std::enable_if_t<!std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R * pmte_value::get_if_() const noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<const T> {})) {
    return static_cast<R *>(raw_access());
  }
  if constexpr (I < std::tuple_size_v<Types> - 1) {
    return get_if_<I + 1, R, Types>();
  }
  return nullptr;
}
#else
template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I<std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *> R *
    pmte_value::get_if_() const noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<const T> {})) {
    return static_cast<R *>(raw_access());
  }
  return get_if_<I + 1, R, Types>();
}

template <std::size_t I, typename R, typename Types,
  typename std::enable_if_t<I == std::tuple_size<Types>::value - 1 && !std::is_pointer<typename std::tuple_element_t<I, Types>>::value> *>
R * pmte_value::get_if_() const noexcept {
  using T = std::tuple_element_t<I, Types>;
  if (is_castable_to(type_info<const T> {})) {
    return static_cast<R *>(raw_access());
  }
  return nullptr;
}
#endif

//---------------------------------------------------------------------------------------------------------------------
// destroy
//---------------------------------------------------------------------------------------------------------------------

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
void destroy(std::pmr::memory_resource & resource, detail::base * p);
#endif

//---------------------------------------------------------------------------------------------------------------------
// Create Polymorphic Type Erased object
//---------------------------------------------------------------------------------------------------------------------

// Integral, Floating Point, Enum, nullptr_t

template <typename RefType,
  typename std::enable_if_t<std::is_integral<RefType>::value || std::is_floating_point<RefType>::value || std::is_enum<RefType>::value ||
    std::is_null_pointer<RefType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte() noexcept(false) {
  using object_type = detail::anchor<detail::value_store<RefType>>;
  return object_type();
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point, enum type or nullptr_t!");
  using object_type = detail::anchor<detail::value_store<T>>;
  return object_type(std::forward<T>(v_));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point, enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  return new (address) object_type(std::forward<T>(v_));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point, enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  return new object_type(std::forward<T>(v_));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point, enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  return std::unique_ptr<object_type>(make_pmte<RefType>(std::forward<T>(v_)));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point, enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  return std::shared_ptr<object_type>(make_pmte<RefType>(std::forward<T>(v_)));
}

// Integral, Floating Point, Enum, nullptr_t (PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point or enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<T>(v_));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point or enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<T>(v_)), std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<std::is_integral<util::remove_cvref_t<ArgType>>::value || std::is_floating_point<util::remove_cvref_t<ArgType>>::value ||
    std::is_enum<util::remove_cvref_t<ArgType>>::value || std::is_null_pointer<util::remove_cvref_t<ArgType>>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_ = RefType {}) noexcept(false) {
  using T = typename std::conditional<std::is_void<RefType>::value, util::remove_cvref_t<ArgType>, RefType>::type;
  static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value || std::is_enum<T>::value || std::is_null_pointer<T>::value,
    "RefType must be of integral, floating point or enum type or nullptr_t!");
  using object_type = decltype(build_pmte<RefType>(std::forward<T>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<T>(v_));
}
#endif

// Pointer types (RefType == void)

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_) noexcept(false) {
  using object_type = detail::anchor<detail::value_store<ArgType>>;
  return object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new (address) object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::unique_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_)));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::shared_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_)));
}

// Pointer types (RefType == void; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_)), std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<ArgType>>::value && std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_));
}
#endif

// Pointer types (RefType != void)

template <typename RefType, typename std::enable_if_t<std::is_pointer<util::remove_cvref_t<RefType>>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte() noexcept(false) {
  using object_type = detail::anchor<detail::value_store<RefType>>;
  return object_type();
}

template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType, RefType>::value, "ArgType must be convertible to RefType for pointer types");
  using object_type = detail::anchor<detail::rtti<detail::value_store<RefType>, RefType, util::add_const_on_pointer_t<RefType>, void *, const void *>>;
  return object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType, RefType>::value, "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new (address) object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType, RefType>::value, "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::unique_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_)));
}

template <typename RefType = void, typename ArgType, std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_) noexcept(false) {
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::shared_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_)));
}

// Pointer types (RefType != void; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType, RefType>::value, "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType, RefType>::value, "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_)), std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType, typename std::enable_if_t<std::is_pointer<ArgType>::value && !std::is_void<RefType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType, RefType>::value, "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_));
}
#endif

// Pointer types (polymorph)

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using T = typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type;
  using object_type = detail::anchor<detail::rtti<detail::value_store<T>, T, util::add_const_on_pointer_t<T>, Types...,
    util::add_const_on_pointer_t<Types>..., void *, const void *>>;
  return object_type(v_);
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return new (address) object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return new object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::unique_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::shared_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
}

// Pointer types (polymorph; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), type_list<Types...> {});
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), type_list<Types...> {}),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_pointer<ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be convertible to all provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_));
}
#endif

// Pointer types (deleter)

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional_t<std::is_void<RefType>::value, ArgType, RefType>>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using T = typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type;
  using object_type = detail::anchor<detail::deleter<detail::value_store<T>, Deleter, T>>;
  return object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional_t<std::is_void<RefType>::value, ArgType, RefType>>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  return new (address) object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional_t<std::is_void<RefType>::value, ArgType, RefType>>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  return new object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD inline auto make_unique_pmte(ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  return std::unique_ptr<object_type>(new object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
}

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD inline auto make_shared_pmte(ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  return std::shared_ptr<object_type>(new object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
}

// Pointer types (deleter; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), std::forward<Deleter>(d_)),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType, typename Deleter,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_, Deleter && d_) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_),
    std::forward<Deleter>(d_));
}
#endif

// Pointer types (polymorph and deleter)

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using T = typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type;
  using object_type = detail::anchor<detail::deleter<
    detail::rtti<detail::value_store<T>, T, util::add_const_on_pointer_t<T>, Types..., util::add_const_on_pointer_t<Types>..., void *, const void *>, Deleter, T>>;
  return object_type(std::forward<T>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  return new (address) object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  return new object_type(std::forward<ArgType>(v_), std::forward<Deleter>(d_));
}

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  return std::unique_ptr<object_type>(construct_pmte_at<RefType>(operator new(sizeof(object_type)), std::forward<ArgType>(v_),
    std::forward<Deleter>(d_), type_list<Types...> {}));
}

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  return std::shared_ptr<object_type>(construct_pmte_at<RefType>(operator new(sizeof(object_type)), std::forward<ArgType>(v_),
    std::forward<Deleter>(d_), type_list<Types...> {}));
}

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), std::forward<Deleter>(d_),
    type_list<Types...> {});
}

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  auto resource_deleter = [&resource](object_type * ptr) {
    if (ptr) {
      ptr->~object_type();
      resource.deallocate(ptr, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), std::forward<Deleter>(d_),
      type_list<Types...> {}),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType, typename Deleter, typename... Types,
  typename std::enable_if_t<std::is_pointer<ArgType>::value &&
    util::is_invocable<Deleter, typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_, Deleter && d_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType, RefType>::value,
    "ArgType must be convertible to RefType for pointer types");
  static_assert(is_convertible<ArgType>::template to<Types...>::value, "ArgType must be a convertible to provided types!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), std::forward<Deleter>(d_), type_list<Types...> {}));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_),
    std::forward<Deleter>(d_));
}
#endif

// Class types (RefType == void || RefType == ArgType)

template <typename RefType,
  typename std::enable_if_t<(std::is_class<RefType>::value || std::is_union<RefType>::value) && std::is_default_constructible<RefType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte() noexcept(false) {
#if __cplusplus <= CPP14_STANDARD
  static_assert(std::is_const<RefType>::value ? std::is_copy_constructible<RefType>::value : true,
    "const values must be copyable under C++14 or lower!");
  static_assert(std::is_move_constructible<RefType>::value || std::is_copy_constructible<RefType>::value,
    "RefType must be movable and/or copyable!");
#endif
  using object_type = detail::anchor<detail::value_store<RefType>>;
  return object_type();
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  static_assert(std::is_move_constructible<ArgType>::value || std::is_move_assignable<ArgType>::value ||
      std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType must be movable, copyable or assignable!");
  using object_type = detail::anchor<detail::value_store<ArgType>>;
  return object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = detail::anchor<detail::value_store<ArgType>>;
  return object_type(v_);
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new (address) object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new (address) object_type(v_);
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new object_type(v_);
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::unique_ptr<object_type>(new object_type(std::forward<ArgType>(v_)));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::unique_ptr<object_type>(new object_type(v_));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::shared_ptr<object_type>(new object_type(std::forward<ArgType>(v_)));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::shared_ptr<object_type>(new object_type(v_));
}

// Class types (RefType == void || RefType == ArgType; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), v_);
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_)), std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), v_),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType = RefType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_ = RefType {}) noexcept(false) {
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<(std::is_class<ArgType>::value || std::is_union<ArgType>::value) &&
    (std::is_void<RefType>::value || std::is_same<RefType, ArgType>::value)> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType & v_) noexcept(false) {
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), v_);
}
#endif

// Class types (RefType != void && RefType != ArgType)

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true, "Can't have non-const RefType to a const ArgType");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = detail::anchor<detail::rtti<detail::value_store<ArgType>, ArgType, const ArgType, RefType, const RefType>>;
  return object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true, "Can't have non-const RefType to a const ArgType");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = detail::anchor<detail::rtti<detail::value_store<ArgType>, ArgType, const ArgType, RefType, const RefType>>;
  return object_type(v_);
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new (address) object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new (address) object_type(v_);
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return new object_type(v_);
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::unique_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_)));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::unique_ptr<object_type>(make_pmte<RefType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::shared_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_)));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::shared_ptr<object_type>(make_pmte<RefType>(v_));
}

// Class types (RefType != void && RefType != ArgType; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true);
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true);
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), v_);
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true);
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_)), std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true);
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), v_),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true);
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType,
  typename std::enable_if_t<std::is_class<ArgType>::value && !std::is_void<RefType>::value && !std::is_same<RefType, ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType & v_) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(std::is_const<ArgType>::value ? std::is_const<RefType>::value : true);
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_)));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), v_);
}
#endif

// Class types (polymorph)

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  using RefT = typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type;
  static_assert(std::is_const<ArgType>::value ? all_are_const<RefT, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<RefT>::value ? all_are_const<Types...>::value : true, "If RefType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = detail::anchor<detail::rtti<detail::value_store<ArgType>, ArgType, const ArgType, RefT, const RefT, Types..., const Types...>>;
  return object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD constexpr inline auto build_pmte(ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  using RefT = typename std::conditional<std::is_void<RefType>::value, ArgType, RefType>::type;
  static_assert(std::is_const<ArgType>::value ? all_are_const<RefT, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<RefT>::value ? all_are_const<Types...>::value : true, "If RefType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = detail::anchor<detail::rtti<detail::value_store<ArgType>, ArgType, const ArgType, RefT, const RefT, Types..., const Types...>>;
  return object_type(v_);
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return new (address) object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD inline auto construct_pmte_at(void * address, ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return new (address) object_type(v_);
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return new object_type(std::forward<ArgType>(v_));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD inline auto make_pmte(ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return new object_type(v_);
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::unique_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::unique_ptr<object_type>(make_pmte<RefType>(v_, type_list<Types...> {}));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::shared_ptr<object_type>(make_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_void<RefType>::value || std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::shared_ptr<object_type>(make_pmte<RefType>(v_, type_list<Types...> {}));
}

// Class types (polymorph; PMR)

#if __cplusplus >= CPP17_STANDARD && __has_include(<memory_resource>)
template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), type_list<Types...> {});
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_pmte(std::pmr::memory_resource & resource, ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), v_, type_list<Types...> {});
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type, decltype(resource_deleter)>(
    construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), std::forward<ArgType>(v_), type_list<Types...> {}),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_unique_pmte(std::pmr::memory_resource & resource, ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  auto resource_deleter = [&resource](object_type * p) {
    if (p) {
      p->~object_type();
      resource.deallocate(p, sizeof(object_type));
    }
  };
  return std::unique_ptr<object_type>(construct_pmte_at<RefType>(resource.allocate(sizeof(object_type)), v_, type_list<Types...> {}),
    std::move(resource_deleter));
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType && v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_const<ArgType>::value ? std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value : true,
    "ArgType needs to be copyable for const rvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), std::forward<ArgType>(v_),
    type_list<Types...> {});
}

template <typename RefType = void, typename ArgType, typename... Types, typename std::enable_if_t<std::is_class<ArgType>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte(std::pmr::memory_resource & resource, ArgType & v_, type_list<Types...>) noexcept(false) {
  static_assert(std::is_convertible<ArgType *, RefType *>::value, "ArgType must be convertible to RefType");
  static_assert(is_derived<ArgType>::template from<ArgType, Types...>::value, "ArgType must be a decendent from provided bases!");
  static_assert(
    std::is_const<ArgType>::value ? std::is_void<RefType>::value ? all_are_const<Types...>::value : all_are_const<RefType, Types...>::value : true,
    "If ArgType is const all castable types must be const also!");
  static_assert(std::is_copy_constructible<ArgType>::value || std::is_copy_assignable<ArgType>::value,
    "ArgType needs to be copyable for lvalues!");
  using object_type = decltype(build_pmte<RefType>(std::forward<ArgType>(v_), type_list<Types...> {}));
  return std::allocate_shared<object_type>(std::pmr::polymorphic_allocator<object_type>(&resource), v_, type_list<Types...> {});
}
#endif

// handlers

template <typename T, typename Func>
NO_DISCARD constexpr inline auto build_pmte_handler(Func && f_) noexcept(false) {
  static_assert(util::is_invocable<Func, T &>::value, "Func must accept type T as its single argument!");
  using object_type = detail::handler_specific<T, Func>;
  return object_type(std::forward<Func>(f_));
}

template <typename T, typename Func>
NO_DISCARD inline auto construct_pmte_handler_at(void * address, Func && f_) noexcept(false) {
  static_assert(util::is_invocable<Func, T &>::value, "Func must accept type T as its single argument!");
  using object_type = decltype(build_pmte_handler<T>(std::forward<Func>(f_)));
  return new (address) object_type(std::forward<Func>(f_));
}

template <typename T, typename Func>
NO_DISCARD inline auto make_pmte_handler(Func && f_) noexcept(false) {
  static_assert(util::is_invocable<Func, T &>::value, "Func must accept type T as its single argument!");
  using object_type = decltype(build_pmte_handler<T>(std::forward<Func>(f_)));
  return new object_type(std::forward<Func>(f_));
}

template <typename T, typename Func>
NO_DISCARD auto make_unique_pmte_handler(Func && f_) noexcept(false) {
  static_assert(util::is_invocable<Func, T &>::value, "Func must accept type T as its single argument!");
  using object_type = decltype(build_pmte_handler<T>(std::forward<Func>(f_)));
  return std::unique_ptr<object_type>(make_pmte_handler<T>(std::forward<Func>(f_)));
}

template <typename T, typename Func, typename std::enable_if_t<util::is_invocable<Func, T &>::value> * = nullptr>
NO_DISCARD auto make_shared_pmte_handler(Func && f_) noexcept(false) {
  static_assert(util::is_invocable<Func, T &>::value, "Func must accept type T as its single argument!");
  using object_type = decltype(build_pmte_handler<T>(std::forward<Func>(f_)));
  return std::shared_ptr<object_type>(make_pmte_handler<T>(std::forward<Func>(f_)));
}

//---------------------------------------------------------------------------------------------------------------------

template <typename T, typename P, typename std::enable_if_t<std::is_pointer<P>::value && std::is_convertible<P, pmte_value *>::value> * = nullptr>
NO_DISCARD FORCE_INLINE PURE_FUNC constexpr bool is_castable_to(P & p) noexcept {
  if (p) LIKELY {
      return p->is_castable_to(type_info<T> {});
    }
  return false;
}

template <typename T>
NO_DISCARD FORCE_INLINE PURE_FUNC constexpr bool is_castable_to(pmte_value const & o) noexcept {
  return o.is_castable_to(type_info<T> {});
}

template <typename T, typename U, typename D, typename std::enable_if_t<std::is_base_of<pmte_value, U>::value> * = nullptr>
NO_DISCARD PURE_FUNC HOT_FUNC bool is_castable_to(std::unique_ptr<U, D> const & ptr) noexcept {
  if (ptr) LIKELY {
      return ptr->is_castable_to(type_info<T> {});
    }
  return false;
}

template <typename T, typename U, typename std::enable_if_t<std::is_base_of<pmte_value, U>::value> * = nullptr>
NO_DISCARD PURE_FUNC HOT_FUNC bool is_castable_to(std::shared_ptr<U> const & ptr) noexcept {
  if (ptr) LIKELY {
      return ptr->is_castable_to(type_info<T> {});
    }
  return false;
}

//---------------------------------------------------------------------------------------------------------------------

namespace detail {

class visitor_base {
private:

  using self = visitor_base;
  static constexpr bool detect_hash_collisions = false;
  static constexpr std::size_t mask = 0x7F00;

  std::forward_list<shared_pmte_handler> handlers;
  mutable std::vector<std::pair<std::size_t, pmte_handler *>> cache_entries;
  mutable std::array<std::size_t, 128> cache_hash_lookup;

  friend std::ostream & operator<<(std::ostream & out, self const & o);

  void add_cache_entry(std::size_t const hash_code, pmte_handler * const handler) const;
  void update_cache_entry(std::size_t const hash_code, pmte_handler * const handler) const noexcept;
  void remove_cache_entries(pmte_handler * handler) const;

  NO_DISCARD FORCE_INLINE constexpr static std::size_t calculate_index_in_of_hash_cache(std::size_t hash_code) {
    return (hash_code & mask) >> 8;
  }

  NO_DISCARD HOT_FUNC std::pair<bool, pmte_handler *> find_in_cache_entries(const std::size_t hash_code) const noexcept {
#ifdef WITH_VISITOR_STATS
    ++lookups;
#endif
    if (std::size_t len = cache_entries.size()) {
      std::pair<std::size_t, pmte_handler *> const * const begin = cache_entries.data();

      // hash lookup
      const std::size_t index_in_hash_cache = calculate_index_in_of_hash_cache(hash_code);
      const std::size_t index_in_cache_entries = cache_hash_lookup[index_in_hash_cache];
      __builtin_prefetch(&begin[index_in_cache_entries]);
      if (index_in_cache_entries < len) {
        auto entry = cache_entries[index_in_cache_entries];
        if (entry.first == hash_code) {
#ifdef WITH_VISITOR_STATS
          ++hash_cache_hits;
#endif
          return std::make_pair(true, entry.second);
        }
      } else {
        cache_hash_lookup[index_in_hash_cache] = len > 1 ? (len >> 1) - 1 : 0;
      }

      // binary search lookup
      std::pair<std::size_t, pmte_handler *> const * itt = begin;
      while (len > 1) {
        const std::size_t half = len >> 1;
        len -= half;
        __builtin_prefetch(&itt[(len >> 1) - 1]);
        __builtin_prefetch(&itt[half + (len >> 1) - 1]);
        itt += (itt[half - 1].first < hash_code) * half;
      }

      // found
      if (itt->first == hash_code) {
#ifdef WITH_VISITOR_STATS
        ++binary_search_hits;
#endif
        const auto index = std::distance<std::pair<std::size_t, pmte_handler *> const *>(begin, itt);
        cache_hash_lookup[index_in_hash_cache] = index;
        return std::pair<bool, pmte_handler *>(true, itt->second);
      }

#ifdef WITH_VISITOR_STATS
      // not-found
      ++binary_search_misses;
#endif
    }
    return std::pair<bool, pmte_handler *>(false, nullptr);
  }

  NO_DISCARD HOT_FUNC pmte_handler * find(pmte_value & value) const {
    const auto value_hash = get_hash_code(value.type());

    const std::pair<bool, pmte_handler *> result = find_in_cache_entries(value_hash);
    if (result.first) LIKELY {
        //* Double check if the type was castable, just in case of a hash collision
        if (detect_hash_collisions and result.second) {
          return value.is_castable_to(result.second->type()) ? result.second : nullptr;
        }
        return result.second;
      }

    pmte_handler * best_handler = nullptr;
    int best_index = -1;
    for (auto && handler : handlers) {
      const int index = value.index(handler->type());
      if (index >= 0 && (index < best_index || best_index == -1)) {
        best_index = index;
        best_handler = handler.get();
      }
    }

    add_cache_entry(value_hash, best_handler);
    return best_handler;
  }

  NO_DISCARD HOT_FUNC pmte_handler * find(pmte_value const & value) const {
    const auto value_hash = get_const_hash_code(value.type());

    const std::pair<bool, pmte_handler *> result = find_in_cache_entries(value_hash);
    if (result.first) LIKELY {
        //* Double check if the type was castable, just in case of a hash collision
        if (detect_hash_collisions and result.second) {
          const auto & handler_type = result.second->type();
          return value.is_castable_to(handler_type) && is_const(handler_type) ? result.second : nullptr;
        }
        return result.second;
      }

    pmte_handler * best_handler = nullptr;
    int best_index = -1;
    for (auto && handler : handlers) {
      const auto & handler_type = handler->type();
      if (is_const(handler_type)) {
        const int index = value.index(handler_type);
        if (index >= 0 && (index < best_index || best_index == -1)) {
          best_index = index;
          best_handler = handler.get();
        }
      }
    }

    add_cache_entry(value_hash, best_handler);
    return best_handler;
  }

protected:

  visitor_base() { cache_hash_lookup.fill(0); }

  NO_DISCARD HOT_FUNC bool process(pmte_value & o) const {
    if (pmte_handler * const handler = find(o)) LIKELY {
        (handler->*(handler->invoke))(o);
        return true;
      }
    return false;
  }

  NO_DISCARD HOT_FUNC bool process(pmte_value const & o) const {
    if (pmte_handler * const handler = find(o)) LIKELY {
        (handler->*(handler->invoke_const))(o);
        return true;
      }
    return false;
  }

public:

#ifdef WITH_VISITOR_STATS
  mutable std::size_t lookups = 0;
  mutable std::size_t hash_cache_hits = 0;
  mutable std::size_t binary_search_hits = 0;
  mutable std::size_t binary_search_misses = 0;
#endif

  template <typename T, typename Func>
  self & add(Func && func) {
    static_assert(util::is_invocable<Func, T>::value || util::is_invocable<Func, std::add_lvalue_reference_t<T>>::value,
      "Provided handler must be invocable with provided type T");
    static_assert(!std::is_reference<T>::value, "Reference types are not allowed!");
    constexpr auto hash_code = util::get_hash_code(type_info<T> {});
    auto handler = make_unique_pmte_handler<T>(std::move(func));
    handlers.push_front(std::move(handler));
    if (cache_entries.empty() or !find_in_cache_entries(hash_code).first) add_cache_entry(hash_code, handlers.front().get());
    else
      update_cache_entry(hash_code, handlers.front().get());
    remove_cache_entries(nullptr);
    return *this;
  }

  template <typename Func>
  inline self & add(Func && func) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    using T = std::remove_reference_t<first_arg>;
    add<T>(std::move(func));
    return *this;
  }

  template <typename T>
  self & remove_last() {
    auto itt = std::begin(handlers);
    auto prv = handlers.before_begin();
    const auto end = std::end(handlers);
    while (itt != end) {
      if (is_type_of<T>(*itt)) {
        remove_cache_entries((*itt).get());
        handlers.erase_after(prv);
        break;
      }
      prv = itt;
      ++itt;
    }
    return *this;
  }

  template <typename T>
  self & remove() {
    handlers.remove_if([this](typename decltype(handlers)::value_type & element) {
      if (is_type_of<T>(element.get())) {
        remove_cache_entries(element.get());
        return true;
      }
      return false;
    });
    return *this;
  }

  NO_DISCARD bool empty() const noexcept { return handlers.empty(); }
};

} // namespace detail

#if __cplusplus >= CPP17_STANDARD
template <typename... Functions>
class pmte_visitor final : public detail::visitor_base, private Functions... {
#else
class pmte_visitor final : public detail::visitor_base {
#endif
private:
  using self = pmte_visitor;

  template <typename... Funcs>
  typename std::enable_if<0 == sizeof...(Funcs)>::type register_(Funcs &&...) {}

  template <typename Func, typename... Funcs>
  typename std::enable_if<0 == sizeof...(Funcs)>::type register_(Func && func, Funcs &&...) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    add<first_arg>(std::move(func));
  }

  template <typename Func, typename... Funcs>
  typename std::enable_if<1 <= sizeof...(Funcs)>::type register_(Func && func, Funcs &&... functions) {
    using first_arg = typename function_info<typename std::remove_reference_t<Func>>::first_arg;
    using return_type = typename function_info<typename std::remove_reference_t<Func>>::return_type;
    using arg_types = typename function_info<typename std::remove_reference_t<Func>>::arg_types;
    static_assert(std::tuple_size<arg_types>::value == 1, "Handlers must accept exactly one argument!");
    static_assert(std::is_same<return_type, void>::value, "Return type of handler must be void!");
    add<first_arg>(std::move(func));
    register_(functions...);
  }

public:

#if __cplusplus >= CPP17_STANDARD
  pmte_visitor(Functions... functions) noexcept(std::is_nothrow_default_constructible<detail::visitor_base>::value)
  : visitor_base(), Functions(functions)... {
    register_(functions...);
  }
#else
  pmte_visitor() noexcept(std::is_nothrow_default_constructible<detail::visitor_base>::value) : visitor_base() {}
#endif

  pmte_visitor(pmte_visitor &&) = default;
  pmte_visitor(pmte_visitor const & other) = default;
  pmte_visitor & operator=(pmte_visitor &&) = default;
  pmte_visitor & operator=(pmte_visitor const &) = default;

  FORCE_INLINE HOT_FUNC bool operator()(pmte_value & o) const { return process(o); }

  FORCE_INLINE HOT_FUNC bool operator()(pmte_value const & o) const { return process(o); }

  HOT_FUNC bool operator()(pmte_value * o) const { return o ? process(*o) : false; }

  HOT_FUNC bool operator()(pmte_value const * o) const { return o ? process(*o) : false; }

  template <typename T, std::enable_if_t<std::is_base_of<pmte_value, T>::value> * = nullptr>
  HOT_FUNC bool operator()(std::unique_ptr<T> && o) const {
    return o ? process(*o) : false;
  }

  template <typename T, std::enable_if_t<std::is_base_of<pmte_value, T>::value> * = nullptr>
  HOT_FUNC bool operator()(std::unique_ptr<T> const & o) const {
    return o ? process(*o) : false;
  }

  template <typename T, std::enable_if_t<std::is_base_of<pmte_value, T>::value> * = nullptr>
  HOT_FUNC bool operator()(std::shared_ptr<T> && o) const {
    return o ? process(*o) : false;
  }

  template <typename T, std::enable_if_t<std::is_base_of<pmte_value, T>::value> * = nullptr>
  HOT_FUNC bool operator()(std::shared_ptr<T> const & o) const {
    return o ? process(*o) : false;
  }
};

#if __cplusplus >= CPP17_STANDARD
template <typename Visitor, typename... PMTEs>
constexpr auto visit(Visitor && vis, PMTEs &&... pmtes) {
  (vis(pmtes), ...);
}
#else
template <typename Visitor, typename First, typename... PMTEs>
constexpr auto visit(Visitor && vis, First && first, PMTEs &&... pmtes) {
  vis(std::forward<First>(first));
  visit(std::forward<Visitor>(vis), std::forward<PMTEs>(pmtes)...);
}

template <typename Visitor, typename First>
constexpr auto visit(Visitor && vis, First && first) {
  vis(std::forward<First>(first));
}
#endif

template <typename Visitor, typename ForwardIt>
constexpr auto visit(Visitor && vis, ForwardIt first, ForwardIt last) {
  while (first != last) {
    vis(*first);
    first = std::next(first);
  }
}

} // namespace pmte

} // namespace util

#endif /* INCLUDE__UTIL__PMTE_HPP */
