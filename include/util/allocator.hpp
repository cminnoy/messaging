/**
 * @file allocator.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__UTIL__ALLOCATOR_HPP
#define INCLUDE__UTIL__ALLOCATOR_HPP

#include <util/attributes.hpp>

#if __has_include(<memory_resource>)

#if __cplusplus < CPP17_STANDARD
#error Minimum required standard is C++17.
#else

static_assert(__cplusplus >= CPP17_STANDARD, "Minimum required standard is C++17.");

#ifdef _MSC_BUILD
#include <iso646.h>
#endif

#include <util/logger.hpp>

#include <memory_resource>
#include <memory>
#include <algorithm>
#include <cstddef>
#include <iostream>

namespace util {

#ifdef WITH_TRACY
/**
 * @brief Polymorphic Memory Allocator proxy for Tracy statistics.
 * 
 */
class memory_resource_tracy : public std::pmr::memory_resource {
  std::pmr::memory_resource * allocator;
  char * name;

public:
  memory_resource_tracy(std::pmr::memory_resource * alloc, char const * const name) noexcept;

private:
  [[nodiscard]] void * do_allocate(std::size_t bytes, std::size_t alignment) override;
  void do_deallocate(void * p, std::size_t bytes, std::size_t alignment) override;

  bool do_is_equal(const std::pmr::memory_resource & other) const noexcept override { return allocator->is_equal(other); }
};
#endif

/**
 * @brief Polymorphic Memory Allocator statistics.
 * 
 */
class memory_resource_counter : public std::pmr::memory_resource {
  friend std::ostream & operator<<(std::ostream &, const memory_resource_counter &);

  std::size_t m_allocations = 0;
  std::size_t m_deallocations = 0;
  std::size_t m_allocated_memory = 0;
  std::pmr::memory_resource * allocator;

public:
  memory_resource_counter(std::pmr::memory_resource * alloc) noexcept : allocator(alloc) {}

  std::size_t allocations() const { return m_allocations; }
  std::size_t deallocations() const { return m_deallocations; }
  std::size_t allocated_memory() const { return m_allocated_memory; }

private:

  [[nodiscard]] void * do_allocate(std::size_t bytes, std::size_t alignment) override;
  void do_deallocate(void * p, std::size_t bytes, std::size_t alignment) override;

  bool do_is_equal(const std::pmr::memory_resource & other) const noexcept override { return allocator->is_equal(other); }
};

std::ostream & operator<<(std::ostream &, const memory_resource_counter &);

/**
 * @brief Old-style allocator interface that acts as proxy towards a new style PMR allocator.
 * 
 * @tparam T 
 */
template <typename T>
class pmr_allocator final {
  using allocator_type = std::shared_ptr<T>;

  allocator_type allocator;
  inline static allocator_type static_allocator;

  static void prepare() {
    if (not static_allocator) static_allocator = std::make_shared<T>();
  }

  static void destroy() {
    if (static_allocator.use_count() == 1) static_allocator.reset();
  }

#ifndef NDEBUG
  inline static std::size_t m_allocations = 0;
  inline static std::size_t m_deallocations = 0;
  inline static std::size_t m_allocated_memory = 0;
#endif

public:

  pmr_allocator() {
    prepare();
    allocator = static_allocator;
  }
  pmr_allocator(pmr_allocator &&) noexcept = default;
  pmr_allocator(const pmr_allocator &) noexcept = default;
  pmr_allocator & operator=(pmr_allocator &&) noexcept = default;
  pmr_allocator & operator=(const pmr_allocator &) noexcept = default;
  ~pmr_allocator() noexcept {
    allocator.reset();
    destroy();
  };

  [[nodiscard]] inline static void * allocate(std::size_t bytes, std::size_t alignment) {
#ifndef NDEBUG
    ++m_allocations;
    m_allocated_memory += bytes;
#endif
    return static_allocator->allocate(bytes, alignment);
  }

  inline static void deallocate(void * p, std::size_t bytes) {
#ifndef NDEBUG
    ++m_deallocations;
    m_allocated_memory -= bytes;
#endif
    static_allocator->deallocate(p, bytes);
  };

  inline allocator_type get_instance() { return allocator; }

  inline static void release() {
#ifndef NDEBUG
    m_allocated_memory = 0;
#endif
    static_allocator->release();
  }

#ifndef NDEBUG
  std::size_t allocations() const { return m_allocations; }
  std::size_t deallocations() const { return m_deallocations; }
  std::size_t allocated_memory() const { return m_allocated_memory; }
#endif
};

//! @brief Default unsynchronized allocator proxy.
using unsynchronized_allocator = pmr_allocator<std::pmr::unsynchronized_pool_resource>;
//! @brief Default thread synchronized allocator proxy.
using synchronized_allocator = pmr_allocator<std::pmr::synchronized_pool_resource>;

/**
 * @brief Old-style allocator class that acts as an interface towards another allocator.
 * 
 * @tparam T value type
 * @tparam PA proxy allocator
 */
template <typename T, typename PA = synchronized_allocator>
class allocator {
public:
  using value_type = T;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;
  using propagate_on_container_move_assignment = std::true_type;
  using proxy_allocator = PA;

  constexpr allocator() noexcept(noexcept(PA())) {}
  constexpr allocator(allocator &&) noexcept = default;
  constexpr allocator(const allocator &) noexcept = default;
  template <class U>
  constexpr allocator(const allocator<U, PA> &) noexcept {}
  constexpr allocator & operator=(allocator &&) noexcept = default;
  constexpr allocator & operator=(const allocator &) noexcept = default;
  ~allocator() noexcept = default;

  [[nodiscard]] T * allocate(std::size_t n);
  void deallocate(T * p, std::size_t n);

  template <typename U>
  constexpr bool operator==(const allocator<U, PA> &) const noexcept {
    return true;
  }

private:
  PA pa;
};

template <typename T, typename U, typename PA>
constexpr bool operator!=(const allocator<T, PA> & lhs, const allocator<U, PA> & rhs) {
  return not lhs.operator==(rhs);
}

template <typename T, typename PA>
[[nodiscard]] inline T * allocator<T, PA>::allocate(std::size_t n) {
  return static_cast<T *>(pa.allocate(n * sizeof(T), std::min(sizeof(T), alignof(std::max_align_t))));
}

template <typename T, typename PA>
inline void allocator<T, PA>::deallocate(T * p, std::size_t n) {
  return pa.deallocate(p, n * sizeof(T));
}

} // namespace util

template <typename T, typename Allocator>
[[nodiscard]] inline T * allocate_object(Allocator & alloc, std::size_t n = 1) {
  return static_cast<T *>(alloc.allocate(n * sizeof(T), std::min(sizeof(T), alignof(std::max_align_t))));
}

template <typename T, typename Allocator>
inline void deallocate_object(Allocator & alloc, T * p, std::size_t n = 1) {
  alloc.deallocate(p, n);
}

template <typename T, typename Allocator, class... CtorArgs>
[[nodiscard]] T * new_object(Allocator & alloc, CtorArgs &&... ctor_args) {
  T * p = allocate_object<T>(alloc);
  try {
    new (p) T(std::forward<CtorArgs>(ctor_args)...);
  } catch (...) {
    deallocate_object<T>(alloc, p);
    throw;
  }
  return p;
}

template <typename T, typename Allocator>
void delete_object(Allocator & alloc, T * p) {
  if (p) {
    p->~T();
    deallocate_object(alloc, p);
  }
}

#endif // C++17

#endif // memory resource support

#if defined(WITH_TRACY) && defined(TRACY_ENABLE)
//* Overloads for global default allocator/deallocator to enable Tracy memory logging
void * operator new(std::size_t count) {
  auto ptr = malloc(count);
  TracySecureAlloc(ptr, count);
  return ptr;
}

void * operator new[](std::size_t count) {
  auto ptr = malloc(count);
  TracySecureAlloc(ptr, count);
  return ptr;
}

void operator delete(void * ptr) noexcept {
  TracySecureFree(ptr);
  free(ptr);
}

void operator delete[](void * ptr) noexcept {
  TracySecureFree(ptr);
  free(ptr);
}
#endif

#endif /* INCLUDE__UTIL__ALLOCTOR_HPP */
