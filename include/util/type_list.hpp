/**
 * @file type_list.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2023
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#ifndef INCLUDE__UTIL__TYPE_LIST_HPP
#define INCLUDE__UTIL__TYPE_LIST_HPP

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#include <tuple>
#include <util/type_info.hpp>

/**
 * @file
 * 
 * Type list manipulation
 */

namespace util {

/**
 * @brief List of type information.
 * @tparam Types template parameter pack of types
 */
template <typename... Types>
using type_list = std::tuple<type_info<Types>...>;

/**
 * @brief Convert a type list into a tuple of plain types.
 * @return Returns a tuple of plain types (compile time).
 */
//@{
template <typename T>
struct remove_type_info;

template <typename T>
struct remove_type_info<type_info<T>> {
  typedef T type;
};

template <typename... Types>
struct remove_type_info<type_list<Types...>> {
  typedef std::tuple<Types...> type;
};

template <typename T>
using remove_type_info_t = typename remove_type_info<T>::type;
//@}

/**
 * @brief Get first element of a type_list as a new type_list.
 * @return Returns a new type_list containing only the first element of the source type_list (compile time).
 */
//@{
template <typename Head = void, typename... Tail>
struct type_list_head {
  typedef type_list<> type;
};

template <typename... Types>
using type_list_head_t = typename type_list_head<Types...>::type;

template <typename Head, typename... Tail>
struct type_list_head<type_list<Head, Tail...>> {
  typedef type_list<Head> type;
};
//@}

/**
 * @brief Get all elements after the first element of a type_list as a new type_list.
 * @return Returns a new type_list with all elements except the first one (compile time).
 */
//@{
template <typename Head = void>
struct type_list_tail {
  typedef type_list<> type;
};

template <typename... Types>
using type_list_tail_t = typename type_list_tail<Types...>::type;

template <typename Head, typename... Tail>
struct type_list_tail<type_list<Head, Tail...>> {
  typedef type_list<Tail...> type;
};
//@}

/**
 * @brief Swap the first and second element of a type_list.
 * @return Returns a new type_list with the first and second element exchanged places (compile time).
 */
//@{
template <typename First = void, typename Second = void, typename... Tail>
struct type_list_swap_first_and_second_element {
  typedef std::tuple<> type;
};

template <typename... Types>
using type_list_swap_first_and_second_t = typename type_list_swap_first_and_second_element<Types...>::type;

template <typename First>
struct type_list_swap_first_and_second_element<type_list<First>> {
  typedef type_list<First> type;
};

template <typename First, typename Second, typename... Tail>
struct type_list_swap_first_and_second_element<type_list<First, Second, Tail...>> {
  typedef type_list<Second, First, Tail...> type;
};
//@}

/**
 * @brief Concatenate one or more type lists into a new type list.
 * @return Returns a new type list holding all the types provided by the source type lists (compile time).
 */
//@{
template <typename T, typename...>
struct type_list_cat {
  using type = T;
};

template <typename... Ts1, typename... Ts2, typename... Ts3>
struct type_list_cat<type_list<Ts1...>, type_list<Ts2...>, Ts3...> : public type_list_cat<type_list<Ts1..., Ts2...>, Ts3...> {};

template <typename... TypeLists>
using type_list_cat_t = typename type_list_cat<TypeLists...>::type;
//@}

/**
 * @brief Get Nth element of a type list.
 * @return Returns the Nth type_info instance of the list.
 */
//@{
namespace detail {

template <class T>
using Invoke = typename T::type;

template <std::size_t...>
struct seq {
  using type = seq;
};

template <class S1, class S2>
struct concat;

template <std::size_t... I1, std::size_t... I2>
struct concat<seq<I1...>, seq<I2...>> : seq<I1..., (sizeof...(I1) + I2)...> {};

template <class S1, class S2>
using Concat = Invoke<concat<S1, S2>>;

template <std::size_t N>
struct gen_seq;
template <std::size_t N>
using GenSeq = Invoke<gen_seq<N>>;

template <std::size_t N>
struct gen_seq : Concat<GenSeq<N / 2>, GenSeq<N - N / 2>> {};

template <>
struct gen_seq<0> : seq<> {};
template <>
struct gen_seq<1> : seq<0> {};

template <std::size_t>
struct Any {
  Any(...) {}
};

template <typename T>
struct wrapper {
  using type = T;
};

template <std::size_t... Is>
struct get_nth_helper {
  template <typename T>
  static auto deduce(Any<Is>..., wrapper<T>, ...) -> wrapper<T>;
};

template <std::size_t... Is, typename... Ts>
auto deduce_seq(seq<Is...>, wrapper<Ts>... pp) -> decltype(get_nth_helper<Is...>::deduce(pp...));

} // namespace detail

template <std::size_t n, typename TypeList>
struct type_list_element;

template <std::size_t n, typename... Ts>
struct type_list_element<n, type_list<Ts...>> {
private:
  using wrapped_type = decltype(detail::deduce_seq(detail::gen_seq<n> {}, detail::wrapper<Ts>()...));

public:
  using type = typename wrapped_type::type;
};

template <std::size_t I, typename T>
using type_list_element_t = typename type_list_element<I, T>::type;
//@}

/**
 * @brief Get Nth element element of a type list as a new type list.
 * @return A type list with a single element.
 */
//@{
template <std::size_t I, typename TypeList>
struct type_list_element_as_type_list {
  typedef type_list<type_list_element_t<I, TypeList>> type;
};

template <std::size_t I, typename T>
using type_list_element_as_type_list_t = typename type_list_element_as_type_list<I, T>::type;
//@}

/**
 * @brief Provides the number of elements in the type list (compile time).
 * @tparam TypeList 
 */
template <typename TypeList>
struct type_list_size : std::integral_constant<std::size_t, std::tuple_size<TypeList>::value> {};

/**
 * @brief Check is a specific type is an element of a type list.
 * @return True if the member is contained in the type list, otherwise false (compile time).
 */
//@{
template <typename T, typename TypeList>
struct type_list_contains_type;

template <typename T>
struct type_list_contains_type<T, type_list<>> : std::false_type {};

template <typename T, typename TypeList>
struct type_list_contains_type
: std::integral_constant<bool, std::is_same<T, type_list_element_t<0, TypeList>>::value || type_list_contains_type<T, type_list_tail_t<TypeList>>::value> {
};
//@}

/**
 * @brief Create type list that contains each unique type only once.
 * @return New type list with each provided type only once (compile time).
 */
//@{
template <typename... Types>
struct type_list_make_unique {
  using type = type_list<>;
};

template <typename Head, typename... Tail>
struct type_list_make_unique<type_list<Head, Tail...>> {
  using type = typename std::conditional<type_list_contains_type<Head, type_list<Tail...>>::value,
    typename type_list_make_unique<type_list<Tail...>>::type,
    type_list_cat_t<type_list<Head>, typename type_list_make_unique<type_list<Tail...>>::type>>::type;
};

template <typename... Types>
using type_list_make_unique_t = typename type_list_make_unique<Types...>::type;
//@}

//@{

namespace detail {

template <typename T>
struct type_list_sort_pass1;

template <>
struct type_list_sort_pass1<type_list<>> {
  using type = type_list<>;
};

template <typename Head>
struct type_list_sort_pass1<type_list<Head>> {
  using type = type_list<Head>;
};

template <typename Head, typename... Tail>
struct type_list_sort_pass1<type_list<Head, Tail...>> {
private:
  using first = Head;
  using second = type_list_element_t<0, type_list_head_t<type_list<Tail...>>>;

  CPP17_INLINE static constexpr bool is_same = std::is_same<std::decay_t<first>, std::decay_t<second>>::value;
  CPP17_INLINE static constexpr bool
    sub_is_same = std::is_same<std::decay_t<std::remove_pointer_t<first>>, std::decay_t<std::remove_pointer_t<second>>>::value;

  CPP17_INLINE static constexpr bool first_is_const = std::is_const<std::remove_pointer_t<first>>::value;
  CPP17_INLINE static constexpr bool second_is_const = std::is_const<std::remove_pointer_t<second>>::value;
  CPP17_INLINE static constexpr bool const_ok = is_same ? (not first_is_const and second_is_const) : true;
  CPP17_INLINE static constexpr bool sub_const_ok = sub_is_same ? (not first_is_const and second_is_const) : true;

  CPP17_INLINE static constexpr bool first_is_class = std::is_class<first>::value;
  CPP17_INLINE static constexpr bool second_is_class = std::is_class<second>::value;

  CPP17_INLINE static constexpr bool first_is_indirect_class = std::is_pointer<first>::value ?
    std::is_class<std::remove_pointer_t<first>>::value :
    false;
  CPP17_INLINE static constexpr bool second_is_indirect_class = std::is_pointer<second>::value ?
    std::is_class<std::remove_pointer_t<second>>::value :
    false;

  CPP17_INLINE static constexpr bool first_is_pointer = std::is_pointer<first>::value;
  CPP17_INLINE static constexpr bool second_is_pointer = std::is_pointer<second>::value;

  CPP17_INLINE static constexpr bool base_ok = std::is_base_of<std::remove_pointer_t<second>, std::remove_pointer_t<first>>::value;

  CPP17_INLINE static constexpr bool must_swap = (is_same && !const_ok) || (sub_is_same && !sub_const_ok) ||
    (first_is_class && second_is_class && !base_ok) || (first_is_indirect_class && second_is_indirect_class && !base_ok) ||
    (!first_is_indirect_class && !first_is_class && second_is_indirect_class) || (!first_is_class && second_is_class) ||
    (!first_is_pointer && !first_is_class && second_is_pointer);

  using head = typename std::conditional<must_swap, type_list_head_t<type_list<Tail...>>, type_list<Head>>::type;
  using tail = typename std::conditional<must_swap, type_list_cat_t<type_list<Head>, type_list_tail_t<type_list<Tail...>>>, type_list<Tail...>>::type;

public:
  using type = type_list_cat_t<head, typename type_list_sort_pass1<tail>::type>;
};

template <typename TypeList, std::size_t I>
struct type_list_sort_pass2 {
  using type = typename type_list_sort_pass2<typename detail::type_list_sort_pass1<TypeList>::type, I - 1>::type;
};

template <typename TypeList>
struct type_list_sort_pass2<TypeList, 0> {
  using type = typename detail::type_list_sort_pass1<TypeList>::type;
};

} // namespace detail

template <typename TypeList>
struct type_list_sort;

template <typename TypeList>
struct type_list_sort {
  using type = typename detail::type_list_sort_pass2<TypeList, type_list_size<TypeList>::value>::type;
};

template <typename TypeList>
using type_list_sort_t = typename type_list_sort<TypeList>::type;
//@}

} // namespace util

#endif /* INCLUDE__UTIL__TYPE_LIST_HPP */
