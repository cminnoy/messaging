/**
 * @file logger.hpp
 * @author Chris Minnoy
 * @version 1.0
 * @date 2022
 * 
 * @copyright Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include <util/attributes.hpp>

static_assert(__cplusplus >= CPP14_STANDARD, "Minimum required standard is C++14.");

#ifndef INCLUDE__UTIL__LOGGER_HPP_
#define INCLUDE__UTIL__LOGGER_HPP_

#include <ostream>
#include <chrono>
#include <vector>
#include <tuple>
#include <type_traits>
#include <string>
#include <initializer_list>

#include <util/shared_library.hpp>
#include <util/attributes.hpp>
#include <util/traits.hpp>

#include <boost/preprocessor.hpp>

#define THROW_NOT_IMPLEMENTED                                      \
  ::util::throw_not_implemented(__FILE__, __FUNCTION__, __LINE__); \
  exit(1);

namespace util {
namespace logger {

#define TRACER_MODULE_NAME "global"

#define TRACER_MODULE(name, banner_text)                                        \
  namespace {                                                                   \
    MAYBE_UNUSED const std::string module_name =                                \
      ::util::logger::register_module(name, {banner_text});                     \
  }
#ifdef WITH_TRACER_SUPPORT

DLL_PUBLIC extern const std::string & module_name;

// clang-format off
#if !defined(__PRETTY_FUNCTION__) && !defined(__GNUC__)
#define __PRETTY_FUNCTION__ __FUNCSIG__
#endif

#define _ARG16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) _15
#define HAS_COMMA(...) _ARG16(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)
#define _TRIGGER_PARENTHESIS_(...) ,
 
#define ISEMPTY(...)                                                                  \
_ISEMPTY(                                                                             \
          /* test if there is just one argument, eventually an empty one */           \
          HAS_COMMA(__VA_ARGS__),                                                     \
          /* test if _TRIGGER_PARENTHESIS_ together with the argument adds a comma */ \
          HAS_COMMA(_TRIGGER_PARENTHESIS_ __VA_ARGS__),                               \
          /* test if the argument together with a parenthesis adds a comma */         \
          HAS_COMMA(__VA_ARGS__ (/*empty*/)),                                         \
          /* test if placing it between _TRIGGER_PARENTHESIS_ and the                 \
             parenthesis adds a comma */                                              \
          HAS_COMMA(_TRIGGER_PARENTHESIS_ __VA_ARGS__ (/*empty*/))                    \
          )
 
#define PASTE5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4
#define _ISEMPTY(_0, _1, _2, _3) HAS_COMMA(PASTE5(_IS_EMPTY_CASE_, _0, _1, _2, _3))
#define _IS_EMPTY_CASE_0001 ,

#define __TRACER_FUNC_PRINT_ARG_IMP(r, elem)                                    \
  (logger::costream&)__tracer__ << '\n';                                        \
  ((logger::costream&)__tracer__).indent();                                     \
  (logger::costream&)__tracer__                                                 \
    << ANSI_FG_YELLOW ">>> "                                                    \
    << logger::reset_attributes                                                 \
    << logger::bold                                                             \
    << "arg" #r " " #elem ": "                                                  \
    << logger::plain;                                                           \
    util::logger::detail::print(__tracer__, elem);

#define __TRACER_FUNC_PRINT_ARG(r, data, elem)                                  \
  __TRACER_FUNC_PRINT_ARG_IMP(r, elem)

#define __TRACER_FUNC_PRINT_ARGS(...)                                           \
  BOOST_PP_IF(                                                                  \
    ISEMPTY(__VA_ARGS__),                                                       \
    __TRACER_FUNC_DO_NOTHING,                                                   \
    BOOST_PP_SEQ_FOR_EACH(                                                      \
      __TRACER_FUNC_PRINT_ARG, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))         \
    )

#define __TRACER_FUNC_DO_NOTHING(...) ;

#define TRACER_COMPONENT_FUNC(COMPONENT_NAME, ...)                              \
  namespace logger = ::util::logger;                                            \
  static unsigned long long __TRACER__counter = 0;                              \
  ++__TRACER__counter;                                                          \
  struct __TRACER__ {                                                           \
    const std::string & n_;                                                     \
    const int l_;                                                               \
    const std::string fu_;                                                      \
    const char *const fi_;                                                      \
    const unsigned int pl_;                                                     \
    std::chrono::time_point<std::chrono::steady_clock> start_time_;             \
    __TRACER__(const std::string & n, const int l,                              \
               std::string fu, const char *const fi)                            \
        : n_(n), l_(l), fu_(fu), fi_(fi), pl_(logger::trace.get_linenumber())   \
    {                                                                           \
      logger::enter_module(n_);                                                 \
      logger::trace                                                             \
          << logger::fg_byellow << "===>>> "                                    \
          << logger::fg_bmagenta << fu_                                         \
          << logger::fg_default << " (defined at " << fi_ << ':' << l_          \
          << ") (call " << __TRACER__counter << ')';                            \
    }                                                                           \
    ~__TRACER__()                                                               \
    {                                                                           \
      using namespace std::literals;                                            \
      const std::chrono::time_point<std::chrono::steady_clock> end_time =       \
        std::chrono::steady_clock::now();                                       \
      const auto calculation_time = end_time - start_time_;                     \
      logger::trace                                                             \
          << logger::fg_byellow << "<<<=== "                                    \
          << logger::fg_bmagenta << fu_                                         \
          << logger::fg_default << " (defined at " << fi_ << ':' << l_          \
          << ")";                                                               \
      if (logger::trace.show_linenumber())                                      \
          logger::trace << " (entered at log line " << pl_ << ')';              \
      logger::trace << " (" << (calculation_time / 1ms) << " ms)";              \
      logger::trace << std::endl;                                               \
      logger::leave_module();                                                   \
    }                                                                           \
    operator logger::costream&() {                                              \
      return logger::trace;                                                     \
    }                                                                           \
  } __tracer__(COMPONENT_NAME,__LINE__,                                         \
               INSIDE_LAMBDA ? std::string(ANSI_FG_CYAN "lambda ") +            \
                               ANSI_FG_WHITE "@ " ANSI_FG_MAGENTA +             \
                               std::string(LAMBDA_OUTER_FUNC_NAME())            \
                             : std::string(__FUNCTION__), __FILE__);            \
  BOOST_PP_IF(                                                                  \
    BOOST_PP_GREATER_EQUAL(BOOST_PP_VARIADIC_SIZE(__VA_ARGS__),1),              \
      __TRACER_FUNC_PRINT_ARGS,                                                 \
      __TRACER_FUNC_DO_NOTHING) (__VA_ARGS__)                                   \
  (logger::costream&)__tracer__                                                 \
    << logger::reset_attributes                                                 \
    << std::endl;                                                               \
  __tracer__.start_time_ = std::chrono::steady_clock::now();                    \
  using namespace ::util::logger;

#define __TRACER_FUNC_SIMPLE_RETURN(...)                                        \
  (logger::costream&)__tracer__                                                 \
    << logger::fg_byellow << "   <<< "                                          \
    << logger::reset_attributes                                                 \
    << logger::fg_bmagenta << __tracer__.fu_                                    \
    << reset_attributes << logger::bold()                                       \
    << " return "                                                               \
    << reset_attributes << logger::fg_bwhite                                    \
    << "(exit at "                                                              \
    << __tracer__.fi_ << ':' << __LINE__ << ')' << std::endl;                   \
  return;

#define __TRACER_FUNC_ARG_RETURN(r, data, elem)                                 \
  (logger::costream&)__tracer__                                                 \
    << logger::fg_byellow << "   <<< "                                          \
    << logger::reset_attributes                                                 \
    << logger::fg_bmagenta << __tracer__.fu_                                    \
    << reset_attributes << logger::bold                                         \
    << " return " << logger::fg_bblue                                           \
    << type_name<decltype(elem)>() << logger::fg_bwhite                         \
    << '(' << elem << ") " << reset_attributes << "(exit at "                   \
    << __tracer__.fi_ << ':' << __LINE__ << ')' << std::endl;                   \
  return elem;

#define TRACER_COMPONENT_RETURN(...)                                            \
  BOOST_PP_IF(                                                                  \
    ISEMPTY(__VA_ARGS__),                                                       \
    __TRACER_FUNC_SIMPLE_RETURN(),                                              \
    BOOST_PP_SEQ_FOR_EACH(                                                      \
      __TRACER_FUNC_ARG_RETURN, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))        \
    )

#define TRACER_FUNC(...)                                                        \
  TRACER_COMPONENT_FUNC(TRACER_MODULE_NAME, ##__VA_ARGS__)

#define TRACER_RETURN(...)                                                      \
  TRACER_COMPONENT_RETURN(__VA_ARGS__)

#define TRACER_TRACE(exp)                                                       \
  ::util::logger::trace << ::util::logger::fg_bwhite << exp                     \
                        << ::util::logger::fg_default;                          \
  ::util::logger::trace << " (at line " << __LINE__                             \
                        << " of file " << __FILE__ << ")" << std::endl;

#else

/* no WITH_TRACER_SUPPORT */

#define TRACER_COMPONENT_RETURN(...)                                            \
  return __VA_ARGS__;

#define TRACER_COMPONENT_FUNC(COMPONENT_NAME, ...)                              \
  namespace logger = ::util::logger;                                            \
  logger::enter_module(COMPONENT_NAME);                                         \
  struct __TRACER__ {                                                           \
    ~__TRACER__() {                                                             \
     logger::leave_module();                                                    \
    }                                                                           \
  } __tracer__;                                                                 \
  using namespace ::util::logger;

#define TRACER_FUNC(...)                                                        \
  TRACER_COMPONENT_FUNC(TRACER_MODULE_NAME, ##__VA_ARGS__)

#define TRACER_RETURN(...)                                                      \
  return __VA_ARGS__;

#define TRACER_TRACE(exp)

#endif /* WITH_TRACER_SUPPORT */

struct DLL_PUBLIC banner { std::string value; };
struct DLL_PUBLIC attribute {
  const unsigned int value;
  constexpr attribute() : value(0) {}
  constexpr attribute(unsigned int v) : value(v){}
};
constexpr struct reset_attributes final : attribute {} reset_attributes;

// CSI
constexpr struct plain final : attribute { constexpr plain() : attribute(0) {} } plain;
constexpr struct bold final : attribute { constexpr bold() : attribute(1) {} } bold;
constexpr struct faint final : attribute { constexpr faint() : attribute(2) {} } faint;
constexpr struct italic final : attribute { constexpr italic() : attribute(3) {} } italic;
constexpr struct underline final : attribute { constexpr underline() : attribute(4) {} } underline;
constexpr struct slow_blink final : attribute { constexpr slow_blink() : attribute(5) {} } slow_blink;
constexpr struct rapid_blink final : attribute { constexpr rapid_blink() : attribute(6) {} } rapid_blink;

// Foreground colours
constexpr struct fg_default final : attribute { constexpr fg_default() : attribute(39) {} } fg_default;
constexpr struct fg_black final : attribute { constexpr fg_black() : attribute(30) {} } fg_black;
constexpr struct fg_red final : attribute { constexpr fg_red() : attribute(31) {} } fg_red;
constexpr struct fg_green final : attribute { constexpr fg_green() : attribute(32) {} } fg_green;
constexpr struct fg_yellow final : attribute { constexpr fg_yellow() : attribute(33) {} } fg_yellow;
constexpr struct fg_blue final : attribute { constexpr fg_blue() : attribute(34) {} } fg_blue;
constexpr struct fg_magenta final : attribute { constexpr fg_magenta() : attribute(35) {} } fg_magenta;
constexpr struct fg_cyan final : attribute { constexpr fg_cyan() : attribute(36) {} } fg_cyan;
constexpr struct fg_white final : attribute { constexpr fg_white() : attribute(37) {} } fg_white;
// Bright foreground colours
constexpr struct fg_bblack final : attribute { constexpr fg_bblack() : attribute(90) {} } fg_bblack;
constexpr struct fg_bred final : attribute { constexpr fg_bred() : attribute(91) {} } fg_bred;
constexpr struct fg_bgreen final : attribute { constexpr fg_bgreen() : attribute(92) {} } fg_bgreen;
constexpr struct fg_byellow final : attribute { constexpr fg_byellow() : attribute(93) {} } fg_byellow;
constexpr struct fg_bblue final : attribute { constexpr fg_bblue() : attribute(94) {} } fg_bblue;
constexpr struct fg_bmagenta final : attribute { constexpr fg_bmagenta() : attribute(95) {} } fg_bmagenta;
constexpr struct fg_bcyan final : attribute { constexpr fg_bcyan() : attribute(96) {} } fg_bcyan;
constexpr struct fg_bwhite final : attribute { constexpr fg_bwhite() : attribute(97) {} } fg_bwhite;
// Background colours
constexpr struct bg_default final : attribute { constexpr bg_default() : attribute(49) {} } bg_default;
constexpr struct bg_black final : attribute { constexpr bg_black() : attribute(40) {} } bg_black;
constexpr struct bg_red final : attribute { constexpr bg_red() : attribute(41) {} } bg_red;
constexpr struct bg_green final : attribute { constexpr bg_green() : attribute(42) {} } bg_green;
constexpr struct bg_yellow final : attribute { constexpr bg_yellow() : attribute(43) {} } bg_yellow;
constexpr struct bg_blue final : attribute { constexpr bg_blue() : attribute(44) {} } bg_blue;
constexpr struct bg_magenta final : attribute { constexpr bg_magenta() : attribute(45) {} } bg_magenta;
constexpr struct bg_cyan final : attribute { constexpr bg_cyan() : attribute(46) {} } bg_cyan;
constexpr struct bg_white final : attribute { constexpr bg_white() : attribute(47) {} } bg_white;
// Bright background colours
constexpr struct bg_bblack final : attribute { constexpr bg_bblack() : attribute(100) {} } bg_bblack;
constexpr struct bg_bred final : attribute { constexpr bg_bred() : attribute(101) {} } bg_bred;
constexpr struct bg_bgreen final : attribute { constexpr bg_bgreen() : attribute(102) {} } bg_bgreen;
constexpr struct bg_byellow final : attribute { constexpr bg_byellow() : attribute(103) {} } bg_byellow;
constexpr struct bg_bblue final : attribute { constexpr bg_bblue() : attribute(104) {} } bg_bblue;
constexpr struct bg_bmagenta final : attribute { constexpr bg_bmagenta() : attribute(105) {} } bg_bmagenta;
constexpr struct bg_bcyan final : attribute { constexpr bg_bcyan() : attribute(106) {} } bg_bcyan;
constexpr struct bg_bwhite final : attribute { constexpr bg_bwhite() : attribute(107) {} } bg_bwhite;
// clang-format on

class DLL_PUBLIC costream : public std::ostream {
public:
  using std::ostream::ostream;
  /**
   * Enable or disable stream.
   * @param flag new value
   * @return previous value
   */
  bool enable(bool flag);
  /**
   * Query stream state.
   * @return current value
   */
  bool is_enabled() const;
  /**
   * Allow ANSI token to pass thru or not.
   * @param flag new value
   * @return previous value
   */
  bool allow_ansi(bool flag);
  /**
   * Show time.
   * @param flag new value
   * @return previous value
   */
  bool show_time(bool flag);
  /**
   * Show line numbers in front.
   * @param flag new value
   * @return previous value
   */
  bool show_linenumber(bool flag);
  /**
   * Query flag 
   * @return flag
   */
  bool show_linenumber() const;
  /**
   * Show thread name.
   * @param flag new value
   * @return previous value
   */
  bool show_thread(bool flag);
  /**
   * Show module name.
   * @param flag new value
   * @return previous value
   */
  bool show_module(bool flag);

  /**
   * Allow function arguments to be indented to match trace entry.
   * @param flag new value
   * @return previous value
   */
  bool allow_indent(bool flag);
  /**
   * Query flag
   * @return flag
   */
  bool allow_indent() const;
  /**
   * Apply argument indentation
   * Ignored when allow indent is false
   */
  void indent();
  /**
   * Assign new stream.
   */
  void set_stream(std::ostream &);
  /**
   * Query current stream.
   */
  std::ostream & get_stream() const;
  /**
   * Clear buffers.
   */
  void clear();
  /**
   * Returns the line number in the output stream.
   * @return line number
   */
  static unsigned int get_linenumber();
};

DLL_PUBLIC extern costream debug;   //!< For programmatic debug information indicating a bug in the system
DLL_PUBLIC extern costream trace;   //!< For runtime trace information
DLL_PUBLIC extern costream info;    //!< For algorithmic information useful to understand the current state
DLL_PUBLIC extern costream warning; //!< For life system warnings
DLL_PUBLIC extern costream error;   //!< For serious system errors and failure
DLL_PUBLIC extern costream stats;   //!< For performance statistics
DLL_PUBLIC extern costream null;    //!< For piping to nothingness
DLL_PUBLIC extern costream test;    //!< For output during unit testing

#if __cplusplus >= 201703L
namespace detail {

template <bool...>
struct bool_pack;

template <bool... v>
using all_true = std::is_same<bool_pack<true, v...>, bool_pack<v..., true>>;

} // namespace detail

template <typename... Attributes, typename = std::enable_if_t<(std::is_base_of_v<attribute, Attributes> && ...)>>
std::ostream & operator<<(std::ostream & out, std::tuple<Attributes...> attr_lst) {
  std::apply([&](const auto &... e) { (operator<<(out, e), ...); }, attr_lst);
  return out;
}
#endif

DLL_PUBLIC std::string register_module(std::string module_name);
DLL_PUBLIC std::string register_module(std::string module_name, std::string short_module_name);
DLL_PUBLIC void unregister_module(std::string module_name);
DLL_PUBLIC void enter_module(const std::string & module_name);
DLL_PUBLIC void leave_module();
DLL_PUBLIC bool enable_module(std::string module_name, bool flag);
DLL_PUBLIC const std::string & active_module();

DLL_PUBLIC std::ostream & operator<<(std::ostream &, banner);
DLL_PUBLIC std::ostream & operator<<(std::ostream &, const attribute &);
DLL_PUBLIC std::ostream & operator<<(std::ostream &, const std::initializer_list<attribute> &);
DLL_PUBLIC std::ostream & operator<<(std::ostream &, const std::vector<attribute> &);

namespace detail {

template <typename U>
typename std::enable_if_t<is_ostream_operator_available<U>::value, costream &> print(costream & out, U const & value) {
  out << value;
  return out;
}

template <typename U>
typename std::enable_if_t<!is_ostream_operator_available<U>::value, costream &> print(costream & out, U const &) {
  out << fg_red << "argument is unprintable with type " << fg_bblue << type_name<U>() << plain;
  return out;
}

} // namespace detail

} // namespace logger

DLL_PUBLIC void throw_not_implemented(char const * file_name, char const * function_name, int linenumber);

} // namespace util

// clang-format off
#define ANSI_TOK "\033[1;36m"
#define ANSI_LBL "\033[95m"
#define ANSI_NRM "\033[0m"

#define ANSI_PLAIN "\033[0m"
#define ANSI_BOLD "\033[1m"
#define ANSI_FAINT "\033[2m"
#define ANSI_ITALIC "\033[3m"
#define ANSI_UNDERLINE "\033[4m"
#define ANSI_SLOW_BLINK "\033[5m"
#define ANSI_RAPID_BLINK "\033[6m"

#define ANSI_FG_BLACK "\033[90m"
#define ANSI_FG_RED "\033[91m"
#define ANSI_FG_GREEN "\033[92m"
#define ANSI_FG_YELLOW "\033[93m"
#define ANSI_FG_BLUE "\033[94m"
#define ANSI_FG_MAGENTA "\033[95m"
#define ANSI_FG_CYAN "\033[96m"
#define ANSI_FG_WHITE "\033[97m"
// clang-format on

#endif /* INCLUDE__UTIL__LOGGER_HPP_ */
